Index: Application/Shell/ShellEnvVar.c
===================================================================
--- Application/Shell/ShellEnvVar.c	(revision 13225)
+++ Application/Shell/ShellEnvVar.c	(working copy)
@@ -157,6 +157,9 @@
     Status = EFI_SUCCESS;
     MaxVarSize = 16384;
   }
+  
+  // dmazar: AMI Aptio 2.0 returns 0 as MaxVarSize - fix it
+  if (MaxVarSize <= 0) MaxVarSize = 16384;
 
   NameSize = (UINTN)MaxVarSize;
   VariableName = AllocateZeroPool(NameSize);
Index: Application/Shell/ShellProtocol.c
===================================================================
--- Application/Shell/ShellProtocol.c	(revision 13225)
+++ Application/Shell/ShellProtocol.c	(working copy)
@@ -1912,7 +1912,6 @@
   FileInfo          = NULL;
   Status            = EFI_SUCCESS;
 
-
   for ( Status = FileHandleFindFirstFile(FileDirHandle, &FileInfo)
       ; !EFI_ERROR(Status) && !NoFile
       ; Status = FileHandleFindNextFile(FileDirHandle, FileInfo, &NoFile)
@@ -2897,6 +2896,9 @@
   Status = gRT->QueryVariableInfo(EFI_VARIABLE_NON_VOLATILE|EFI_VARIABLE_BOOTSERVICE_ACCESS, &MaxStorSize, &RemStorSize, &MaxVarSize);
   ASSERT_EFI_ERROR(Status);
 
+  // dmazar: AMI Aptio 2.0 returns 0 as MaxVarSize - fix it
+  if (MaxVarSize <= 0) MaxVarSize = 16384;
+  
   VariableName  = AllocateZeroPool((UINTN)MaxVarSize);
   RetSize       = 0;
   RetVal        = NULL;
Index: Library/UefiFileHandleLib/UefiFileHandleLib.c
===================================================================
--- Library/UefiFileHandleLib/UefiFileHandleLib.c	(revision 13225)
+++ Library/UefiFileHandleLib/UefiFileHandleLib.c	(working copy)
@@ -19,7 +19,10 @@
 
 #include <Guid/FileInfo.h>
 
+#include <Library/UefiLib.h>
+
 #include <Library/DebugLib.h>
+#include <Library/UefiBootServicesTableLib.h>
 #include <Library/MemoryAllocationLib.h>
 #include <Library/BaseLib.h>
 #include <Library/BaseMemoryLib.h>
@@ -68,13 +71,13 @@
   Status = FileHandle->GetInfo(FileHandle,
                                &gEfiFileInfoGuid,
                                &FileInfoSize,
-                               NULL);
+                               FileInfo);
   if (Status == EFI_BUFFER_TOO_SMALL){
     //
     // error is expected.  getting size to allocate
+    // dmazar: some drivers do not count 0 at the end of file name
+    FileInfo = AllocateZeroPool(FileInfoSize + 2);
     //
-    FileInfo = AllocateZeroPool(FileInfoSize);
-    //
     // now get the information
     //
     Status = FileHandle->GetInfo(FileHandle,
@@ -834,14 +837,31 @@
         break;
       } else {
         //
-        // We got info... do we have a name? if yes preceed the current path with it...
+        // We got info... do we have a name and parent? if yes preceed the current path with name
         //
-        if (StrLen (FileInfo->FileName) == 0) {
+		//Print(L"FileName='%s', Attr = 0x%lx\n", FileInfo->FileName, FileInfo->Attribute);
+        //
+        // dmazar: Some drivers returns Volume name as root dir name - check
+		// for end of parent path by opening parent directory.
+        //
+        Status = CurrentHandle->Open (CurrentHandle, &NextHigherHandle, L"..", EFI_FILE_MODE_READ, 0);
+        //Print(L"parent dir: %r\n", Status);
+        if (StrLen (FileInfo->FileName) == 0
+            // dmazar: we'll treat error as signal that there is not parent any more
+			|| EFI_ERROR (Status)
+		) {
           if (*FullFileName == NULL) {
             ASSERT((*FullFileName == NULL && Size == 0) || (*FullFileName != NULL));
             *FullFileName = StrnCatGrowLeft(FullFileName, &Size, L"\\", 0);
+			//Print(L"*FullFileName='%s'\n", *FullFileName);
           }
+		  //Print(L"FreePool\n");
           FreePool(FileInfo);
+		  //gBS->FreePool(FileInfo);
+		  if (Status == EFI_SUCCESS) {
+		    FileHandleClose(NextHigherHandle);
+		  }
+		  Status = EFI_SUCCESS;
           break;
         } else {
           if (*FullFileName == NULL) {
@@ -851,17 +871,14 @@
           ASSERT((*FullFileName == NULL && Size == 0) || (*FullFileName != NULL));
           *FullFileName = StrnCatGrowLeft(FullFileName, &Size, FileInfo->FileName, 0);
           *FullFileName = StrnCatGrowLeft(FullFileName, &Size, L"\\", 0);
+			//Print(L"*FullFileName='%s'\n", *FullFileName);
+		  //Print(L"FreePool\n");
           FreePool(FileInfo);
+		  //gBS->FreePool(FileInfo);
         }
       }
-      //
-      // Move to the parent directory
-      //
-      Status = CurrentHandle->Open (CurrentHandle, &NextHigherHandle, L"..", EFI_FILE_MODE_READ, 0);
-      if (EFI_ERROR (Status)) {
-        break;
-      }
 
+	  //Print(L"FileHandleClose\n");
       FileHandleClose(CurrentHandle);
       CurrentHandle = NextHigherHandle;
     }
@@ -872,9 +889,11 @@
   }
 
   if (CurrentHandle != NULL) {
+	//Print(L"CurrentHandle->Close\n");
     CurrentHandle->Close (CurrentHandle);
   }
 
+  //Print(L"Status=%r, *FullFileName='%s'\n", Status, *FullFileName);
   if (EFI_ERROR(Status) && *FullFileName != NULL) {
     FreePool(*FullFileName);
   }
Index: Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePath.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePath.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePath.c	(working copy)
@@ -0,0 +1,101 @@
+/** @file
+  Device Path Driver to produce DevPathUtilities Protocol, DevPathFromText Protocol
+  and DevPathToText Protocol.
+
+Copyright (c) 2006 - 2008, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "DevicePath.h"
+#include <Library/UefiLib.h>
+
+EFI_HANDLE  mDevicePathHandle = NULL;
+
+GLOBAL_REMOVE_IF_UNREFERENCED CONST EFI_DEVICE_PATH_UTILITIES_PROTOCOL mDevicePathUtilities = {
+  GetDevicePathSizeProtocolInterface,
+  DuplicateDevicePathProtocolInterface,
+  AppendDevicePathProtocolInterface,
+  AppendDeviceNodeProtocolInterface,
+  AppendDevicePathInstanceProtocolInterface,
+  GetNextDevicePathInstanceProtocolInterface,
+  IsDevicePathMultiInstanceProtocolInterface,
+  CreateDeviceNodeProtocolInterface
+};
+
+GLOBAL_REMOVE_IF_UNREFERENCED CONST EFI_DEVICE_PATH_TO_TEXT_PROTOCOL   mDevicePathToText = {
+  ConvertDeviceNodeToText,
+  ConvertDevicePathToText
+};
+
+GLOBAL_REMOVE_IF_UNREFERENCED CONST EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL mDevicePathFromText = {
+  ConvertTextToDeviceNode,
+  ConvertTextToDevicePath
+};
+
+GLOBAL_REMOVE_IF_UNREFERENCED CONST EFI_GUID mEfiDevicePathMessagingUartFlowControlGuid = DEVICE_PATH_MESSAGING_UART_FLOW_CONTROL;
+GLOBAL_REMOVE_IF_UNREFERENCED CONST EFI_GUID mEfiDevicePathMessagingSASGuid             = DEVICE_PATH_MESSAGING_SAS;
+
+
+
+/**
+  The user Entry Point for DevicePath module.
+
+  This is the entry point for DevicePath module. It installs the UEFI Device Path Utility Protocol and
+  optionally the Device Path to Text and Device Path from Text protocols based on feature flags.
+
+  @param[in] ImageHandle    The firmware allocated handle for the EFI image.
+  @param[in] SystemTable    A pointer to the EFI System Table.
+
+  @retval EFI_SUCCESS       The entry point is executed successfully.
+  @retval Others            Some error occurs when executing this entry point.
+
+**/
+EFI_STATUS
+EFIAPI
+DevicePathEntryPoint (
+  IN EFI_HANDLE           ImageHandle,
+  IN EFI_SYSTEM_TABLE     *SystemTable
+  )
+{
+  EFI_STATUS  Status;
+  VOID        *Instance;
+
+  Status = EFI_ALREADY_STARTED;
+  
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiDevicePathUtilitiesProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiDevicePathUtilitiesProtocolGuid already installed\n");
+  } else {
+      Status = gBS->InstallMultipleProtocolInterfaces (
+                      &mDevicePathHandle,
+                      &gEfiDevicePathUtilitiesProtocolGuid, &mDevicePathUtilities,
+                      NULL
+                      );
+  }
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiDevicePathToTextProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiDevicePathToTextProtocolGuid already installed\n");
+  } else {
+      Status = gBS->InstallMultipleProtocolInterfaces (
+                      &mDevicePathHandle,
+                      &gEfiDevicePathToTextProtocolGuid,    &mDevicePathToText,
+                      NULL
+                      );
+  }
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiDevicePathFromTextProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiDevicePathFromTextProtocolGuid already installed\n");
+  } else {
+      Status = gBS->InstallMultipleProtocolInterfaces (
+                      &mDevicePathHandle,
+                      &gEfiDevicePathFromTextProtocolGuid,  &mDevicePathFromText,
+                      NULL
+                      );
+  }
+
+  return Status;
+}
Index: Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePath.h
===================================================================
--- Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePath.h	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePath.h	(working copy)
@@ -0,0 +1,433 @@
+/** @file
+  Definition for Device Path Utilities driver
+
+Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _DEVICE_PATH_DRIVER_H_
+#define _DEVICE_PATH_DRIVER_H_
+
+#include <Uefi.h>
+#include <Protocol/DevicePathUtilities.h>
+#include <Protocol/DebugPort.h>
+#include <Protocol/DevicePathToText.h>
+#include <Protocol/DevicePathFromText.h>
+#include <Guid/PcAnsi.h>
+#include <Library/DebugLib.h>
+#include <Library/PrintLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/PcdLib.h>
+
+#define IS_COMMA(a)                ((a) == L',')
+#define IS_HYPHEN(a)               ((a) == L'-')
+#define IS_DOT(a)                  ((a) == L'.')
+#define IS_LEFT_PARENTH(a)         ((a) == L'(')
+#define IS_RIGHT_PARENTH(a)        ((a) == L')')
+#define IS_SLASH(a)                ((a) == L'/')
+#define IS_NULL(a)                 ((a) == L'\0')
+
+
+#define SET_DEVICE_PATH_INSTANCE_END_NODE(a) {                   \
+    (a)->Type       = END_DEVICE_PATH_TYPE;                      \
+    (a)->SubType    = END_INSTANCE_DEVICE_PATH_SUBTYPE;          \
+    (a)->Length[0]  = (UINT8) sizeof (EFI_DEVICE_PATH_PROTOCOL); \
+    (a)->Length[1]  = 0;                                         \
+  }
+
+//
+// Private Data structure
+//
+typedef struct {
+  CHAR16  *Str;
+  UINTN   Length;
+  UINTN   Capacity;
+} POOL_PRINT;
+
+typedef
+EFI_DEVICE_PATH_PROTOCOL  *
+(*DUMP_NODE) (
+  IN  CHAR16 *DeviceNodeStr
+  );
+
+typedef
+VOID
+(*DEVICE_PATH_TO_TEXT_FUNC) (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  );
+
+typedef struct {
+  UINT8                     Type;
+  UINT8                     SubType;
+  DEVICE_PATH_TO_TEXT_FUNC  Function;
+} DEVICE_PATH_TO_TEXT_TABLE;
+
+typedef struct {
+  CHAR16                    *DevicePathNodeText;
+  DUMP_NODE                 Function;
+} DEVICE_PATH_FROM_TEXT_TABLE;
+
+typedef struct {
+  BOOLEAN ClassExist;
+  UINT8   Class;
+  BOOLEAN SubClassExist;
+  UINT8   SubClass;
+} USB_CLASS_TEXT;
+
+#define USB_CLASS_AUDIO            1
+#define USB_CLASS_CDCCONTROL       2
+#define USB_CLASS_HID              3
+#define USB_CLASS_IMAGE            6
+#define USB_CLASS_PRINTER          7
+#define USB_CLASS_MASS_STORAGE     8
+#define USB_CLASS_HUB              9
+#define USB_CLASS_CDCDATA          10
+#define USB_CLASS_SMART_CARD       11
+#define USB_CLASS_VIDEO            14
+#define USB_CLASS_DIAGNOSTIC       220
+#define USB_CLASS_WIRELESS         224
+
+#define USB_CLASS_RESERVE          254
+#define USB_SUBCLASS_FW_UPDATE     1
+#define USB_SUBCLASS_IRDA_BRIDGE   2
+#define USB_SUBCLASS_TEST          3
+
+#define RFC_1700_UDP_PROTOCOL      17
+#define RFC_1700_TCP_PROTOCOL      6
+
+#pragma pack(1)
+
+typedef struct {
+  EFI_DEVICE_PATH_PROTOCOL  Header;
+  EFI_GUID                  Guid;
+  UINT8                     VendorDefinedData[1];
+} VENDOR_DEFINED_HARDWARE_DEVICE_PATH;
+
+typedef struct {
+  EFI_DEVICE_PATH_PROTOCOL  Header;
+  EFI_GUID                  Guid;
+  UINT8                     VendorDefinedData[1];
+} VENDOR_DEFINED_MESSAGING_DEVICE_PATH;
+
+typedef struct {
+  EFI_DEVICE_PATH_PROTOCOL  Header;
+  EFI_GUID                  Guid;
+  UINT8                     VendorDefinedData[1];
+} VENDOR_DEFINED_MEDIA_DEVICE_PATH;
+
+typedef struct {
+  EFI_DEVICE_PATH_PROTOCOL  Header;
+  UINT32                    Hid;
+  UINT32                    Uid;
+  UINT32                    Cid;
+  CHAR8                     HidUidCidStr[3];
+} ACPI_EXTENDED_HID_DEVICE_PATH_WITH_STR;
+
+typedef struct {
+  EFI_DEVICE_PATH_PROTOCOL  Header;
+  UINT16                    NetworkProtocol;
+  UINT16                    LoginOption;
+  UINT64                    Lun;
+  UINT16                    TargetPortalGroupTag;
+  CHAR8                     TargetName[1];
+} ISCSI_DEVICE_PATH_WITH_NAME;
+
+typedef struct {
+  EFI_DEVICE_PATH_PROTOCOL  Header;
+  EFI_GUID                  Guid;
+  UINT8                     VendorDefinedData[1];
+} VENDOR_DEVICE_PATH_WITH_DATA;
+
+#pragma pack()
+
+/**
+  Converts a device node to its string representation.
+
+  @param DeviceNode        A Pointer to the device node to be converted.
+  @param DisplayOnly       If DisplayOnly is TRUE, then the shorter text representation
+                           of the display node is used, where applicable. If DisplayOnly
+                           is FALSE, then the longer text representation of the display node
+                           is used.
+  @param AllowShortcuts    If AllowShortcuts is TRUE, then the shortcut forms of text
+                           representation for a device node can be used, where applicable.
+
+  @return A pointer to the allocated text representation of the device node or NULL if DeviceNode
+          is NULL or there was insufficient memory.
+
+**/
+CHAR16 *
+EFIAPI
+ConvertDeviceNodeToText (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL  *DeviceNode,
+  IN BOOLEAN                         DisplayOnly,
+  IN BOOLEAN                         AllowShortcuts
+  );
+
+/**
+  Converts a device path to its text representation.
+
+  @param DevicePath      A Pointer to the device to be converted.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+  @return A pointer to the allocated text representation of the device path or
+          NULL if DeviceNode is NULL or there was insufficient memory.
+
+**/
+CHAR16 *
+EFIAPI
+ConvertDevicePathToText (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL   *DevicePath,
+  IN BOOLEAN                          DisplayOnly,
+  IN BOOLEAN                          AllowShortcuts
+  );
+
+/**
+  Convert text to the binary representation of a device node.
+
+  @param TextDeviceNode  TextDeviceNode points to the text representation of a device
+                         node. Conversion starts with the first character and continues
+                         until the first non-device node character.
+
+  @return A pointer to the EFI device node or NULL if TextDeviceNode is NULL or there was
+          insufficient memory or text unsupported.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+ConvertTextToDeviceNode (
+  IN CONST CHAR16 *TextDeviceNode
+  );
+
+/**
+  Convert text to the binary representation of a device path.
+
+
+  @param TextDevicePath  TextDevicePath points to the text representation of a device
+                         path. Conversion starts with the first character and continues
+                         until the first non-device node character.
+
+  @return A pointer to the allocated device path or NULL if TextDeviceNode is NULL or
+          there was insufficient memory.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+ConvertTextToDevicePath (
+  IN CONST CHAR16 *TextDevicePath
+  );
+
+/**
+  Returns the size of a device path in bytes.
+
+  This function returns the size, in bytes, of the device path data structure specified by
+  DevicePath including the end of device path node.  If DevicePath is NULL, then 0 is returned.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+
+  @return The size of a device path in bytes.
+
+**/
+UINTN
+EFIAPI
+GetDevicePathSizeProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL  *DevicePath
+  );
+
+/**
+  Creates a new device path by appending a second device path to a first device path.
+
+  This function allocates space for a new copy of the device path specified by DevicePath.  If
+  DevicePath is NULL, then NULL is returned.  If the memory is successfully allocated, then the
+  contents of DevicePath are copied to the newly allocated buffer, and a pointer to that buffer
+  is returned.  Otherwise, NULL is returned.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+
+  @return A pointer to the duplicated device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+DuplicateDevicePathProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL  *DevicePath
+  );
+
+/**
+  Creates a new device path by appending a second device path to a first device path.
+
+  This function creates a new device path by appending a copy of SecondDevicePath to a copy of
+  FirstDevicePath in a newly allocated buffer.  Only the end-of-device-path device node from
+  SecondDevicePath is retained. The newly created device path is returned.
+  If FirstDevicePath is NULL, then it is ignored, and a duplicate of SecondDevicePath is returned.
+  If SecondDevicePath is NULL, then it is ignored, and a duplicate of FirstDevicePath is returned.
+  If both FirstDevicePath and SecondDevicePath are NULL, then a copy of an end-of-device-path is
+  returned.
+  If there is not enough memory for the newly allocated buffer, then NULL is returned.
+  The memory for the new device path is allocated from EFI boot services memory. It is the
+  responsibility of the caller to free the memory allocated.
+
+  @param  FirstDevicePath            A pointer to a device path data structure.
+  @param  SecondDevicePath           A pointer to a device path data structure.
+
+  @return A pointer to the new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+AppendDevicePathProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *FirstDevicePath,
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *SecondDevicePath
+  );
+
+/**
+  Creates a new path by appending the device node to the device path.
+
+  This function creates a new device path by appending a copy of the device node specified by
+  DevicePathNode to a copy of the device path specified by DevicePath in an allocated buffer.
+  The end-of-device-path device node is moved after the end of the appended device node.
+  If DevicePathNode is NULL then a copy of DevicePath is returned.
+  If DevicePath is NULL then a copy of DevicePathNode, followed by an end-of-device path device
+  node is returned.
+  If both DevicePathNode and DevicePath are NULL then a copy of an end-of-device-path device node
+  is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+  @param  DevicePathNode             A pointer to a single device path node.
+
+  @return A pointer to the new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+AppendDeviceNodeProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath,
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePathNode
+  );
+
+/**
+  Creates a new device path by appending the specified device path instance to the specified device
+  path.
+
+  This function creates a new device path by appending a copy of the device path instance specified
+  by DevicePathInstance to a copy of the device path specified by DevicePath in a allocated buffer.
+  The end-of-device-path device node is moved after the end of the appended device path instance
+  and a new end-of-device-path-instance node is inserted between.
+  If DevicePath is NULL, then a copy if DevicePathInstance is returned.
+  If DevicePathInstance is NULL, then NULL is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+  @param  DevicePathInstance         A pointer to a device path instance.
+
+  @return A pointer to the new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+AppendDevicePathInstanceProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath,
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePathInstance
+  );
+
+/**
+  Creates a copy of the current device path instance and returns a pointer to the next device path
+  instance.
+
+  This function creates a copy of the current device path instance. It also updates DevicePath to
+  point to the next device path instance in the device path (or NULL if no more) and updates Size
+  to hold the size of the device path instance copy.
+  If DevicePath is NULL, then NULL is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+  If Size is NULL, then ASSERT().
+
+  @param  DevicePath                 On input, this holds the pointer to the current device path
+                                     instance. On output, this holds the pointer to the next device
+                                     path instance or NULL if there are no more device path
+                                     instances in the device path pointer to a device path data
+                                     structure.
+  @param  Size                       On output, this holds the size of the device path instance, in
+                                     bytes or zero, if DevicePath is NULL.
+
+  @return A pointer to the current device path instance.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+GetNextDevicePathInstanceProtocolInterface (
+  IN OUT EFI_DEVICE_PATH_PROTOCOL   **DevicePath,
+  OUT UINTN                         *Size
+  );
+
+/**
+  Determines if a device path is single or multi-instance.
+
+  This function returns TRUE if the device path specified by DevicePath is multi-instance.
+  Otherwise, FALSE is returned.  If DevicePath is NULL, then FALSE is returned.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+
+  @retval  TRUE                      DevicePath is multi-instance.
+  @retval  FALSE                     DevicePath is not multi-instance or DevicePath is NULL.
+
+**/
+BOOLEAN
+EFIAPI
+IsDevicePathMultiInstanceProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath
+  );
+
+/**
+  Creates a copy of the current device path instance and returns a pointer to the next device path
+  instance.
+
+  This function creates a new device node in a newly allocated buffer of size NodeLength and
+  initializes the device path node header with NodeType and NodeSubType.  The new device path node
+  is returned.
+  If NodeLength is smaller than a device path header, then NULL is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+
+  @param  NodeType                   The device node type for the new device node.
+  @param  NodeSubType                The device node sub-type for the new device node.
+  @param  NodeLength                 The length of the new device node.
+
+  @return The new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+CreateDeviceNodeProtocolInterface (
+  IN UINT8  NodeType,
+  IN UINT8  NodeSubType,
+  IN UINT16 NodeLength
+  );
+
+#endif
Index: Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathDxe.inf
===================================================================
--- Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathDxe.inf	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathDxe.inf	(working copy)
@@ -0,0 +1,75 @@
+## @file
+#  Device path driver that produces three UEFI device path protocols.
+#
+#  This driver produces Device Path Utilities protocol and optionally
+#  DevicePahtToText and DevicePathFromText protocols based on feature flags
+#  PcdDevicePathSupportDevicePathToText & PcdDevicePathSupportDevicePathFromText
+#  respectively.
+#
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = DevicePathDxe
+  FILE_GUID                      = 9B680FCE-AD6B-4F3A-B60B-F59899003443
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = DevicePathEntryPoint
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  DevicePathUtilities.c
+  DevicePathToText.c   ||||gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText
+  DevicePathFromText.c ||||gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText
+  DevicePath.h
+  DevicePath.c
+
+[Packages]
+  MdeModulePkg/MdeModulePkg.dec
+  MdePkg/MdePkg.dec
+
+[LibraryClasses]
+  PcdLib
+  DevicePathLib
+  UefiBootServicesTableLib
+  MemoryAllocationLib
+  BaseMemoryLib
+  BaseLib
+  UefiDriverEntryPoint
+  PrintLib
+  DebugLib
+
+[Guids]
+  gEfiVTUTF8Guid         | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiVT100Guid          | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiVT100PlusGuid      | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiPcAnsiGuid         | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiUartDevicePathGuid | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiSasDevicePathGuid  | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  
+[Protocols]
+  gEfiDevicePathToTextProtocolGuid   | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText ## PRODUCES
+  gEfiDevicePathFromTextProtocolGuid | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## PRODUCES
+  gEfiDevicePathUtilitiesProtocolGuid ## PRODUCES
+  gEfiDebugPortProtocolGuid          | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+
+[FeaturePcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText
+
+[Depex]
+  TRUE
Index: Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathFromText.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathFromText.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathFromText.c	(working copy)
@@ -0,0 +1,3155 @@
+/** @file
+  DevicePathFromText protocol as defined in the UEFI 2.0 specification.
+
+Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "DevicePath.h"
+
+
+/**
+
+  Duplicates a string.
+
+  @param  Src  Source string.
+
+  @return The duplicated string.
+
+**/
+CHAR16 *
+StrDuplicate (
+  IN CONST CHAR16  *Src
+  )
+{
+  return AllocateCopyPool (StrSize (Src), Src);
+}
+
+/**
+
+  Get parameter in a pair of parentheses follow the given node name.
+  For example, given the "Pci(0,1)" and NodeName "Pci", it returns "0,1".
+
+  @param  Str      Device Path Text.
+  @param  NodeName Name of the node.
+
+  @return Parameter text for the node.
+
+**/
+CHAR16 *
+GetParamByNodeName (
+  IN CHAR16 *Str,
+  IN CHAR16 *NodeName
+  )
+{
+  CHAR16  *ParamStr;
+  CHAR16  *StrPointer;
+  UINTN   NodeNameLength;
+  UINTN   ParameterLength;
+
+  //
+  // Check whether the node name matchs
+  //
+  NodeNameLength = StrLen (NodeName);
+  if (CompareMem (Str, NodeName, NodeNameLength * sizeof (CHAR16)) != 0) {
+    return NULL;
+  }
+
+  ParamStr = Str + NodeNameLength;
+  if (!IS_LEFT_PARENTH (*ParamStr)) {
+    return NULL;
+  }
+
+  //
+  // Skip the found '(' and find first occurrence of ')'
+  //
+  ParamStr++;
+  ParameterLength = 0;
+  StrPointer = ParamStr;
+  while (!IS_NULL (*StrPointer)) {
+    if (IS_RIGHT_PARENTH (*StrPointer)) {
+      break;
+    }
+    StrPointer++;
+    ParameterLength++;
+  }
+  if (IS_NULL (*StrPointer)) {
+    //
+    // ')' not found
+    //
+    return NULL;
+  }
+
+  ParamStr = AllocateCopyPool ((ParameterLength + 1) * sizeof (CHAR16), ParamStr);
+  if (ParamStr == NULL) {
+    return NULL;
+  }
+  //
+  // Terminate the parameter string
+  //
+  ParamStr[ParameterLength] = L'\0';
+
+  return ParamStr;
+}
+
+/**
+  Gets current sub-string from a string list, before return
+  the list header is moved to next sub-string. The sub-string is separated
+  by the specified character. For example, the separator is ',', the string
+  list is "2,0,3", it returns "2", the remain list move to "0,3"
+
+  @param  List        A string list separated by the specified separator
+  @param  Separator   The separator character
+
+  @return A pointer to the current sub-string
+
+**/
+CHAR16 *
+SplitStr (
+  IN OUT CHAR16 **List,
+  IN     CHAR16 Separator
+  )
+{
+  CHAR16  *Str;
+  CHAR16  *ReturnStr;
+
+  Str = *List;
+  ReturnStr = Str;
+
+  if (IS_NULL (*Str)) {
+    return ReturnStr;
+  }
+
+  //
+  // Find first occurrence of the separator
+  //
+  while (!IS_NULL (*Str)) {
+    if (*Str == Separator) {
+      break;
+    }
+    Str++;
+  }
+
+  if (*Str == Separator) {
+    //
+    // Find a sub-string, terminate it
+    //
+    *Str = L'\0';
+    Str++;
+  }
+
+  //
+  // Move to next sub-string
+  //
+  *List = Str;
+
+  return ReturnStr;
+}
+
+/**
+  Gets the next parameter string from the list.
+
+  @param List            A string list separated by the specified separator
+
+  @return A pointer to the current sub-string
+
+**/
+CHAR16 *
+GetNextParamStr (
+  IN OUT CHAR16 **List
+  )
+{
+  //
+  // The separator is comma
+  //
+  return SplitStr (List, L',');
+}
+
+/**
+  Get one device node from entire device path text.
+
+  @param DevicePath      On input, the current Device Path node; on output, the next device path node
+  @param IsInstanceEnd   This node is the end of a device path instance
+
+  @return A device node text or NULL if no more device node available
+
+**/
+CHAR16 *
+GetNextDeviceNodeStr (
+  IN OUT CHAR16   **DevicePath,
+  OUT    BOOLEAN  *IsInstanceEnd
+  )
+{
+  CHAR16  *Str;
+  CHAR16  *ReturnStr;
+  UINTN   ParenthesesStack;
+
+  Str = *DevicePath;
+  if (IS_NULL (*Str)) {
+    return NULL;
+  }
+
+  //
+  // Skip the leading '/', '(', ')' and ','
+  //
+  while (!IS_NULL (*Str)) {
+    if (!IS_SLASH (*Str) &&
+        !IS_COMMA (*Str) &&
+        !IS_LEFT_PARENTH (*Str) &&
+        !IS_RIGHT_PARENTH (*Str)) {
+      break;
+    }
+    Str++;
+  }
+
+  ReturnStr = Str;
+
+  //
+  // Scan for the separator of this device node, '/' or ','
+  //
+  ParenthesesStack = 0;
+  while (!IS_NULL (*Str)) {
+    if ((IS_COMMA (*Str) || IS_SLASH (*Str)) && (ParenthesesStack == 0)) {
+      break;
+    }
+
+    if (IS_LEFT_PARENTH (*Str)) {
+      ParenthesesStack++;
+    } else if (IS_RIGHT_PARENTH (*Str)) {
+      ParenthesesStack--;
+    }
+
+    Str++;
+  }
+
+  if (ParenthesesStack != 0) {
+    //
+    // The '(' doesn't pair with ')', invalid device path text
+    //
+    return NULL;
+  }
+
+  if (IS_COMMA (*Str)) {
+    *IsInstanceEnd = TRUE;
+    *Str = L'\0';
+    Str++;
+  } else {
+    *IsInstanceEnd = FALSE;
+    if (!IS_NULL (*Str)) {
+      *Str = L'\0';
+      Str++;
+    }
+  }
+
+  *DevicePath = Str;
+
+  return ReturnStr;
+}
+
+
+/**
+  Skip the leading white space and '0x' or '0X' of a integer string
+
+  @param Str             The integer string
+  @param IsHex           TRUE: Hex string, FALSE: Decimal string
+
+  @return The trimmed Hex string.
+
+**/
+CHAR16 *
+TrimHexStr (
+  IN CHAR16   *Str,
+  OUT BOOLEAN *IsHex
+  )
+{
+  *IsHex = FALSE;
+
+  //
+  // skip preceeding white space
+  //
+  while ((*Str != 0) && *Str == ' ') {
+    Str += 1;
+  }
+  //
+  // skip preceeding zeros
+  //
+  while ((*Str != 0) && *Str == '0') {
+    Str += 1;
+  }
+  //
+  // skip preceeding character 'x' or 'X'
+  //
+  if ((*Str != 0) && (*Str == 'x' || *Str == 'X')) {
+    Str += 1;
+    *IsHex = TRUE;
+  }
+
+  return Str;
+}
+
+/**
+
+  Convert hex string to uint.
+
+  @param Str             The hex string
+
+  @return A UINTN value represented by Str
+
+**/
+UINTN
+Xtoi (
+  IN CHAR16  *Str
+  )
+{
+  return StrHexToUintn (Str);
+}
+
+/**
+
+  Convert hex string to 64 bit data.
+
+  @param Str             The hex string
+  @param Data            A pointer to the UINT64 value represented by Str
+
+**/
+VOID
+Xtoi64 (
+  IN  CHAR16  *Str,
+  OUT UINT64  *Data
+  )
+{
+  *Data = StrHexToUint64 (Str);
+}
+
+/**
+
+  Convert decimal string to uint.
+
+  @param Str             The decimal string
+
+  @return A UINTN value represented by Str
+
+**/
+UINTN
+Dtoi (
+  IN CHAR16  *Str
+  )
+{
+  UINTN   Rvalue;
+  CHAR16  Char;
+  UINTN   High;
+  UINTN   Low;
+
+  ASSERT (Str != NULL);
+
+  High = (UINTN) -1 / 10;
+  Low  = (UINTN) -1 % 10;
+  //
+  // skip preceeding white space
+  //
+  while ((*Str != 0) && *Str == ' ') {
+    Str += 1;
+  }
+  //
+  // convert digits
+  //
+  Rvalue = 0;
+  Char = *(Str++);
+  while (Char != 0) {
+    if (Char >= '0' && Char <= '9') {
+      if ((Rvalue > High || Rvalue == High) && (Char - '0' > (INTN) Low)) {
+        return (UINTN) -1;
+      }
+
+      Rvalue = (Rvalue * 10) + Char - '0';
+    } else {
+      break;
+    }
+
+    Char = *(Str++);
+  }
+
+  return Rvalue;
+}
+
+/**
+
+  Convert decimal string to uint.
+
+  @param Str             The decimal string
+  @param Data            A pointer to the UINT64 value represented by Str
+
+**/
+VOID
+Dtoi64 (
+  IN CHAR16  *Str,
+  OUT UINT64 *Data
+  )
+{
+  UINT64   Rvalue;
+  CHAR16   Char;
+  UINT64   High;
+  UINT64   Low;
+
+  ASSERT (Str != NULL);
+  ASSERT (Data != NULL);
+
+  //
+  // skip preceeding white space
+  //
+  while ((*Str != 0) && *Str == ' ') {
+    Str += 1;
+  }
+  //
+  // convert digits
+  //
+  Rvalue = 0;
+  Char = *(Str++);
+  while (Char != 0) {
+    if (Char >= '0' && Char <= '9') {
+      High = LShiftU64 (Rvalue, 3);
+      Low = LShiftU64 (Rvalue, 1);
+      Rvalue = High + Low + Char - '0';
+    } else {
+      break;
+    }
+
+    Char = *(Str++);
+  }
+
+  *Data = Rvalue;
+}
+
+/**
+
+  Convert integer string to uint.
+
+  @param Str             The integer string. If leading with "0x" or "0X", it's hexadecimal.
+
+  @return A UINTN value represented by Str
+
+**/
+UINTN
+Strtoi (
+  IN CHAR16  *Str
+  )
+{
+  BOOLEAN IsHex;
+
+  Str = TrimHexStr (Str, &IsHex);
+
+  if (IsHex) {
+    return Xtoi (Str);
+  } else {
+    return Dtoi (Str);
+  }
+}
+
+/**
+
+  Convert integer string to 64 bit data.
+
+  @param Str             The integer string. If leading with "0x" or "0X", it's hexadecimal.
+  @param Data            A pointer to the UINT64 value represented by Str
+
+**/
+VOID
+Strtoi64 (
+  IN  CHAR16  *Str,
+  OUT UINT64  *Data
+  )
+{
+  BOOLEAN IsHex;
+
+  Str = TrimHexStr (Str, &IsHex);
+
+  if (IsHex) {
+    Xtoi64 (Str, Data);
+  } else {
+    Dtoi64 (Str, Data);
+  }
+}
+
+/**
+  Converts a list of string to a specified buffer.
+
+  @param Buf             The output buffer that contains the string.
+  @param BufferLength    The length of the buffer
+  @param Str             The input string that contains the hex number
+
+  @retval EFI_SUCCESS    The string was successfully converted to the buffer.
+
+**/
+EFI_STATUS
+StrToBuf (
+  OUT UINT8    *Buf,
+  IN  UINTN    BufferLength,
+  IN  CHAR16   *Str
+  )
+{
+  UINTN       Index;
+  UINTN       StrLength;
+  UINT8       Digit;
+  UINT8       Byte;
+
+  Digit = 0;
+
+  //
+  // Two hex char make up one byte
+  //
+  StrLength = BufferLength * sizeof (CHAR16);
+
+  for(Index = 0; Index < StrLength; Index++, Str++) {
+
+    if ((*Str >= L'a') && (*Str <= L'f')) {
+      Digit = (UINT8) (*Str - L'a' + 0x0A);
+    } else if ((*Str >= L'A') && (*Str <= L'F')) {
+      Digit = (UINT8) (*Str - L'A' + 0x0A);
+    } else if ((*Str >= L'0') && (*Str <= L'9')) {
+      Digit = (UINT8) (*Str - L'0');
+    } else {
+      return EFI_INVALID_PARAMETER;
+    }
+
+    //
+    // For odd characters, write the upper nibble for each buffer byte,
+    // and for even characters, the lower nibble.
+    //
+    if ((Index & 1) == 0) {
+      Byte = (UINT8) (Digit << 4);
+    } else {
+      Byte = Buf[Index / 2];
+      Byte &= 0xF0;
+      Byte = (UINT8) (Byte | Digit);
+    }
+
+    Buf[Index / 2] = Byte;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Converts a string to GUID value.
+  Guid Format is xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
+
+  @param Str              The registry format GUID string that contains the GUID value.
+  @param Guid             A pointer to the converted GUID value.
+
+  @retval EFI_SUCCESS     The GUID string was successfully converted to the GUID value.
+  @retval EFI_UNSUPPORTED The input string is not in registry format.
+  @return others          Some error occurred when converting part of GUID value.
+
+**/
+EFI_STATUS
+StrToGuid (
+  IN  CHAR16   *Str,
+  OUT EFI_GUID *Guid
+  )
+{
+  //
+  // Get the first UINT32 data
+  //
+  Guid->Data1 = (UINT32) StrHexToUint64  (Str);
+  while (!IS_HYPHEN (*Str) && !IS_NULL (*Str)) {
+    Str ++;
+  }
+  
+  if (IS_HYPHEN (*Str)) {
+    Str++;
+  } else {
+    return EFI_UNSUPPORTED;
+  }
+  
+  //
+  // Get the second UINT16 data
+  //
+  Guid->Data2 = (UINT16) StrHexToUint64  (Str);
+  while (!IS_HYPHEN (*Str) && !IS_NULL (*Str)) {
+    Str ++;
+  }
+
+  if (IS_HYPHEN (*Str)) {
+    Str++;
+  } else {
+    return EFI_UNSUPPORTED;
+  }
+  
+  //
+  // Get the third UINT16 data
+  //
+  Guid->Data3 = (UINT16) StrHexToUint64  (Str);
+  while (!IS_HYPHEN (*Str) && !IS_NULL (*Str)) {
+    Str ++;
+  }
+
+  if (IS_HYPHEN (*Str)) {
+    Str++;
+  } else {
+    return EFI_UNSUPPORTED;
+  }
+
+  //
+  // Get the following 8 bytes data
+  //  
+  StrToBuf (&Guid->Data4[0], 2, Str);
+  //
+  // Skip 2 byte hex chars
+  //
+  Str += 2 * 2;
+
+  if (IS_HYPHEN (*Str)) {
+    Str++;
+  } else {
+    return EFI_UNSUPPORTED;
+  }
+  StrToBuf (&Guid->Data4[2], 6, Str);
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Converts a string to IPv4 address
+
+  @param Str             A string representation of IPv4 address.
+  @param IPv4Addr        A pointer to the converted IPv4 address.
+
+**/
+VOID
+StrToIPv4Addr (
+  IN OUT CHAR16           **Str,
+  OUT    EFI_IPv4_ADDRESS *IPv4Addr
+  )
+{
+  UINTN  Index;
+
+  for (Index = 0; Index < 4; Index++) {
+    IPv4Addr->Addr[Index] = (UINT8) Dtoi (SplitStr (Str, L'.'));
+  }
+}
+
+/**
+  Converts a string to IPv4 address
+
+  @param Str             A string representation of IPv6 address.
+  @param IPv6Addr        A pointer to the converted IPv6 address.
+
+**/
+VOID
+StrToIPv6Addr (
+  IN OUT CHAR16           **Str,
+  OUT    EFI_IPv6_ADDRESS *IPv6Addr
+  )
+{
+  UINTN  Index;
+  UINT16 Data;
+
+  for (Index = 0; Index < 8; Index++) {
+    Data = (UINT16) Xtoi (SplitStr (Str, L':'));
+    IPv6Addr->Addr[Index * 2] = (UINT8) (Data >> 8);
+    IPv6Addr->Addr[Index * 2 + 1] = (UINT8) (Data & 0xff);
+  }
+}
+
+/**
+  Converts a Unicode string to ASCII string.
+
+  @param Str             The equivalent Unicode string
+  @param AsciiStr        On input, it points to destination ASCII string buffer; on output, it points
+                         to the next ASCII string next to it
+
+**/
+VOID
+StrToAscii (
+  IN     CHAR16 *Str,
+  IN OUT CHAR8  **AsciiStr
+  )
+{
+  CHAR8 *Dest;
+
+  Dest = *AsciiStr;
+  while (!IS_NULL (*Str)) {
+    *(Dest++) = (CHAR8) *(Str++);
+  }
+  *Dest = 0;
+
+  //
+  // Return the string next to it
+  //
+  *AsciiStr = Dest + 1;
+}
+
+/**
+  Converts a text device path node to Hardware PCI device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to Hardware PCI device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextPci (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16          *FunctionStr;
+  CHAR16          *DeviceStr;
+  PCI_DEVICE_PATH *Pci;
+
+  DeviceStr   = GetNextParamStr (&TextDeviceNode);
+  FunctionStr = GetNextParamStr (&TextDeviceNode);
+  Pci         = (PCI_DEVICE_PATH *) CreateDeviceNode (
+                                      HARDWARE_DEVICE_PATH,
+                                      HW_PCI_DP,
+                                      (UINT16) sizeof (PCI_DEVICE_PATH)
+                                      );
+
+  Pci->Function = (UINT8) Strtoi (FunctionStr);
+  Pci->Device   = (UINT8) Strtoi (DeviceStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Pci;
+}
+
+/**
+  Converts a text device path node to Hardware PC card device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to Hardware PC card device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextPcCard (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16              *FunctionNumberStr;
+  PCCARD_DEVICE_PATH  *Pccard;
+
+  FunctionNumberStr = GetNextParamStr (&TextDeviceNode);
+  Pccard            = (PCCARD_DEVICE_PATH *) CreateDeviceNode (
+                                               HARDWARE_DEVICE_PATH,
+                                               HW_PCCARD_DP,
+                                               (UINT16) sizeof (PCCARD_DEVICE_PATH)
+                                               );
+
+  Pccard->FunctionNumber  = (UINT8) Strtoi (FunctionNumberStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Pccard;
+}
+
+/**
+  Converts a text device path node to Hardware memory map device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to Hardware memory map device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextMemoryMapped (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16              *MemoryTypeStr;
+  CHAR16              *StartingAddressStr;
+  CHAR16              *EndingAddressStr;
+  MEMMAP_DEVICE_PATH  *MemMap;
+
+  MemoryTypeStr      = GetNextParamStr (&TextDeviceNode);
+  StartingAddressStr = GetNextParamStr (&TextDeviceNode);
+  EndingAddressStr   = GetNextParamStr (&TextDeviceNode);
+  MemMap             = (MEMMAP_DEVICE_PATH *) CreateDeviceNode (
+                                               HARDWARE_DEVICE_PATH,
+                                               HW_MEMMAP_DP,
+                                               (UINT16) sizeof (MEMMAP_DEVICE_PATH)
+                                               );
+
+  MemMap->MemoryType = (UINT32) Strtoi (MemoryTypeStr);
+  Strtoi64 (StartingAddressStr, &MemMap->StartingAddress);
+  Strtoi64 (EndingAddressStr, &MemMap->EndingAddress);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) MemMap;
+}
+
+/**
+  Converts a text device path node to Vendor device path structure based on the input Type
+  and SubType.
+
+  @param TextDeviceNode  The input Text device path node.
+  @param Type            The type of device path node.
+  @param SubType         The subtype of device path node.
+
+  @return A pointer to the newly-created Vendor device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+ConvertFromTextVendor (
+  IN CHAR16 *TextDeviceNode,
+  IN UINT8  Type,
+  IN UINT8  SubType
+  )
+{
+  CHAR16              *GuidStr;
+  CHAR16              *DataStr;
+  UINTN               Length;
+  VENDOR_DEVICE_PATH  *Vendor;
+
+  GuidStr = GetNextParamStr (&TextDeviceNode);
+
+  DataStr = GetNextParamStr (&TextDeviceNode);
+  Length  = StrLen (DataStr);
+  //
+  // Two hex characters make up 1 buffer byte
+  //
+  Length  = (Length + 1) / 2;
+
+  Vendor  = (VENDOR_DEVICE_PATH *) CreateDeviceNode (
+                                     Type,
+                                     SubType,
+                                     (UINT16) (sizeof (VENDOR_DEVICE_PATH) + Length)
+                                     );
+
+  StrToGuid (GuidStr, &Vendor->Guid);
+  StrToBuf (((UINT8 *) Vendor) + sizeof (VENDOR_DEVICE_PATH), Length, DataStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vendor;
+}
+
+/**
+  Converts a text device path node to Vendor Hardware device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor Hardware device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenHw (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextVendor (
+           TextDeviceNode,
+           HARDWARE_DEVICE_PATH,
+           HW_VENDOR_DP
+           );
+}
+
+/**
+  Converts a text device path node to Hardware Controller device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Hardware Controller device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextCtrl (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                  *ControllerStr;
+  CONTROLLER_DEVICE_PATH  *Controller;
+
+  ControllerStr = GetNextParamStr (&TextDeviceNode);
+  Controller    = (CONTROLLER_DEVICE_PATH *) CreateDeviceNode (
+                                               HARDWARE_DEVICE_PATH,
+                                               HW_CONTROLLER_DP,
+                                               (UINT16) sizeof (CONTROLLER_DEVICE_PATH)
+                                               );
+  Controller->ControllerNumber = (UINT32) Strtoi (ControllerStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Controller;
+}
+
+/**
+  Converts a string to EisaId.
+
+  @param Text   The input string.
+  @param EisaId A pointer to the output EisaId.
+
+**/
+VOID
+EisaIdFromText (
+  IN CHAR16 *Text,
+  OUT UINT32 *EisaId
+  )
+{
+  UINTN PnpId;
+
+  PnpId = Xtoi (Text + 3);
+  *EisaId = (((Text[0] - '@') & 0x1f) << 10) +
+            (((Text[1] - '@') & 0x1f) << 5) +
+            ((Text[2] - '@') & 0x1f) +
+            (UINT32) (PnpId << 16);
+}
+
+/**
+  Converts a text device path node to ACPI HID device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created ACPI HID device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextAcpi (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                *HIDStr;
+  CHAR16                *UIDStr;
+  ACPI_HID_DEVICE_PATH  *Acpi;
+
+  HIDStr = GetNextParamStr (&TextDeviceNode);
+  UIDStr = GetNextParamStr (&TextDeviceNode);
+  Acpi   = (ACPI_HID_DEVICE_PATH *) CreateDeviceNode (
+                                      ACPI_DEVICE_PATH,
+                                      ACPI_DP,
+                                      (UINT16) sizeof (ACPI_HID_DEVICE_PATH)
+                                      );
+
+  EisaIdFromText (HIDStr, &Acpi->HID);
+  Acpi->UID = (UINT32) Strtoi (UIDStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Acpi;
+}
+
+/**
+  Converts a text device path node to ACPI HID device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+  @param PnPId           The input plug and play identification.
+
+  @return A pointer to the newly-created ACPI HID device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+ConvertFromTextAcpi (
+  IN CHAR16 *TextDeviceNode,
+  IN UINT32  PnPId
+  )
+{
+  CHAR16                *UIDStr;
+  ACPI_HID_DEVICE_PATH  *Acpi;
+
+  UIDStr = GetNextParamStr (&TextDeviceNode);
+  Acpi   = (ACPI_HID_DEVICE_PATH *) CreateDeviceNode (
+                                      ACPI_DEVICE_PATH,
+                                      ACPI_DP,
+                                      (UINT16) sizeof (ACPI_HID_DEVICE_PATH)
+                                      );
+
+  Acpi->HID = EFI_PNP_ID (PnPId);
+  Acpi->UID = (UINT32) Strtoi (UIDStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Acpi;
+}
+
+/**
+  Converts a text device path node to PCI root device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created PCI root device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextPciRoot (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextAcpi (TextDeviceNode, 0x0a03);
+}
+
+/**
+  Converts a text device path node to PCIE root device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created PCIE root device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextPcieRoot (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextAcpi (TextDeviceNode, 0x0a08);
+}
+
+/**
+  Converts a text device path node to Floppy device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Floppy device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextFloppy (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextAcpi (TextDeviceNode, 0x0604);
+}
+
+/**
+  Converts a text device path node to Keyboard device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created  Keyboard device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextKeyboard (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextAcpi (TextDeviceNode, 0x0301);
+}
+
+/**
+  Converts a text device path node to Serial device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Serial device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextSerial (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextAcpi (TextDeviceNode, 0x0501);
+}
+
+/**
+  Converts a text device path node to Parallel Port device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Parallel Port device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextParallelPort (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextAcpi (TextDeviceNode, 0x0401);
+}
+
+/**
+  Converts a text device path node to ACPI extension device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created ACPI extension device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextAcpiEx (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                         *HIDStr;
+  CHAR16                         *CIDStr;
+  CHAR16                         *UIDStr;
+  CHAR16                         *HIDSTRStr;
+  CHAR16                         *CIDSTRStr;
+  CHAR16                         *UIDSTRStr;
+  CHAR8                          *AsciiStr;
+  UINT16                         Length;
+  ACPI_EXTENDED_HID_DEVICE_PATH  *AcpiEx;
+
+  HIDStr    = GetNextParamStr (&TextDeviceNode);
+  CIDStr    = GetNextParamStr (&TextDeviceNode);
+  UIDStr    = GetNextParamStr (&TextDeviceNode);
+  HIDSTRStr = GetNextParamStr (&TextDeviceNode);
+  CIDSTRStr = GetNextParamStr (&TextDeviceNode);
+  UIDSTRStr = GetNextParamStr (&TextDeviceNode);
+
+  Length    = (UINT16) (sizeof (ACPI_EXTENDED_HID_DEVICE_PATH) + StrLen (HIDSTRStr) + 1);
+  Length    = (UINT16) (Length + StrLen (UIDSTRStr) + 1);
+  Length    = (UINT16) (Length + StrLen (CIDSTRStr) + 1);
+  AcpiEx = (ACPI_EXTENDED_HID_DEVICE_PATH *) CreateDeviceNode (
+                                               ACPI_DEVICE_PATH,
+                                               ACPI_EXTENDED_DP,
+                                               Length
+                                               );
+
+  EisaIdFromText (HIDStr, &AcpiEx->HID);
+  EisaIdFromText (CIDStr, &AcpiEx->CID);
+  AcpiEx->UID = (UINT32) Strtoi (UIDStr);
+
+  AsciiStr = (CHAR8 *) ((UINT8 *)AcpiEx + sizeof (ACPI_EXTENDED_HID_DEVICE_PATH));
+  StrToAscii (HIDSTRStr, &AsciiStr);
+  StrToAscii (UIDSTRStr, &AsciiStr);
+  StrToAscii (CIDSTRStr, &AsciiStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) AcpiEx;
+}
+
+/**
+  Converts a text device path node to ACPI extension device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created ACPI extension device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextAcpiExp (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                         *HIDStr;
+  CHAR16                         *CIDStr;
+  CHAR16                         *UIDSTRStr;
+  CHAR8                          *AsciiStr;
+  UINT16                         Length;
+  ACPI_EXTENDED_HID_DEVICE_PATH  *AcpiEx;
+
+  HIDStr    = GetNextParamStr (&TextDeviceNode);
+  CIDStr    = GetNextParamStr (&TextDeviceNode);
+  UIDSTRStr = GetNextParamStr (&TextDeviceNode);
+  Length    = (UINT16) (sizeof (ACPI_EXTENDED_HID_DEVICE_PATH) + StrLen (UIDSTRStr) + 3);
+  AcpiEx    = (ACPI_EXTENDED_HID_DEVICE_PATH *) CreateDeviceNode (
+                                                  ACPI_DEVICE_PATH,
+                                                  ACPI_EXTENDED_DP,
+                                                  Length
+                                                  );
+
+  EisaIdFromText (HIDStr, &AcpiEx->HID);
+  EisaIdFromText (CIDStr, &AcpiEx->CID);
+  AcpiEx->UID = 0;
+
+  AsciiStr = (CHAR8 *) ((UINT8 *)AcpiEx + sizeof (ACPI_EXTENDED_HID_DEVICE_PATH));
+  //
+  // HID string is NULL
+  //
+  *AsciiStr = '\0';
+  //
+  // Convert UID string
+  //
+  AsciiStr++;
+  StrToAscii (UIDSTRStr, &AsciiStr);
+  //
+  // CID string is NULL
+  //
+  *AsciiStr = '\0';
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) AcpiEx;
+}
+
+/**
+  Converts a text device path node to ACPI _ADR device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created ACPI _ADR device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextAcpiAdr (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                *DisplayDeviceStr;
+  ACPI_ADR_DEVICE_PATH  *AcpiAdr;
+  UINTN                 Index;
+  UINTN                 Length;
+
+  AcpiAdr = (ACPI_ADR_DEVICE_PATH *) CreateDeviceNode (
+                                       ACPI_DEVICE_PATH,
+                                       ACPI_ADR_DP,
+                                       (UINT16) sizeof (ACPI_ADR_DEVICE_PATH)
+                                       );
+  ASSERT (AcpiAdr != NULL);
+
+  for (Index = 0; ; Index++) {
+    DisplayDeviceStr = GetNextParamStr (&TextDeviceNode);
+    if (IS_NULL (*DisplayDeviceStr)) {
+      break;
+    }
+    if (Index > 0) {
+      Length  = DevicePathNodeLength (AcpiAdr);
+      AcpiAdr = ReallocatePool (
+                  Length,
+                  Length + sizeof (UINT32),
+                  AcpiAdr
+                  );
+      ASSERT (AcpiAdr != NULL);
+      SetDevicePathNodeLength (AcpiAdr, Length + sizeof (UINT32));
+    }
+    
+    (&AcpiAdr->ADR)[Index] = (UINT32) Strtoi (DisplayDeviceStr);
+  }
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) AcpiAdr;
+}
+
+/**
+  Converts a text device path node to Parallel Port device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Parallel Port device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextAta (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *PrimarySecondaryStr;
+  CHAR16            *SlaveMasterStr;
+  CHAR16            *LunStr;
+  ATAPI_DEVICE_PATH *Atapi;
+
+  Atapi = (ATAPI_DEVICE_PATH *) CreateDeviceNode (
+                                  MESSAGING_DEVICE_PATH,
+                                  MSG_ATAPI_DP,
+                                  (UINT16) sizeof (ATAPI_DEVICE_PATH)
+                                  );
+
+  PrimarySecondaryStr     = GetNextParamStr (&TextDeviceNode);
+  SlaveMasterStr          = GetNextParamStr (&TextDeviceNode);
+  LunStr                  = GetNextParamStr (&TextDeviceNode);
+
+  Atapi->PrimarySecondary = (UINT8) ((StrCmp (PrimarySecondaryStr, L"Primary") == 0) ? 0 : 1);
+  Atapi->SlaveMaster      = (UINT8) ((StrCmp (SlaveMasterStr, L"Master") == 0) ? 0 : 1);
+  Atapi->Lun              = (UINT16) Strtoi (LunStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Atapi;
+}
+
+/**
+  Converts a text device path node to SCSI device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created SCSI device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextScsi (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *PunStr;
+  CHAR16            *LunStr;
+  SCSI_DEVICE_PATH  *Scsi;
+
+  PunStr = GetNextParamStr (&TextDeviceNode);
+  LunStr = GetNextParamStr (&TextDeviceNode);
+  Scsi   = (SCSI_DEVICE_PATH *) CreateDeviceNode (
+                                   MESSAGING_DEVICE_PATH,
+                                   MSG_SCSI_DP,
+                                   (UINT16) sizeof (SCSI_DEVICE_PATH)
+                                   );
+
+  Scsi->Pun = (UINT16) Strtoi (PunStr);
+  Scsi->Lun = (UINT16) Strtoi (LunStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Scsi;
+}
+
+/**
+  Converts a text device path node to Fibre device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Fibre device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextFibre (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                    *WWNStr;
+  CHAR16                    *LunStr;
+  FIBRECHANNEL_DEVICE_PATH  *Fibre;
+
+  WWNStr = GetNextParamStr (&TextDeviceNode);
+  LunStr = GetNextParamStr (&TextDeviceNode);
+  Fibre  = (FIBRECHANNEL_DEVICE_PATH *) CreateDeviceNode (
+                                          MESSAGING_DEVICE_PATH,
+                                          MSG_FIBRECHANNEL_DP,
+                                          (UINT16) sizeof (FIBRECHANNEL_DEVICE_PATH)
+                                          );
+
+  Fibre->Reserved = 0;
+  Strtoi64 (WWNStr, &Fibre->WWN);
+  Strtoi64 (LunStr, &Fibre->Lun);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Fibre;
+}
+
+/**
+  Converts a text device path node to FibreEx device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created FibreEx device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextFibreEx (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                      *WWNStr;
+  CHAR16                      *LunStr;
+  FIBRECHANNELEX_DEVICE_PATH  *FibreEx;
+
+  WWNStr  = GetNextParamStr (&TextDeviceNode);
+  LunStr  = GetNextParamStr (&TextDeviceNode);
+  FibreEx = (FIBRECHANNELEX_DEVICE_PATH *) CreateDeviceNode (
+                                             MESSAGING_DEVICE_PATH,
+                                             MSG_FIBRECHANNELEX_DP,
+                                             (UINT16) sizeof (FIBRECHANNELEX_DEVICE_PATH)
+                                             );
+
+  FibreEx->Reserved = 0;
+  Strtoi64 (WWNStr, (UINT64 *) (&FibreEx->WWN));
+  Strtoi64 (LunStr, (UINT64 *) (&FibreEx->Lun));
+
+  *(UINT64 *) (&FibreEx->WWN) = SwapBytes64 (*(UINT64 *) (&FibreEx->WWN));
+  *(UINT64 *) (&FibreEx->Lun) = SwapBytes64 (*(UINT64 *) (&FibreEx->Lun));
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) FibreEx;
+}
+
+/**
+  Converts a text device path node to 1394 device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created 1394 device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromText1394 (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *GuidStr;
+  F1394_DEVICE_PATH *F1394DevPath;
+
+  GuidStr = GetNextParamStr (&TextDeviceNode);
+  F1394DevPath  = (F1394_DEVICE_PATH *) CreateDeviceNode (
+                                          MESSAGING_DEVICE_PATH,
+                                          MSG_1394_DP,
+                                          (UINT16) sizeof (F1394_DEVICE_PATH)
+                                          );
+
+  F1394DevPath->Reserved = 0;
+  Xtoi64 (GuidStr, &F1394DevPath->Guid);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) F1394DevPath;
+}
+
+/**
+  Converts a text device path node to USB device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsb (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16          *PortStr;
+  CHAR16          *InterfaceStr;
+  USB_DEVICE_PATH *Usb;
+
+  PortStr               = GetNextParamStr (&TextDeviceNode);
+  InterfaceStr          = GetNextParamStr (&TextDeviceNode);
+  Usb                   = (USB_DEVICE_PATH *) CreateDeviceNode (
+                                                MESSAGING_DEVICE_PATH,
+                                                MSG_USB_DP,
+                                                (UINT16) sizeof (USB_DEVICE_PATH)
+                                                );
+
+  Usb->ParentPortNumber = (UINT8) Strtoi (PortStr);
+  Usb->InterfaceNumber  = (UINT8) Strtoi (InterfaceStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Usb;
+}
+
+/**
+  Converts a text device path node to I20 device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created I20 device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextI2O (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16          *TIDStr;
+  I2O_DEVICE_PATH *I2ODevPath;
+
+  TIDStr     = GetNextParamStr (&TextDeviceNode);
+  I2ODevPath = (I2O_DEVICE_PATH *) CreateDeviceNode (
+                                    MESSAGING_DEVICE_PATH,
+                                    MSG_I2O_DP,
+                                    (UINT16) sizeof (I2O_DEVICE_PATH)
+                                    );
+
+  I2ODevPath->Tid  = (UINT32) Strtoi (TIDStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) I2ODevPath;
+}
+
+/**
+  Converts a text device path node to Infini Band device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Infini Band device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextInfiniband (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                  *FlagsStr;
+  CHAR16                  *GuidStr;
+  CHAR16                  *SidStr;
+  CHAR16                  *TidStr;
+  CHAR16                  *DidStr;
+  EFI_GUID                PortGid;
+  INFINIBAND_DEVICE_PATH  *InfiniBand;
+
+  FlagsStr   = GetNextParamStr (&TextDeviceNode);
+  GuidStr    = GetNextParamStr (&TextDeviceNode);
+  SidStr     = GetNextParamStr (&TextDeviceNode);
+  TidStr     = GetNextParamStr (&TextDeviceNode);
+  DidStr     = GetNextParamStr (&TextDeviceNode);
+  InfiniBand = (INFINIBAND_DEVICE_PATH *) CreateDeviceNode (
+                                            MESSAGING_DEVICE_PATH,
+                                            MSG_INFINIBAND_DP,
+                                            (UINT16) sizeof (INFINIBAND_DEVICE_PATH)
+                                            );
+
+  InfiniBand->ResourceFlags = (UINT32) Strtoi (FlagsStr);
+  StrToGuid (GuidStr, &PortGid);
+  CopyMem (InfiniBand->PortGid, &PortGid, sizeof (EFI_GUID));
+  Strtoi64 (SidStr, &InfiniBand->ServiceId);
+  Strtoi64 (TidStr, &InfiniBand->TargetPortId);
+  Strtoi64 (DidStr, &InfiniBand->DeviceId);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) InfiniBand;
+}
+
+/**
+  Converts a text device path node to Vendor-Defined Messaging device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor-Defined Messaging device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenMsg (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextVendor (
+            TextDeviceNode,
+            MESSAGING_DEVICE_PATH,
+            MSG_VENDOR_DP
+            );
+}
+
+/**
+  Converts a text device path node to Vendor defined PC-ANSI device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor defined PC-ANSI device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenPcAnsi (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  VENDOR_DEVICE_PATH  *Vendor;
+
+  Vendor = (VENDOR_DEVICE_PATH *) CreateDeviceNode (
+                                    MESSAGING_DEVICE_PATH,
+                                    MSG_VENDOR_DP,
+                                    (UINT16) sizeof (VENDOR_DEVICE_PATH));
+  CopyGuid (&Vendor->Guid, &gEfiPcAnsiGuid);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vendor;
+}
+
+/**
+  Converts a text device path node to Vendor defined VT100 device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor defined VT100 device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenVt100 (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  VENDOR_DEVICE_PATH  *Vendor;
+
+  Vendor = (VENDOR_DEVICE_PATH *) CreateDeviceNode (
+                                    MESSAGING_DEVICE_PATH,
+                                    MSG_VENDOR_DP,
+                                    (UINT16) sizeof (VENDOR_DEVICE_PATH));
+  CopyGuid (&Vendor->Guid, &gEfiVT100Guid);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vendor;
+}
+
+/**
+  Converts a text device path node to Vendor defined VT100 Plus device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor defined VT100 Plus device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenVt100Plus (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  VENDOR_DEVICE_PATH  *Vendor;
+
+  Vendor = (VENDOR_DEVICE_PATH *) CreateDeviceNode (
+                                    MESSAGING_DEVICE_PATH,
+                                    MSG_VENDOR_DP,
+                                    (UINT16) sizeof (VENDOR_DEVICE_PATH));
+  CopyGuid (&Vendor->Guid, &gEfiVT100PlusGuid);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vendor;
+}
+
+/**
+  Converts a text device path node to Vendor defined UTF8 device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor defined UTF8 device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenUtf8 (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  VENDOR_DEVICE_PATH  *Vendor;
+
+  Vendor = (VENDOR_DEVICE_PATH *) CreateDeviceNode (
+                                    MESSAGING_DEVICE_PATH,
+                                    MSG_VENDOR_DP,
+                                    (UINT16) sizeof (VENDOR_DEVICE_PATH));
+  CopyGuid (&Vendor->Guid, &gEfiVTUTF8Guid);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vendor;
+}
+
+/**
+  Converts a text device path node to UART Flow Control device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created UART Flow Control device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUartFlowCtrl (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                        *ValueStr;
+  UART_FLOW_CONTROL_DEVICE_PATH *UartFlowControl;
+
+  ValueStr        = GetNextParamStr (&TextDeviceNode);
+  UartFlowControl = (UART_FLOW_CONTROL_DEVICE_PATH *) CreateDeviceNode (
+                                                        MESSAGING_DEVICE_PATH,
+                                                        MSG_VENDOR_DP,
+                                                        (UINT16) sizeof (UART_FLOW_CONTROL_DEVICE_PATH)
+                                                        );
+
+  CopyGuid (&UartFlowControl->Guid, &gEfiUartDevicePathGuid);
+  if (StrCmp (ValueStr, L"XonXoff") == 0) {
+    UartFlowControl->FlowControlMap = 2;
+  } else if (StrCmp (ValueStr, L"Hardware") == 0) {
+    UartFlowControl->FlowControlMap = 1;
+  } else {
+    UartFlowControl->FlowControlMap = 0;
+  }
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) UartFlowControl;
+}
+
+/**
+  Converts a text device path node to Serial Attached SCSI device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Serial Attached SCSI device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextSAS (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16          *AddressStr;
+  CHAR16          *LunStr;
+  CHAR16          *RTPStr;
+  CHAR16          *SASSATAStr;
+  CHAR16          *LocationStr;
+  CHAR16          *ConnectStr;
+  CHAR16          *DriveBayStr;
+  CHAR16          *ReservedStr;
+  UINT16          Info;
+  SAS_DEVICE_PATH *Sas;
+
+  AddressStr  = GetNextParamStr (&TextDeviceNode);
+  LunStr      = GetNextParamStr (&TextDeviceNode);
+  RTPStr      = GetNextParamStr (&TextDeviceNode);
+  SASSATAStr  = GetNextParamStr (&TextDeviceNode);
+  LocationStr = GetNextParamStr (&TextDeviceNode);
+  ConnectStr  = GetNextParamStr (&TextDeviceNode);
+  DriveBayStr = GetNextParamStr (&TextDeviceNode);
+  ReservedStr = GetNextParamStr (&TextDeviceNode);
+  Info        = 0x0000;
+  Sas         = (SAS_DEVICE_PATH *) CreateDeviceNode (
+                                       MESSAGING_DEVICE_PATH,
+                                       MSG_VENDOR_DP,
+                                       (UINT16) sizeof (SAS_DEVICE_PATH)
+                                       );
+
+  CopyGuid (&Sas->Guid, &gEfiSasDevicePathGuid);
+  Strtoi64 (AddressStr, &Sas->SasAddress);
+  Strtoi64 (LunStr, &Sas->Lun);
+  Sas->RelativeTargetPort = (UINT16) Strtoi (RTPStr);
+  if (StrCmp (SASSATAStr, L"NoTopology") != 0) {
+    if (StrCmp (DriveBayStr, L"0") == 0) {
+      Info |= 0x0001;
+    } else {
+      Info |= 0x0002;
+      Info = (UINT16) (Info | (Strtoi (DriveBayStr) << 8));
+    }
+
+    if (StrCmp (SASSATAStr, L"SATA") == 0) {
+      Info |= 0x0010;
+    }
+
+    if (StrCmp (LocationStr, L"External") == 0) {
+      Info |= 0x0020;
+    }
+
+    if (StrCmp (ConnectStr, L"Expanded") == 0) {
+      Info |= 0x0040;
+    }
+  }
+
+  Sas->DeviceTopology = Info;
+  Sas->Reserved       = (UINT32) Strtoi (ReservedStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Sas;
+}
+
+/**
+  Converts a text device path node to Serial Attached SCSI Ex device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Serial Attached SCSI Ex device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextSasEx (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *AddressStr;
+  CHAR16            *LunStr;
+  CHAR16            *RTPStr;
+  CHAR16            *SASSATAStr;
+  CHAR16            *LocationStr;
+  CHAR16            *ConnectStr;
+  CHAR16            *DriveBayStr;
+  UINT16            Info;
+  SASEX_DEVICE_PATH *SasEx;
+
+  AddressStr  = GetNextParamStr (&TextDeviceNode);
+  LunStr      = GetNextParamStr (&TextDeviceNode);
+  RTPStr      = GetNextParamStr (&TextDeviceNode);
+  SASSATAStr  = GetNextParamStr (&TextDeviceNode);
+  LocationStr = GetNextParamStr (&TextDeviceNode);
+  ConnectStr  = GetNextParamStr (&TextDeviceNode);
+  DriveBayStr = GetNextParamStr (&TextDeviceNode);
+  Info        = 0x0000;
+  SasEx       = (SASEX_DEVICE_PATH *) CreateDeviceNode (
+                                        MESSAGING_DEVICE_PATH,
+                                        MSG_SASEX_DP,
+                                        (UINT16) sizeof (SASEX_DEVICE_PATH)
+                                        );
+
+  Strtoi64 (AddressStr, (UINT64 *) &SasEx->SasAddress);
+  Strtoi64 (LunStr,     (UINT64 *) &SasEx->Lun);
+  *(UINT64 *) &SasEx->SasAddress = SwapBytes64 (*(UINT64 *) &SasEx->SasAddress);
+  *(UINT64 *) &SasEx->Lun        = SwapBytes64 (*(UINT64 *) &SasEx->Lun);
+  SasEx->RelativeTargetPort      = (UINT16) Strtoi (RTPStr);
+  if (StrCmp (SASSATAStr, L"NoTopology") != 0) {
+    if (StrCmp (DriveBayStr, L"0") == 0) {
+      Info |= 0x0001;
+    } else {
+      Info |= 0x0002;
+      Info = (UINT16) (Info | (Strtoi (DriveBayStr) << 8));
+    }
+
+    if (StrCmp (SASSATAStr, L"SATA") == 0) {
+      Info |= 0x0010;
+    }
+
+    if (StrCmp (LocationStr, L"External") == 0) {
+      Info |= 0x0020;
+    }
+
+    if (StrCmp (ConnectStr, L"Expanded") == 0) {
+      Info |= 0x0040;
+    }
+  }
+
+  SasEx->DeviceTopology = Info;
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) SasEx;
+}
+
+/**
+  Converts a text device path node to Debug Port device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Debug Port device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextDebugPort (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  VENDOR_DEFINED_MESSAGING_DEVICE_PATH  *Vend;
+
+  Vend = (VENDOR_DEFINED_MESSAGING_DEVICE_PATH *) CreateDeviceNode (
+                                                    MESSAGING_DEVICE_PATH,
+                                                    MSG_VENDOR_DP,
+                                                    (UINT16) sizeof (VENDOR_DEFINED_MESSAGING_DEVICE_PATH)
+                                                    );
+
+  CopyGuid (&Vend->Guid, &gEfiDebugPortProtocolGuid);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vend;
+}
+
+/**
+  Converts a text device path node to MAC device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created MAC device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextMAC (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                *AddressStr;
+  CHAR16                *IfTypeStr;
+  UINTN                 Length;
+  MAC_ADDR_DEVICE_PATH  *MACDevPath;
+
+  AddressStr    = GetNextParamStr (&TextDeviceNode);
+  IfTypeStr     = GetNextParamStr (&TextDeviceNode);
+  MACDevPath    = (MAC_ADDR_DEVICE_PATH *) CreateDeviceNode (
+                                              MESSAGING_DEVICE_PATH,
+                                              MSG_MAC_ADDR_DP,
+                                              (UINT16) sizeof (MAC_ADDR_DEVICE_PATH)
+                                              );
+
+  MACDevPath->IfType   = (UINT8) Strtoi (IfTypeStr);
+
+  Length = sizeof (EFI_MAC_ADDRESS);
+  StrToBuf (&MACDevPath->MacAddress.Addr[0], Length, AddressStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) MACDevPath;
+}
+
+
+/**
+  Converts a text format to the network protocol ID.
+
+  @param Text  String of protocol field.
+
+  @return Network protocol ID .
+
+**/
+UINTN
+NetworkProtocolFromText (
+  IN CHAR16 *Text
+  )
+{
+  if (StrCmp (Text, L"UDP") == 0) {
+    return RFC_1700_UDP_PROTOCOL;
+  }
+
+  if (StrCmp (Text, L"TCP") == 0) {
+    return RFC_1700_TCP_PROTOCOL;
+  }
+
+  return Strtoi (Text);
+}
+
+
+/**
+  Converts a text device path node to IPV4 device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created IPV4 device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextIPv4 (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *RemoteIPStr;
+  CHAR16            *ProtocolStr;
+  CHAR16            *TypeStr;
+  CHAR16            *LocalIPStr;
+  CHAR16            *GatewayIPStr;
+  CHAR16            *SubnetMaskStr;
+  IPv4_DEVICE_PATH  *IPv4;
+
+  RemoteIPStr           = GetNextParamStr (&TextDeviceNode);
+  ProtocolStr           = GetNextParamStr (&TextDeviceNode);
+  TypeStr               = GetNextParamStr (&TextDeviceNode);
+  LocalIPStr            = GetNextParamStr (&TextDeviceNode);
+  GatewayIPStr          = GetNextParamStr (&TextDeviceNode);
+  SubnetMaskStr         = GetNextParamStr (&TextDeviceNode);
+  IPv4                  = (IPv4_DEVICE_PATH *) CreateDeviceNode (
+                                                 MESSAGING_DEVICE_PATH,
+                                                 MSG_IPv4_DP,
+                                                 (UINT16) sizeof (IPv4_DEVICE_PATH)
+                                                 );
+
+  StrToIPv4Addr (&RemoteIPStr, &IPv4->RemoteIpAddress);
+  IPv4->Protocol = (UINT16) NetworkProtocolFromText (ProtocolStr);
+  if (StrCmp (TypeStr, L"Static") == 0) {
+    IPv4->StaticIpAddress = TRUE;
+  } else {
+    IPv4->StaticIpAddress = FALSE;
+  }
+
+  StrToIPv4Addr (&LocalIPStr, &IPv4->LocalIpAddress);
+  if (!IS_NULL (*GatewayIPStr) && !IS_NULL (*SubnetMaskStr)) {
+    StrToIPv4Addr (&GatewayIPStr,  &IPv4->GatewayIpAddress);
+    StrToIPv4Addr (&SubnetMaskStr, &IPv4->SubnetMask);
+  } else {
+    ZeroMem (&IPv4->GatewayIpAddress, sizeof (IPv4->GatewayIpAddress));
+    ZeroMem (&IPv4->SubnetMask,    sizeof (IPv4->SubnetMask));
+  }
+
+  IPv4->LocalPort       = 0;
+  IPv4->RemotePort      = 0;
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) IPv4;
+}
+
+/**
+  Converts a text device path node to IPV6 device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created IPV6 device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextIPv6 (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *RemoteIPStr;
+  CHAR16            *ProtocolStr;
+  CHAR16            *TypeStr;
+  CHAR16            *LocalIPStr;
+  CHAR16            *GatewayIPStr;
+  CHAR16            *PrefixLengthStr;
+  IPv6_DEVICE_PATH  *IPv6;
+
+  RemoteIPStr           = GetNextParamStr (&TextDeviceNode);
+  ProtocolStr           = GetNextParamStr (&TextDeviceNode);
+  TypeStr               = GetNextParamStr (&TextDeviceNode);
+  LocalIPStr            = GetNextParamStr (&TextDeviceNode);
+  PrefixLengthStr       = GetNextParamStr (&TextDeviceNode);
+  GatewayIPStr          = GetNextParamStr (&TextDeviceNode);
+  IPv6                  = (IPv6_DEVICE_PATH *) CreateDeviceNode (
+                                                 MESSAGING_DEVICE_PATH,
+                                                 MSG_IPv6_DP,
+                                                 (UINT16) sizeof (IPv6_DEVICE_PATH)
+                                                 );
+
+  StrToIPv6Addr (&RemoteIPStr, &IPv6->RemoteIpAddress);
+  IPv6->Protocol        = (UINT16) NetworkProtocolFromText (ProtocolStr);
+  if (StrCmp (TypeStr, L"Static") == 0) {
+    IPv6->IpAddressOrigin = 0;
+  } else if (StrCmp (TypeStr, L"StatelessAutoConfigure") == 0) {
+    IPv6->IpAddressOrigin = 1;
+  } else {
+    IPv6->IpAddressOrigin = 2;
+  }
+
+  StrToIPv6Addr (&LocalIPStr, &IPv6->LocalIpAddress);
+  if (!IS_NULL (*GatewayIPStr) && !IS_NULL (*PrefixLengthStr)) {
+    StrToIPv6Addr (&GatewayIPStr, &IPv6->GatewayIpAddress);
+    IPv6->PrefixLength = (UINT8) Strtoi (PrefixLengthStr);
+  } else {
+    ZeroMem (&IPv6->GatewayIpAddress, sizeof (IPv6->GatewayIpAddress));
+    IPv6->PrefixLength = 0;
+  }
+
+  IPv6->LocalPort       = 0;
+  IPv6->RemotePort      = 0;
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) IPv6;
+}
+
+/**
+  Converts a text device path node to UART device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created UART device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUart (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *BaudStr;
+  CHAR16            *DataBitsStr;
+  CHAR16            *ParityStr;
+  CHAR16            *StopBitsStr;
+  UART_DEVICE_PATH  *Uart;
+
+  BaudStr         = GetNextParamStr (&TextDeviceNode);
+  DataBitsStr     = GetNextParamStr (&TextDeviceNode);
+  ParityStr       = GetNextParamStr (&TextDeviceNode);
+  StopBitsStr     = GetNextParamStr (&TextDeviceNode);
+  Uart            = (UART_DEVICE_PATH *) CreateDeviceNode (
+                                           MESSAGING_DEVICE_PATH,
+                                           MSG_UART_DP,
+                                           (UINT16) sizeof (UART_DEVICE_PATH)
+                                           );
+
+  Uart->BaudRate  = (StrCmp (BaudStr, L"DEFAULT") == 0) ? 115200 : Dtoi (BaudStr);
+  Uart->DataBits  = (UINT8) ((StrCmp (DataBitsStr, L"DEFAULT") == 0) ? 8 : Dtoi (DataBitsStr));
+  switch (*ParityStr) {
+  case L'D':
+    Uart->Parity = 0;
+    break;
+
+  case L'N':
+    Uart->Parity = 1;
+    break;
+
+  case L'E':
+    Uart->Parity = 2;
+    break;
+
+  case L'O':
+    Uart->Parity = 3;
+    break;
+
+  case L'M':
+    Uart->Parity = 4;
+    break;
+
+  case L'S':
+    Uart->Parity = 5;
+
+  default:
+    Uart->Parity = 0xff;
+  }
+
+  if (StrCmp (StopBitsStr, L"D") == 0) {
+    Uart->StopBits = (UINT8) 0;
+  } else if (StrCmp (StopBitsStr, L"1") == 0) {
+    Uart->StopBits = (UINT8) 1;
+  } else if (StrCmp (StopBitsStr, L"1.5") == 0) {
+    Uart->StopBits = (UINT8) 2;
+  } else if (StrCmp (StopBitsStr, L"2") == 0) {
+    Uart->StopBits = (UINT8) 3;
+  } else {
+    Uart->StopBits = 0xff;
+  }
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Uart;
+}
+
+/**
+  Converts a text device path node to USB class device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+  @param UsbClassText    A pointer to USB_CLASS_TEXT structure to be integrated to USB Class Text.
+
+  @return A pointer to the newly-created USB class device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+ConvertFromTextUsbClass (
+  IN CHAR16         *TextDeviceNode,
+  IN USB_CLASS_TEXT *UsbClassText
+  )
+{
+  CHAR16                *VIDStr;
+  CHAR16                *PIDStr;
+  CHAR16                *ClassStr;
+  CHAR16                *SubClassStr;
+  CHAR16                *ProtocolStr;
+  USB_CLASS_DEVICE_PATH *UsbClass;
+
+  UsbClass    = (USB_CLASS_DEVICE_PATH *) CreateDeviceNode (
+                                            MESSAGING_DEVICE_PATH,
+                                            MSG_USB_CLASS_DP,
+                                            (UINT16) sizeof (USB_CLASS_DEVICE_PATH)
+                                            );
+
+  VIDStr      = GetNextParamStr (&TextDeviceNode);
+  PIDStr      = GetNextParamStr (&TextDeviceNode);
+  if (UsbClassText->ClassExist) {
+    ClassStr = GetNextParamStr (&TextDeviceNode);
+    UsbClass->DeviceClass = (UINT8) Strtoi (ClassStr);
+  } else {
+    UsbClass->DeviceClass = UsbClassText->Class;
+  }
+  if (UsbClassText->SubClassExist) {
+    SubClassStr = GetNextParamStr (&TextDeviceNode);
+    UsbClass->DeviceSubClass = (UINT8) Strtoi (SubClassStr);
+  } else {
+    UsbClass->DeviceSubClass = UsbClassText->SubClass;
+  }
+
+  ProtocolStr = GetNextParamStr (&TextDeviceNode);
+
+  UsbClass->VendorId        = (UINT16) Strtoi (VIDStr);
+  UsbClass->ProductId       = (UINT16) Strtoi (PIDStr);
+  UsbClass->DeviceProtocol  = (UINT8) Strtoi (ProtocolStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) UsbClass;
+}
+
+
+/**
+  Converts a text device path node to USB class device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB class device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbClass (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = TRUE;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB audio device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB audio device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbAudio (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_AUDIO;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB CDC Control device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB CDC Control device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbCDCControl (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_CDCCONTROL;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB HID device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB HID device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbHID (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_HID;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB Image device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB Image device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbImage (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_IMAGE;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB Print device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB Print device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbPrinter (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_PRINTER;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB mass storage device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB mass storage device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbMassStorage (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_MASS_STORAGE;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB HUB device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB HUB device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbHub (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_HUB;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB CDC data device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB CDC data device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbCDCData (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_CDCDATA;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB smart card device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB smart card device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbSmartCard (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_SMART_CARD;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB video device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB video device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbVideo (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_VIDEO;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB diagnostic device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB diagnostic device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbDiagnostic (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_DIAGNOSTIC;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB wireless device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB wireless device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbWireless (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_WIRELESS;
+  UsbClassText.SubClassExist = TRUE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB device firmware update device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB device firmware update device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbDeviceFirmwareUpdate (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_RESERVE;
+  UsbClassText.SubClassExist = FALSE;
+  UsbClassText.SubClass      = USB_SUBCLASS_FW_UPDATE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB IRDA bridge device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB IRDA bridge device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbIrdaBridge (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_RESERVE;
+  UsbClassText.SubClassExist = FALSE;
+  UsbClassText.SubClass      = USB_SUBCLASS_IRDA_BRIDGE;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB text and measurement device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB text and measurement device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbTestAndMeasurement (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  USB_CLASS_TEXT  UsbClassText;
+
+  UsbClassText.ClassExist    = FALSE;
+  UsbClassText.Class         = USB_CLASS_RESERVE;
+  UsbClassText.SubClassExist = FALSE;
+  UsbClassText.SubClass      = USB_SUBCLASS_TEST;
+
+  return ConvertFromTextUsbClass (TextDeviceNode, &UsbClassText);
+}
+
+/**
+  Converts a text device path node to USB WWID device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created USB WWID device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUsbWwid (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                *VIDStr;
+  CHAR16                *PIDStr;
+  CHAR16                *InterfaceNumStr;
+  CHAR16                *SerialNumberStr;
+  USB_WWID_DEVICE_PATH  *UsbWwid;
+
+  VIDStr                    = GetNextParamStr (&TextDeviceNode);
+  PIDStr                    = GetNextParamStr (&TextDeviceNode);
+  InterfaceNumStr           = GetNextParamStr (&TextDeviceNode);
+  SerialNumberStr           = GetNextParamStr (&TextDeviceNode);
+  UsbWwid                   = (USB_WWID_DEVICE_PATH *) CreateDeviceNode (
+                                                         MESSAGING_DEVICE_PATH,
+                                                         MSG_USB_WWID_DP,
+                                                         (UINT16) (sizeof (USB_WWID_DEVICE_PATH) + StrSize (SerialNumberStr))
+                                                         );
+
+  UsbWwid->VendorId         = (UINT16) Strtoi (VIDStr);
+  UsbWwid->ProductId        = (UINT16) Strtoi (PIDStr);
+  UsbWwid->InterfaceNumber  = (UINT16) Strtoi (InterfaceNumStr);
+  StrCpy ((CHAR16 *) ((UINT8 *) UsbWwid + sizeof (USB_WWID_DEVICE_PATH)), SerialNumberStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) UsbWwid;
+}
+
+/**
+  Converts a text device path node to Logic Unit device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Logic Unit device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextUnit (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                          *LunStr;
+  DEVICE_LOGICAL_UNIT_DEVICE_PATH *LogicalUnit;
+
+  LunStr      = GetNextParamStr (&TextDeviceNode);
+  LogicalUnit = (DEVICE_LOGICAL_UNIT_DEVICE_PATH *) CreateDeviceNode (
+                                                      MESSAGING_DEVICE_PATH,
+                                                      MSG_DEVICE_LOGICAL_UNIT_DP,
+                                                      (UINT16) sizeof (DEVICE_LOGICAL_UNIT_DEVICE_PATH)
+                                                      );
+
+  LogicalUnit->Lun  = (UINT8) Strtoi (LunStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) LogicalUnit;
+}
+
+/**
+  Converts a text device path node to iSCSI device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created iSCSI device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextiSCSI (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  UINT16                      Options;
+  CHAR16                      *NameStr;
+  CHAR16                      *PortalGroupStr;
+  CHAR16                      *LunStr;
+  CHAR16                      *HeaderDigestStr;
+  CHAR16                      *DataDigestStr;
+  CHAR16                      *AuthenticationStr;
+  CHAR16                      *ProtocolStr;
+  CHAR8                       *AsciiStr;
+  ISCSI_DEVICE_PATH_WITH_NAME *ISCSIDevPath;
+
+  NameStr           = GetNextParamStr (&TextDeviceNode);
+  PortalGroupStr    = GetNextParamStr (&TextDeviceNode);
+  LunStr            = GetNextParamStr (&TextDeviceNode);
+  HeaderDigestStr   = GetNextParamStr (&TextDeviceNode);
+  DataDigestStr     = GetNextParamStr (&TextDeviceNode);
+  AuthenticationStr = GetNextParamStr (&TextDeviceNode);
+  ProtocolStr       = GetNextParamStr (&TextDeviceNode);
+  ISCSIDevPath      = (ISCSI_DEVICE_PATH_WITH_NAME *) CreateDeviceNode (
+                                                        MESSAGING_DEVICE_PATH,
+                                                        MSG_ISCSI_DP,
+                                                        (UINT16) (sizeof (ISCSI_DEVICE_PATH_WITH_NAME) + StrLen (NameStr))
+                                                        );
+
+  AsciiStr = ISCSIDevPath->TargetName;
+  StrToAscii (NameStr, &AsciiStr);
+
+  ISCSIDevPath->TargetPortalGroupTag = (UINT16) Strtoi (PortalGroupStr);
+  Strtoi64 (LunStr, &ISCSIDevPath->Lun);
+
+  Options = 0x0000;
+  if (StrCmp (HeaderDigestStr, L"CRC32C") == 0) {
+    Options |= 0x0002;
+  }
+
+  if (StrCmp (DataDigestStr, L"CRC32C") == 0) {
+    Options |= 0x0008;
+  }
+
+  if (StrCmp (AuthenticationStr, L"None") == 0) {
+    Options |= 0x0800;
+  }
+
+  if (StrCmp (AuthenticationStr, L"CHAP_UNI") == 0) {
+    Options |= 0x1000;
+  }
+
+  ISCSIDevPath->LoginOption      = (UINT16) Options;
+
+  ISCSIDevPath->NetworkProtocol  = (UINT16) StrCmp (ProtocolStr, L"TCP");
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) ISCSIDevPath;
+}
+
+/**
+  Converts a text device path node to VLAN device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created VLAN device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVlan (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *VlanStr;
+  VLAN_DEVICE_PATH  *Vlan;
+
+  VlanStr = GetNextParamStr (&TextDeviceNode);
+  Vlan    = (VLAN_DEVICE_PATH *) CreateDeviceNode (
+                                   MESSAGING_DEVICE_PATH,
+                                   MSG_VLAN_DP,
+                                   (UINT16) sizeof (VLAN_DEVICE_PATH)
+                                   );
+
+  Vlan->VlanId = (UINT16) Strtoi (VlanStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Vlan;
+}
+
+/**
+  Converts a text device path node to HD device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created HD device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextHD (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                *PartitionStr;
+  CHAR16                *TypeStr;
+  CHAR16                *SignatureStr;
+  CHAR16                *StartStr;
+  CHAR16                *SizeStr;
+  UINT32                Signature32;
+  EFI_GUID              SignatureGuid;
+  HARDDRIVE_DEVICE_PATH *Hd;
+
+  PartitionStr        = GetNextParamStr (&TextDeviceNode);
+  TypeStr             = GetNextParamStr (&TextDeviceNode);
+  SignatureStr        = GetNextParamStr (&TextDeviceNode);
+  StartStr            = GetNextParamStr (&TextDeviceNode);
+  SizeStr             = GetNextParamStr (&TextDeviceNode);
+  Hd                  = (HARDDRIVE_DEVICE_PATH *) CreateDeviceNode (
+                                                    MEDIA_DEVICE_PATH,
+                                                    MEDIA_HARDDRIVE_DP,
+                                                    (UINT16) sizeof (HARDDRIVE_DEVICE_PATH)
+                                                    );
+
+  Hd->PartitionNumber = (UINT32) Dtoi (PartitionStr);
+
+  ZeroMem (Hd->Signature, 16);
+  Hd->MBRType = (UINT8) 0;
+
+  if (StrCmp (TypeStr, L"MBR") == 0) {
+    Hd->SignatureType = SIGNATURE_TYPE_MBR;
+    Hd->MBRType       = 0x01;
+
+    Signature32       = (UINT32) Strtoi (SignatureStr);
+    CopyMem (Hd->Signature, &Signature32, sizeof (UINT32));
+  } else if (StrCmp (TypeStr, L"GPT") == 0) {
+    Hd->SignatureType = SIGNATURE_TYPE_GUID;
+    Hd->MBRType       = 0x02;
+
+    StrToGuid (SignatureStr, &SignatureGuid);
+    CopyMem (Hd->Signature, &SignatureGuid, sizeof (EFI_GUID));
+  } else {
+    Hd->SignatureType = (UINT8) Strtoi (TypeStr);
+  }
+
+  Strtoi64 (StartStr, &Hd->PartitionStart);
+  Strtoi64 (SizeStr, &Hd->PartitionSize);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Hd;
+}
+
+/**
+  Converts a text device path node to CDROM device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created CDROM device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextCDROM (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16            *EntryStr;
+  CHAR16            *StartStr;
+  CHAR16            *SizeStr;
+  CDROM_DEVICE_PATH *CDROMDevPath;
+
+  EntryStr              = GetNextParamStr (&TextDeviceNode);
+  StartStr              = GetNextParamStr (&TextDeviceNode);
+  SizeStr               = GetNextParamStr (&TextDeviceNode);
+  CDROMDevPath          = (CDROM_DEVICE_PATH *) CreateDeviceNode (
+                                                  MEDIA_DEVICE_PATH,
+                                                  MEDIA_CDROM_DP,
+                                                  (UINT16) sizeof (CDROM_DEVICE_PATH)
+                                                  );
+
+  CDROMDevPath->BootEntry = (UINT32) Strtoi (EntryStr);
+  Strtoi64 (StartStr, &CDROMDevPath->PartitionStart);
+  Strtoi64 (SizeStr, &CDROMDevPath->PartitionSize);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) CDROMDevPath;
+}
+
+/**
+  Converts a text device path node to Vendor-defined media device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Vendor-defined media device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextVenMEDIA (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  return ConvertFromTextVendor (
+           TextDeviceNode,
+           MEDIA_DEVICE_PATH,
+           MEDIA_VENDOR_DP
+           );
+}
+
+/**
+  Converts a text device path node to File device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created File device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextFilePath (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  FILEPATH_DEVICE_PATH  *File;
+
+  File = (FILEPATH_DEVICE_PATH *) CreateDeviceNode (
+                                    MEDIA_DEVICE_PATH,
+                                    MEDIA_FILEPATH_DP,
+                                    (UINT16) (sizeof (FILEPATH_DEVICE_PATH) + StrLen (TextDeviceNode) * 2)
+                                    );
+
+  StrCpy (File->PathName, TextDeviceNode);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) File;
+}
+
+/**
+  Converts a text device path node to Media protocol device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Media protocol device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextMedia (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                      *GuidStr;
+  MEDIA_PROTOCOL_DEVICE_PATH  *Media;
+
+  GuidStr = GetNextParamStr (&TextDeviceNode);
+  Media   = (MEDIA_PROTOCOL_DEVICE_PATH *) CreateDeviceNode (
+                                             MEDIA_DEVICE_PATH,
+                                             MEDIA_PROTOCOL_DP,
+                                             (UINT16) sizeof (MEDIA_PROTOCOL_DEVICE_PATH)
+                                             );
+
+  StrToGuid (GuidStr, &Media->Protocol);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Media;
+}
+
+/**
+  Converts a text device path node to firmware volume device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created firmware volume device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextFv (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                    *GuidStr;
+  MEDIA_FW_VOL_DEVICE_PATH  *Fv;
+
+  GuidStr = GetNextParamStr (&TextDeviceNode);
+  Fv      = (MEDIA_FW_VOL_DEVICE_PATH *) CreateDeviceNode (
+                                           MEDIA_DEVICE_PATH,
+                                           MEDIA_PIWG_FW_VOL_DP,
+                                           (UINT16) sizeof (MEDIA_FW_VOL_DEVICE_PATH)
+                                           );
+
+  StrToGuid (GuidStr, &Fv->FvName);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Fv;
+}
+
+/**
+  Converts a text device path node to firmware file device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created firmware file device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextFvFile (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                             *GuidStr;
+  MEDIA_FW_VOL_FILEPATH_DEVICE_PATH  *FvFile;
+
+  GuidStr = GetNextParamStr (&TextDeviceNode);
+  FvFile  = (MEDIA_FW_VOL_FILEPATH_DEVICE_PATH *) CreateDeviceNode (
+                                                    MEDIA_DEVICE_PATH,
+                                                    MEDIA_PIWG_FW_FILE_DP,
+                                                    (UINT16) sizeof (MEDIA_FW_VOL_FILEPATH_DEVICE_PATH)
+                                                    );
+
+  StrToGuid (GuidStr, &FvFile->FvFileName);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) FvFile;
+}
+
+/**
+  Converts a text device path node to text relative offset device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created Text device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextRelativeOffsetRange (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16                                  *StartingOffsetStr;
+  CHAR16                                  *EndingOffsetStr;
+  MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH *Offset;
+
+  StartingOffsetStr = GetNextParamStr (&TextDeviceNode);
+  EndingOffsetStr   = GetNextParamStr (&TextDeviceNode);
+  Offset            = (MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH *) CreateDeviceNode (
+                                                                    MEDIA_DEVICE_PATH,
+                                                                    MEDIA_RELATIVE_OFFSET_RANGE_DP,
+                                                                    (UINT16) sizeof (MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH)
+                                                                    );
+
+  Strtoi64 (StartingOffsetStr, &Offset->StartingOffset);
+  Strtoi64 (EndingOffsetStr, &Offset->EndingOffset);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Offset;
+}
+
+/**
+  Converts a text device path node to BIOS Boot Specification device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created BIOS Boot Specification device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextBBS (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  CHAR16              *TypeStr;
+  CHAR16              *IdStr;
+  CHAR16              *FlagsStr;
+  CHAR8               *AsciiStr;
+  BBS_BBS_DEVICE_PATH *Bbs;
+
+  TypeStr   = GetNextParamStr (&TextDeviceNode);
+  IdStr     = GetNextParamStr (&TextDeviceNode);
+  FlagsStr  = GetNextParamStr (&TextDeviceNode);
+  Bbs       = (BBS_BBS_DEVICE_PATH *) CreateDeviceNode (
+                                        BBS_DEVICE_PATH,
+                                        BBS_BBS_DP,
+                                        (UINT16) (sizeof (BBS_BBS_DEVICE_PATH) + StrLen (IdStr))
+                                        );
+
+  if (StrCmp (TypeStr, L"Floppy") == 0) {
+    Bbs->DeviceType = BBS_TYPE_FLOPPY;
+  } else if (StrCmp (TypeStr, L"HD") == 0) {
+    Bbs->DeviceType = BBS_TYPE_HARDDRIVE;
+  } else if (StrCmp (TypeStr, L"CDROM") == 0) {
+    Bbs->DeviceType = BBS_TYPE_CDROM;
+  } else if (StrCmp (TypeStr, L"PCMCIA") == 0) {
+    Bbs->DeviceType = BBS_TYPE_PCMCIA;
+  } else if (StrCmp (TypeStr, L"USB") == 0) {
+    Bbs->DeviceType = BBS_TYPE_USB;
+  } else if (StrCmp (TypeStr, L"Network") == 0) {
+    Bbs->DeviceType = BBS_TYPE_EMBEDDED_NETWORK;
+  } else {
+    Bbs->DeviceType = (UINT16) Strtoi (TypeStr);
+  }
+
+  AsciiStr = Bbs->String;
+  StrToAscii (IdStr, &AsciiStr);
+
+  Bbs->StatusFlag = (UINT16) Strtoi (FlagsStr);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Bbs;
+}
+
+/**
+  Converts a text device path node to SATA device path structure.
+
+  @param TextDeviceNode  The input Text device path node.
+
+  @return A pointer to the newly-created SATA device path structure.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+DevPathFromTextSata (
+  IN CHAR16 *TextDeviceNode
+  )
+{
+  SATA_DEVICE_PATH *Sata;
+  CHAR16           *Param1;
+  CHAR16           *Param2;
+  CHAR16           *Param3;
+
+  //
+  // The PMPN is optional.
+  //
+  Param1 = GetNextParamStr (&TextDeviceNode);
+  Param2 = GetNextParamStr (&TextDeviceNode);
+  Param3 = NULL;
+  if (!IS_NULL (TextDeviceNode)) {
+    Param3 = GetNextParamStr (&TextDeviceNode);
+  }
+
+  Sata = (SATA_DEVICE_PATH *) CreateDeviceNode (
+                                MESSAGING_DEVICE_PATH,
+                                MSG_SATA_DP,
+                                (UINT16) sizeof (SATA_DEVICE_PATH)
+                                );
+  Sata->HBAPortNumber = (UINT16) Xtoi (Param1);
+  if (Param3 != NULL) {
+    Sata->PortMultiplierPortNumber = (UINT16) Xtoi (Param2);
+    Param2                   = Param3;
+  } else {
+    Sata->PortMultiplierPortNumber = SATA_HBA_DIRECT_CONNECT_FLAG;
+  }
+  Sata->Lun = (UINT16) Xtoi (Param2);
+
+  return (EFI_DEVICE_PATH_PROTOCOL *) Sata;
+}
+
+GLOBAL_REMOVE_IF_UNREFERENCED DEVICE_PATH_FROM_TEXT_TABLE DevPathFromTextTable[] = {
+  {L"Pci", DevPathFromTextPci},
+  {L"PcCard", DevPathFromTextPcCard},
+  {L"MemoryMapped", DevPathFromTextMemoryMapped},
+  {L"VenHw", DevPathFromTextVenHw},
+  {L"Ctrl", DevPathFromTextCtrl},
+  {L"Acpi", DevPathFromTextAcpi},
+  {L"PciRoot", DevPathFromTextPciRoot},
+  {L"PcieRoot", DevPathFromTextPcieRoot},
+  {L"Floppy", DevPathFromTextFloppy},
+  {L"Keyboard", DevPathFromTextKeyboard},
+  {L"Serial", DevPathFromTextSerial},
+  {L"ParallelPort", DevPathFromTextParallelPort},
+  {L"AcpiEx", DevPathFromTextAcpiEx},
+  {L"AcpiExp", DevPathFromTextAcpiExp},
+  {L"AcpiAdr", DevPathFromTextAcpiAdr},
+  {L"Ata", DevPathFromTextAta},
+  {L"Scsi", DevPathFromTextScsi},
+  {L"Fibre", DevPathFromTextFibre},
+  {L"FibreEx", DevPathFromTextFibreEx},
+  {L"I1394", DevPathFromText1394},
+  {L"USB", DevPathFromTextUsb},
+  {L"I2O", DevPathFromTextI2O},
+  {L"Infiniband", DevPathFromTextInfiniband},
+  {L"VenMsg", DevPathFromTextVenMsg},
+  {L"VenPcAnsi", DevPathFromTextVenPcAnsi},
+  {L"VenVt100", DevPathFromTextVenVt100},
+  {L"VenVt100Plus", DevPathFromTextVenVt100Plus},
+  {L"VenUtf8", DevPathFromTextVenUtf8},
+  {L"UartFlowCtrl", DevPathFromTextUartFlowCtrl},
+  {L"SAS", DevPathFromTextSAS},
+  {L"SasEx", DevPathFromTextSasEx},
+  {L"DebugPort", DevPathFromTextDebugPort},
+  {L"MAC", DevPathFromTextMAC},
+  {L"IPv4", DevPathFromTextIPv4},
+  {L"IPv6", DevPathFromTextIPv6},
+  {L"Uart", DevPathFromTextUart},
+  {L"UsbClass", DevPathFromTextUsbClass},
+  {L"UsbAudio", DevPathFromTextUsbAudio},
+  {L"UsbCDCControl", DevPathFromTextUsbCDCControl},
+  {L"UsbHID", DevPathFromTextUsbHID},
+  {L"UsbImage", DevPathFromTextUsbImage},
+  {L"UsbPrinter", DevPathFromTextUsbPrinter},
+  {L"UsbMassStorage", DevPathFromTextUsbMassStorage},
+  {L"UsbHub", DevPathFromTextUsbHub},
+  {L"UsbCDCData", DevPathFromTextUsbCDCData},
+  {L"UsbSmartCard", DevPathFromTextUsbSmartCard},
+  {L"UsbVideo", DevPathFromTextUsbVideo},
+  {L"UsbDiagnostic", DevPathFromTextUsbDiagnostic},
+  {L"UsbWireless", DevPathFromTextUsbWireless},
+  {L"UsbDeviceFirmwareUpdate", DevPathFromTextUsbDeviceFirmwareUpdate},
+  {L"UsbIrdaBridge", DevPathFromTextUsbIrdaBridge},
+  {L"UsbTestAndMeasurement", DevPathFromTextUsbTestAndMeasurement},
+  {L"UsbWwid", DevPathFromTextUsbWwid},
+  {L"Unit", DevPathFromTextUnit},
+  {L"iSCSI", DevPathFromTextiSCSI},
+  {L"Vlan", DevPathFromTextVlan},
+  {L"HD", DevPathFromTextHD},
+  {L"CDROM", DevPathFromTextCDROM},
+  {L"VenMEDIA", DevPathFromTextVenMEDIA},
+  {L"Media", DevPathFromTextMedia},
+  {L"Fv", DevPathFromTextFv},
+  {L"FvFile", DevPathFromTextFvFile},
+  {L"Offset", DevPathFromTextRelativeOffsetRange},
+  {L"BBS", DevPathFromTextBBS},
+  {L"Sata", DevPathFromTextSata},
+  {NULL, NULL}
+};
+
+/**
+  Convert text to the binary representation of a device node.
+
+  @param TextDeviceNode  TextDeviceNode points to the text representation of a device
+                         node. Conversion starts with the first character and continues
+                         until the first non-device node character.
+
+  @return A pointer to the EFI device node or NULL if TextDeviceNode is NULL or there was
+          insufficient memory or text unsupported.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+ConvertTextToDeviceNode (
+  IN CONST CHAR16 *TextDeviceNode
+  )
+{
+  DUMP_NODE                DumpNode;
+  CHAR16                   *ParamStr;
+  EFI_DEVICE_PATH_PROTOCOL *DeviceNode;
+  CHAR16                   *DeviceNodeStr;
+  UINTN                    Index;
+
+  if ((TextDeviceNode == NULL) || (IS_NULL (*TextDeviceNode))) {
+    return NULL;
+  }
+
+  ParamStr      = NULL;
+  DumpNode      = NULL;
+  DeviceNodeStr = StrDuplicate (TextDeviceNode);
+  ASSERT (DeviceNodeStr != NULL);
+
+  for (Index = 0; DevPathFromTextTable[Index].Function != NULL; Index++) {
+    ParamStr = GetParamByNodeName (DeviceNodeStr, DevPathFromTextTable[Index].DevicePathNodeText);
+    if (ParamStr != NULL) {
+      DumpNode = DevPathFromTextTable[Index].Function;
+      break;
+    }
+  }
+
+  if (DumpNode == NULL) {
+    //
+    // A file path
+    //
+    DumpNode = DevPathFromTextFilePath;
+    DeviceNode = DumpNode (DeviceNodeStr);
+  } else {
+    DeviceNode = DumpNode (ParamStr);
+    FreePool (ParamStr);
+  }
+
+  FreePool (DeviceNodeStr);
+
+  return DeviceNode;
+}
+
+/**
+  Convert text to the binary representation of a device path.
+
+
+  @param TextDevicePath  TextDevicePath points to the text representation of a device
+                         path. Conversion starts with the first character and continues
+                         until the first non-device node character.
+
+  @return A pointer to the allocated device path or NULL if TextDeviceNode is NULL or
+          there was insufficient memory.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+ConvertTextToDevicePath (
+  IN CONST CHAR16 *TextDevicePath
+  )
+{
+  DUMP_NODE                DumpNode;
+  CHAR16                   *ParamStr;
+  EFI_DEVICE_PATH_PROTOCOL *DeviceNode;
+  UINTN                    Index;
+  EFI_DEVICE_PATH_PROTOCOL *NewDevicePath;
+  CHAR16                   *DevicePathStr;
+  CHAR16                   *Str;
+  CHAR16                   *DeviceNodeStr;
+  UINT8                    IsInstanceEnd;
+  EFI_DEVICE_PATH_PROTOCOL *DevicePath;
+
+  if ((TextDevicePath == NULL) || (IS_NULL (*TextDevicePath))) {
+    return NULL;
+  }
+
+  DevicePath = (EFI_DEVICE_PATH_PROTOCOL *) AllocatePool (END_DEVICE_PATH_LENGTH);
+  ASSERT (DevicePath != NULL);
+  SetDevicePathEndNode (DevicePath);
+
+  ParamStr            = NULL;
+  DeviceNodeStr       = NULL;
+  DevicePathStr       = StrDuplicate (TextDevicePath);
+
+  Str                 = DevicePathStr;
+  while ((DeviceNodeStr = GetNextDeviceNodeStr (&Str, &IsInstanceEnd)) != NULL) {
+    DumpNode = NULL;
+    for (Index = 0; DevPathFromTextTable[Index].Function != NULL; Index++) {
+      ParamStr = GetParamByNodeName (DeviceNodeStr, DevPathFromTextTable[Index].DevicePathNodeText);
+      if (ParamStr != NULL) {
+        DumpNode = DevPathFromTextTable[Index].Function;
+        break;
+      }
+    }
+
+    if (DumpNode == NULL) {
+      //
+      // A file path
+      //
+      DumpNode  = DevPathFromTextFilePath;
+      DeviceNode = DumpNode (DeviceNodeStr);
+    } else {
+      DeviceNode = DumpNode (ParamStr);
+      FreePool (ParamStr);
+    }
+
+    NewDevicePath = AppendDeviceNodeProtocolInterface (DevicePath, DeviceNode);
+    FreePool (DevicePath);
+    FreePool (DeviceNode);
+    DevicePath = NewDevicePath;
+
+    if (IsInstanceEnd != 0) {
+      DeviceNode = (EFI_DEVICE_PATH_PROTOCOL *) AllocatePool (END_DEVICE_PATH_LENGTH);
+      ASSERT (DeviceNode != NULL);
+      SET_DEVICE_PATH_INSTANCE_END_NODE (DeviceNode);
+
+      NewDevicePath = AppendDeviceNodeProtocolInterface (DevicePath, DeviceNode);
+      FreePool (DevicePath);
+      FreePool (DeviceNode);
+      DevicePath = NewDevicePath;
+    }
+  }
+
+  FreePool (DevicePathStr);
+  return DevicePath;
+}
Index: Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathToText.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathToText.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathToText.c	(working copy)
@@ -0,0 +1,2065 @@
+/** @file
+  DevicePathToText protocol as defined in the UEFI 2.0 specification.
+
+Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "DevicePath.h"
+
+/**
+  Concatenates a formatted unicode string to allocated pool. The caller must
+  free the resulting buffer.
+
+  @param Str             Tracks the allocated pool, size in use, and
+                         amount of pool allocated.
+  @param Fmt             The format string
+  @param ...             Variable arguments based on the format string.
+
+  @return Allocated buffer with the formatted string printed in it.
+          The caller must free the allocated buffer. The buffer
+          allocation is not packed.
+
+**/
+CHAR16 *
+EFIAPI
+IntCatPrint (
+  IN OUT POOL_PRINT   *Str,
+  IN CHAR16           *Fmt,
+  ...
+  )
+{
+  UINT16  *AppendStr;
+  UINTN   AppendCount;
+  VA_LIST Args;
+
+  AppendStr = AllocateZeroPool (0x1000);
+  ASSERT (AppendStr != NULL);
+
+  VA_START (Args, Fmt);
+  AppendCount = UnicodeVSPrint (AppendStr, 0x1000, Fmt, Args);
+  VA_END (Args);
+
+  if (Str->Length + AppendCount * sizeof (CHAR16) > Str->Capacity) {
+    Str->Capacity = Str->Length + (AppendCount + 1) * sizeof (CHAR16) * 2;
+    Str->Str = ReallocatePool (
+                 Str->Length,
+                 Str->Capacity,
+                 Str->Str
+                 );
+    ASSERT (Str->Str != NULL);
+  }
+
+  if (Str->Length == 0) {
+    StrCpy (Str->Str, AppendStr);
+    Str->Length = (AppendCount + 1) * sizeof (CHAR16);
+  } else {
+    StrCat (Str->Str, AppendStr);
+    Str->Length += AppendCount * sizeof (CHAR16);
+  }
+
+  FreePool (AppendStr);
+  return Str->Str;
+}
+
+/**
+  Converts a PCI device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextPci (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  PCI_DEVICE_PATH *Pci;
+
+  Pci = DevPath;
+  IntCatPrint (Str, L"Pci(0x%x,0x%x)", Pci->Device, Pci->Function);
+}
+
+/**
+  Converts a PC Card device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextPccard (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  PCCARD_DEVICE_PATH  *Pccard;
+
+  Pccard = DevPath;
+  IntCatPrint (Str, L"PcCard(0x%x)", Pccard->FunctionNumber);
+}
+
+/**
+  Converts a Memory Map device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextMemMap (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  MEMMAP_DEVICE_PATH  *MemMap;
+
+  MemMap = DevPath;
+  IntCatPrint (
+    Str,
+    L"MemoryMapped(0x%x,0x%lx,0x%lx)",
+    MemMap->MemoryType,
+    MemMap->StartingAddress,
+    MemMap->EndingAddress
+    );
+}
+
+/**
+  Converts a Vendor device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextVendor (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  VENDOR_DEVICE_PATH  *Vendor;
+  CHAR16              *Type;
+  UINTN               Index;
+  UINTN               DataLength;
+  UINT32              FlowControlMap;
+  UINT16              Info;
+
+  Vendor = (VENDOR_DEVICE_PATH *) DevPath;
+  switch (DevicePathType (&Vendor->Header)) {
+  case HARDWARE_DEVICE_PATH:
+    Type = L"Hw";
+    break;
+
+  case MESSAGING_DEVICE_PATH:
+    Type = L"Msg";
+    if (AllowShortcuts) {
+      if (CompareGuid (&Vendor->Guid, &gEfiPcAnsiGuid)) {
+        IntCatPrint (Str, L"VenPcAnsi()");
+        return ;
+      } else if (CompareGuid (&Vendor->Guid, &gEfiVT100Guid)) {
+        IntCatPrint (Str, L"VenVt100()");
+        return ;
+      } else if (CompareGuid (&Vendor->Guid, &gEfiVT100PlusGuid)) {
+        IntCatPrint (Str, L"VenVt100Plus()");
+        return ;
+      } else if (CompareGuid (&Vendor->Guid, &gEfiVTUTF8Guid)) {
+        IntCatPrint (Str, L"VenUft8()");
+        return ;
+      } else if (CompareGuid (&Vendor->Guid, &gEfiUartDevicePathGuid)) {
+        FlowControlMap = (((UART_FLOW_CONTROL_DEVICE_PATH *) Vendor)->FlowControlMap);
+        switch (FlowControlMap & 0x00000003) {
+        case 0:
+          IntCatPrint (Str, L"UartFlowCtrl(%s)", L"None");
+          break;
+
+        case 1:
+          IntCatPrint (Str, L"UartFlowCtrl(%s)", L"Hardware");
+          break;
+
+        case 2:
+          IntCatPrint (Str, L"UartFlowCtrl(%s)", L"XonXoff");
+          break;
+
+        default:
+          break;
+        }
+
+        return ;
+      } else if (CompareGuid (&Vendor->Guid, &gEfiSasDevicePathGuid)) {
+        IntCatPrint (
+          Str,
+          L"SAS(0x%lx,0x%lx,0x%x,",
+          ((SAS_DEVICE_PATH *) Vendor)->SasAddress,
+          ((SAS_DEVICE_PATH *) Vendor)->Lun,
+          ((SAS_DEVICE_PATH *) Vendor)->RelativeTargetPort
+          );
+        Info = (((SAS_DEVICE_PATH *) Vendor)->DeviceTopology);
+        if ((Info & 0x0f) == 0) {
+          IntCatPrint (Str, L"NoTopology,0,0,0,");
+        } else if (((Info & 0x0f) == 1) || ((Info & 0x0f) == 2)) {
+          IntCatPrint (
+            Str,
+            L"%s,%s,%s,",
+            ((Info & (0x1 << 4)) != 0) ? L"SATA" : L"SAS",
+            ((Info & (0x1 << 5)) != 0) ? L"External" : L"Internal",
+            ((Info & (0x1 << 6)) != 0) ? L"Expanded" : L"Direct"
+            );
+          if ((Info & 0x0f) == 1) {
+            IntCatPrint (Str, L"0,");
+          } else {
+            IntCatPrint (Str, L"0x%x,", (Info >> 8) & 0xff);
+          }
+        } else {
+          IntCatPrint (Str, L"0,0,0,0,");
+        }
+
+        IntCatPrint (Str, L"0x%x)", ((SAS_DEVICE_PATH *) Vendor)->Reserved);
+        return ;
+      } else if (CompareGuid (&Vendor->Guid, &gEfiDebugPortProtocolGuid)) {
+        IntCatPrint (Str, L"DebugPort()");
+        return ;
+      }
+    }
+    break;
+
+  case MEDIA_DEVICE_PATH:
+    Type = L"Media";
+    break;
+
+  default:
+    Type = L"?";
+    break;
+  }
+
+  DataLength = DevicePathNodeLength (&Vendor->Header) - sizeof (VENDOR_DEVICE_PATH);
+  IntCatPrint (Str, L"Ven%s(%g", Type, &Vendor->Guid);
+  if (DataLength != 0) {
+    IntCatPrint (Str, L",");
+    for (Index = 0; Index < DataLength; Index++) {
+      IntCatPrint (Str, L"%02x", ((VENDOR_DEVICE_PATH_WITH_DATA *) Vendor)->VendorDefinedData[Index]);
+    }
+  }
+
+  IntCatPrint (Str, L")");
+}
+
+/**
+  Converts a Controller device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextController (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  CONTROLLER_DEVICE_PATH  *Controller;
+
+  Controller = DevPath;
+  IntCatPrint (
+    Str,
+    L"Ctrl(0x%x)",
+    Controller->ControllerNumber
+    );
+}
+
+/**
+  Converts a ACPI device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextAcpi (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  ACPI_HID_DEVICE_PATH  *Acpi;
+
+  Acpi = DevPath;
+  if ((Acpi->HID & PNP_EISA_ID_MASK) == PNP_EISA_ID_CONST) {
+    switch (EISA_ID_TO_NUM (Acpi->HID)) {
+    case 0x0a03:
+      IntCatPrint (Str, L"PciRoot(0x%x)", Acpi->UID);
+      break;
+
+    case 0x0a08:
+      IntCatPrint (Str, L"PcieRoot(0x%x)", Acpi->UID);
+      break;
+
+    case 0x0604:
+      IntCatPrint (Str, L"Floppy(0x%x)", Acpi->UID);
+      break;
+
+    case 0x0301:
+      IntCatPrint (Str, L"Keyboard(0x%x)", Acpi->UID);
+      break;
+
+    case 0x0501:
+      IntCatPrint (Str, L"Serial(0x%x)", Acpi->UID);
+      break;
+
+    case 0x0401:
+      IntCatPrint (Str, L"ParallelPort(0x%x)", Acpi->UID);
+      break;
+
+    default:
+      IntCatPrint (Str, L"Acpi(PNP%04x,0x%x)", EISA_ID_TO_NUM (Acpi->HID), Acpi->UID);
+      break;
+    }
+  } else {
+    IntCatPrint (Str, L"Acpi(0x%08x,0x%x)", Acpi->HID, Acpi->UID);
+  }
+}
+
+/**
+  Converts EISA identification to string.
+
+  @param EisaId        The input EISA identification.
+  @param Text          A pointer to the output string.
+
+**/
+VOID
+EisaIdToText (
+  IN UINT32         EisaId,
+  IN OUT CHAR16     *Text
+  )
+{
+  CHAR16 PnpIdStr[17];
+
+  //
+  //UnicodeSPrint ("%X", 0x0a03) => "0000000000000A03"
+  //
+  UnicodeSPrint (PnpIdStr, 17 * 2, L"%16X", EisaId >> 16);
+
+  UnicodeSPrint (
+    Text,
+    sizeof (CHAR16) + sizeof (CHAR16) + sizeof (CHAR16) + sizeof (PnpIdStr),
+    L"%c%c%c%s",
+    '@' + ((EisaId >> 10) & 0x1f),
+    '@' + ((EisaId >>  5) & 0x1f),
+    '@' + ((EisaId >>  0) & 0x1f),
+    PnpIdStr + (16 - 4)
+    );
+}
+
+/**
+  Converts a ACPI extended HID device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextAcpiEx (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  ACPI_EXTENDED_HID_DEVICE_PATH  *AcpiEx;
+  CHAR8                          *HIDStr;
+  CHAR8                          *UIDStr;
+  CHAR8                          *CIDStr;
+  CHAR16                         HIDText[11];
+  CHAR16                         CIDText[11];
+
+  AcpiEx = DevPath;
+  HIDStr = (CHAR8 *) (((UINT8 *) AcpiEx) + sizeof (ACPI_EXTENDED_HID_DEVICE_PATH));
+  UIDStr = HIDStr + AsciiStrLen (HIDStr) + 1;
+  CIDStr = UIDStr + AsciiStrLen (UIDStr) + 1;
+
+  EisaIdToText (AcpiEx->HID, HIDText);
+  EisaIdToText (AcpiEx->CID, CIDText);
+
+  if ((*HIDStr == '\0') && (*CIDStr == '\0') && (AcpiEx->UID == 0)) {
+    //
+    // use AcpiExp()
+    //
+    IntCatPrint (
+      Str,
+      L"AcpiExp(%s,%s,%a)",
+      HIDText,
+      CIDText,
+      UIDStr
+      );
+  } else {
+    if (AllowShortcuts) {
+      //
+      // display only
+      //
+      if (AcpiEx->HID == 0) {
+        IntCatPrint (Str, L"AcpiEx(%a,", HIDStr);
+      } else {
+        IntCatPrint (Str, L"AcpiEx(%s,", HIDText);
+      }
+
+      if (AcpiEx->UID == 0) {
+        IntCatPrint (Str, L"%a,", UIDStr);
+      } else {
+        IntCatPrint (Str, L"0x%x,", AcpiEx->UID);
+      }
+
+      if (AcpiEx->CID == 0) {
+        IntCatPrint (Str, L"%a)", CIDStr);
+      } else {
+        IntCatPrint (Str, L"%s)", CIDText);
+      }
+    } else {
+      IntCatPrint (
+        Str,
+        L"AcpiEx(%s,%s,0x%x,%a,%a,%a)",
+        HIDText,
+        CIDText,
+        AcpiEx->UID,
+        HIDStr,
+        CIDStr,
+        UIDStr
+        );
+    }
+  }
+}
+
+/**
+  Converts a ACPI address device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextAcpiAdr (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  ACPI_ADR_DEVICE_PATH    *AcpiAdr;
+  UINT16                  Index;
+  UINT16                  Length;
+  UINT16                  AdditionalAdrCount;
+
+  AcpiAdr            = DevPath;
+  Length             = (UINT16) DevicePathNodeLength ((EFI_DEVICE_PATH_PROTOCOL *) AcpiAdr);
+  AdditionalAdrCount = (UINT16) ((Length - 8) / 4);
+
+  IntCatPrint (Str, L"AcpiAdr(0x%x", AcpiAdr->ADR);
+  for (Index = 0; Index < AdditionalAdrCount; Index++) {
+    IntCatPrint (Str, L",0x%x", *(UINT32 *) ((UINT8 *) AcpiAdr + 8 + Index * 4));
+  }
+  IntCatPrint (Str, L")");
+}
+
+/**
+  Converts a ATAPI device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextAtapi (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  ATAPI_DEVICE_PATH *Atapi;
+
+  Atapi = DevPath;
+
+  if (DisplayOnly) {
+    IntCatPrint (Str, L"Ata(0x%x)", Atapi->Lun);
+  } else {
+    IntCatPrint (
+      Str,
+      L"Ata(%s,%s,0x%x)",
+      (Atapi->PrimarySecondary == 1) ? L"Secondary" : L"Primary",
+      (Atapi->SlaveMaster == 1) ? L"Slave" : L"Master",
+      Atapi->Lun
+      );
+  }
+}
+
+/**
+  Converts a SCSI device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextScsi (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  SCSI_DEVICE_PATH  *Scsi;
+
+  Scsi = DevPath;
+  IntCatPrint (Str, L"Scsi(0x%x,0x%x)", Scsi->Pun, Scsi->Lun);
+}
+
+/**
+  Converts a Fibre device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextFibre (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  FIBRECHANNEL_DEVICE_PATH  *Fibre;
+
+  Fibre = DevPath;
+  IntCatPrint (Str, L"Fibre(0x%lx,0x%lx)", Fibre->WWN, Fibre->Lun);
+}
+
+/**
+  Converts a FibreEx device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextFibreEx (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  FIBRECHANNELEX_DEVICE_PATH  *FibreEx;
+  UINTN                       Index;
+
+  FibreEx = DevPath;
+  IntCatPrint (Str, L"FibreEx(0x");
+  for (Index = 0; Index < sizeof (FibreEx->WWN) / sizeof (FibreEx->WWN[0]); Index++) {
+    IntCatPrint (Str, L"%02x", FibreEx->WWN[Index]);
+  }
+  IntCatPrint (Str, L",0x");
+  for (Index = 0; Index < sizeof (FibreEx->Lun) / sizeof (FibreEx->Lun[0]); Index++) {
+    IntCatPrint (Str, L"%02x", FibreEx->Lun[Index]);
+  }
+  IntCatPrint (Str, L")");
+}
+
+/**
+  Converts a Sas Ex device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextSasEx (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  SASEX_DEVICE_PATH  *SasEx;
+  UINTN              Index;
+
+  SasEx = DevPath;
+  IntCatPrint (Str, L"SasEx(0x");
+
+  for (Index = 0; Index < sizeof (SasEx->SasAddress) / sizeof (SasEx->SasAddress[0]); Index++) {
+    IntCatPrint (Str, L"%02x", SasEx->SasAddress[Index]);
+  }
+  IntCatPrint (Str, L",0x");
+  for (Index = 0; Index < sizeof (SasEx->Lun) / sizeof (SasEx->Lun[0]); Index++) {
+    IntCatPrint (Str, L"%02x", SasEx->Lun[Index]);
+  }
+  IntCatPrint (Str, L",0x%x,", SasEx->RelativeTargetPort);
+
+  if ((SasEx->DeviceTopology & 0x0f) == 0) {
+    IntCatPrint (Str, L"NoTopology,0,0,0");
+  } else if (((SasEx->DeviceTopology & 0x0f) == 1) || ((SasEx->DeviceTopology & 0x0f) == 2)) {
+    IntCatPrint (
+      Str,
+      L"%s,%s,%s,",
+      ((SasEx->DeviceTopology & (0x1 << 4)) != 0) ? L"SATA" : L"SAS",
+      ((SasEx->DeviceTopology & (0x1 << 5)) != 0) ? L"External" : L"Internal",
+      ((SasEx->DeviceTopology & (0x1 << 6)) != 0) ? L"Expanded" : L"Direct"
+      );
+    if ((SasEx->DeviceTopology & 0x0f) == 1) {
+      IntCatPrint (Str, L"0");
+    } else {
+      IntCatPrint (Str, L"0x%x", (SasEx->DeviceTopology >> 8) & 0xff);
+    }
+  } else {
+    IntCatPrint (Str, L"0,0,0,0");
+  }
+
+  IntCatPrint (Str, L")");
+  return ;
+
+}
+
+/**
+  Converts a 1394 device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToText1394 (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  F1394_DEVICE_PATH *F1394DevPath;
+
+  F1394DevPath = DevPath;
+  //
+  // Guid has format of IEEE-EUI64
+  //
+  IntCatPrint (Str, L"I1394(%016lx)", F1394DevPath->Guid);
+}
+
+/**
+  Converts a USB device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextUsb (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  USB_DEVICE_PATH *Usb;
+
+  Usb = DevPath;
+  IntCatPrint (Str, L"USB(0x%x,0x%x)", Usb->ParentPortNumber, Usb->InterfaceNumber);
+}
+
+/**
+  Converts a USB WWID device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextUsbWWID (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  USB_WWID_DEVICE_PATH  *UsbWWId;
+  CHAR16                *SerialNumberStr;
+  CHAR16                *NewStr;
+  UINT16                Length;
+
+  UsbWWId = DevPath;
+
+  SerialNumberStr = (CHAR16 *) ((UINT8 *) UsbWWId + sizeof (USB_WWID_DEVICE_PATH));
+  Length = (UINT16) ((DevicePathNodeLength ((EFI_DEVICE_PATH_PROTOCOL *) UsbWWId) - sizeof (USB_WWID_DEVICE_PATH)) / sizeof (CHAR16));
+  if (SerialNumberStr [Length - 1] != 0) {
+    //
+    // In case no NULL terminator in SerialNumber, create a new one with NULL terminator
+    //
+    NewStr = AllocateCopyPool ((Length + 1) * sizeof (CHAR16), SerialNumberStr);
+    ASSERT (NewStr != NULL);
+    NewStr [Length] = 0;
+    SerialNumberStr = NewStr;
+  }
+
+  IntCatPrint (
+    Str,
+    L"UsbWwid(0x%x,0x%x,0x%x,\"%s\")",
+    UsbWWId->VendorId,
+    UsbWWId->ProductId,
+    UsbWWId->InterfaceNumber,
+    SerialNumberStr
+    );
+}
+
+/**
+  Converts a Logic Unit device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextLogicalUnit (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  DEVICE_LOGICAL_UNIT_DEVICE_PATH *LogicalUnit;
+
+  LogicalUnit = DevPath;
+  IntCatPrint (Str, L"Unit(0x%x)", LogicalUnit->Lun);
+}
+
+/**
+  Converts a USB class device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextUsbClass (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  USB_CLASS_DEVICE_PATH *UsbClass;
+  BOOLEAN               IsKnownSubClass;
+
+
+  UsbClass = DevPath;
+
+  IsKnownSubClass = TRUE;
+  switch (UsbClass->DeviceClass) {
+  case USB_CLASS_AUDIO:
+    IntCatPrint (Str, L"UsbAudio");
+    break;
+
+  case USB_CLASS_CDCCONTROL:
+    IntCatPrint (Str, L"UsbCDCControl");
+    break;
+
+  case USB_CLASS_HID:
+    IntCatPrint (Str, L"UsbHID");
+    break;
+
+  case USB_CLASS_IMAGE:
+    IntCatPrint (Str, L"UsbImage");
+    break;
+
+  case USB_CLASS_PRINTER:
+    IntCatPrint (Str, L"UsbPrinter");
+    break;
+
+  case USB_CLASS_MASS_STORAGE:
+    IntCatPrint (Str, L"UsbMassStorage");
+    break;
+
+  case USB_CLASS_HUB:
+    IntCatPrint (Str, L"UsbHub");
+    break;
+
+  case USB_CLASS_CDCDATA:
+    IntCatPrint (Str, L"UsbCDCData");
+    break;
+
+  case USB_CLASS_SMART_CARD:
+    IntCatPrint (Str, L"UsbSmartCard");
+    break;
+
+  case USB_CLASS_VIDEO:
+    IntCatPrint (Str, L"UsbVideo");
+    break;
+
+  case USB_CLASS_DIAGNOSTIC:
+    IntCatPrint (Str, L"UsbDiagnostic");
+    break;
+
+  case USB_CLASS_WIRELESS:
+    IntCatPrint (Str, L"UsbWireless");
+    break;
+
+  default:
+    IsKnownSubClass = FALSE;
+    break;
+  }
+
+  if (IsKnownSubClass) {
+    IntCatPrint (
+      Str,
+      L"(0x%x,0x%x,0x%x,0x%x)",
+      UsbClass->VendorId,
+      UsbClass->ProductId,
+      UsbClass->DeviceSubClass,
+      UsbClass->DeviceProtocol
+      );
+    return;
+  }
+
+  if (UsbClass->DeviceClass == USB_CLASS_RESERVE) {
+    if (UsbClass->DeviceSubClass == USB_SUBCLASS_FW_UPDATE) {
+      IntCatPrint (
+        Str,
+        L"UsbDeviceFirmwareUpdate(0x%x,0x%x,0x%x)",
+        UsbClass->VendorId,
+        UsbClass->ProductId,
+        UsbClass->DeviceProtocol
+        );
+      return;
+    } else if (UsbClass->DeviceSubClass == USB_SUBCLASS_IRDA_BRIDGE) {
+      IntCatPrint (
+        Str,
+        L"UsbIrdaBridge(0x%x,0x%x,0x%x)",
+        UsbClass->VendorId,
+        UsbClass->ProductId,
+        UsbClass->DeviceProtocol
+        );
+      return;
+    } else if (UsbClass->DeviceSubClass == USB_SUBCLASS_TEST) {
+      IntCatPrint (
+        Str,
+        L"UsbTestAndMeasurement(0x%x,0x%x,0x%x)",
+        UsbClass->VendorId,
+        UsbClass->ProductId,
+        UsbClass->DeviceProtocol
+        );
+      return;
+    }
+  }
+
+  IntCatPrint (
+    Str,
+    L"UsbClass(0x%x,0x%x,0x%x,0x%x,0x%x)",
+    UsbClass->VendorId,
+    UsbClass->ProductId,
+    UsbClass->DeviceClass,
+    UsbClass->DeviceSubClass,
+    UsbClass->DeviceProtocol
+    );
+}
+
+/**
+  Converts a SATA device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextSata (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  SATA_DEVICE_PATH *Sata;
+
+  Sata = DevPath;
+  if ((Sata->PortMultiplierPortNumber & SATA_HBA_DIRECT_CONNECT_FLAG) != 0) {
+    IntCatPrint (
+      Str,
+      L"Sata(0x%x,0x%x)",
+      Sata->HBAPortNumber,
+      Sata->Lun
+      );
+  } else {
+    IntCatPrint (
+      Str,
+      L"Sata(0x%x,0x%x,0x%x)",
+      Sata->HBAPortNumber,
+      Sata->PortMultiplierPortNumber,
+      Sata->Lun
+      );
+  }
+}
+
+/**
+  Converts a I20 device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextI2O (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  I2O_DEVICE_PATH *I2ODevPath;
+
+  I2ODevPath = DevPath;
+  IntCatPrint (Str, L"I2O(0x%x)", I2ODevPath->Tid);
+}
+
+/**
+  Converts a MAC address device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextMacAddr (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  MAC_ADDR_DEVICE_PATH  *MacDevPath;
+  UINTN                 HwAddressSize;
+  UINTN                 Index;
+
+  MacDevPath = DevPath;
+
+  HwAddressSize = sizeof (EFI_MAC_ADDRESS);
+  if (MacDevPath->IfType == 0x01 || MacDevPath->IfType == 0x00) {
+    HwAddressSize = 6;
+  }
+
+  IntCatPrint (Str, L"MAC(");
+
+  for (Index = 0; Index < HwAddressSize; Index++) {
+    IntCatPrint (Str, L"%02x", MacDevPath->MacAddress.Addr[Index]);
+  }
+
+  IntCatPrint (Str, L",0x%x)", MacDevPath->IfType);
+}
+
+/**
+  Converts network protocol string to its text representation.
+
+  @param Str             The string representative of input device.
+  @param Protocol        The network protocol ID.
+
+**/
+VOID
+CatNetworkProtocol (
+  IN OUT POOL_PRINT  *Str,
+  IN UINT16          Protocol
+  )
+{
+  if (Protocol == RFC_1700_TCP_PROTOCOL) {
+    IntCatPrint (Str, L"TCP");
+  } else if (Protocol == RFC_1700_UDP_PROTOCOL) {
+    IntCatPrint (Str, L"UDP");
+  } else {
+    IntCatPrint (Str, L"0x%x", Protocol);
+  }
+}
+
+/**
+  Converts a IPv4 device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextIPv4 (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  IPv4_DEVICE_PATH  *IPDevPath;
+
+  IPDevPath = DevPath;
+  if (DisplayOnly) {
+    IntCatPrint (
+      Str,
+      L"IPv4(%d.%d.%d.%d)",
+      IPDevPath->RemoteIpAddress.Addr[0],
+      IPDevPath->RemoteIpAddress.Addr[1],
+      IPDevPath->RemoteIpAddress.Addr[2],
+      IPDevPath->RemoteIpAddress.Addr[3]
+      );
+    return ;
+  }
+
+  IntCatPrint (
+    Str,
+    L"IPv4(%d.%d.%d.%d,",
+    IPDevPath->RemoteIpAddress.Addr[0],
+    IPDevPath->RemoteIpAddress.Addr[1],
+    IPDevPath->RemoteIpAddress.Addr[2],
+    IPDevPath->RemoteIpAddress.Addr[3]
+    );
+
+  CatNetworkProtocol (
+    Str,
+    IPDevPath->Protocol
+    );
+
+  IntCatPrint (
+    Str,
+    L",%s,%d.%d.%d.%d",
+    IPDevPath->StaticIpAddress ? L"Static" : L"DHCP",
+    IPDevPath->LocalIpAddress.Addr[0],
+    IPDevPath->LocalIpAddress.Addr[1],
+    IPDevPath->LocalIpAddress.Addr[2],
+    IPDevPath->LocalIpAddress.Addr[3]
+    );
+  if (DevicePathNodeLength (IPDevPath) == sizeof (IPv4_DEVICE_PATH)) {
+    IntCatPrint (
+      Str,
+      L",%d.%d.%d.%d,%d.%d.%d.%d",
+      IPDevPath->GatewayIpAddress.Addr[0],
+      IPDevPath->GatewayIpAddress.Addr[1],
+      IPDevPath->GatewayIpAddress.Addr[2],
+      IPDevPath->GatewayIpAddress.Addr[3],
+      IPDevPath->SubnetMask.Addr[0],
+      IPDevPath->SubnetMask.Addr[1],
+      IPDevPath->SubnetMask.Addr[2],
+      IPDevPath->SubnetMask.Addr[3]
+      );
+  }
+  IntCatPrint (Str, L")");
+}
+
+/**
+  Converts a IPv6 device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextIPv6 (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  IPv6_DEVICE_PATH  *IPDevPath;
+
+  IPDevPath = DevPath;
+  if (DisplayOnly) {
+    IntCatPrint (
+      Str,
+      L"IPv6(%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x)",
+      IPDevPath->RemoteIpAddress.Addr[0],
+      IPDevPath->RemoteIpAddress.Addr[1],
+      IPDevPath->RemoteIpAddress.Addr[2],
+      IPDevPath->RemoteIpAddress.Addr[3],
+      IPDevPath->RemoteIpAddress.Addr[4],
+      IPDevPath->RemoteIpAddress.Addr[5],
+      IPDevPath->RemoteIpAddress.Addr[6],
+      IPDevPath->RemoteIpAddress.Addr[7],
+      IPDevPath->RemoteIpAddress.Addr[8],
+      IPDevPath->RemoteIpAddress.Addr[9],
+      IPDevPath->RemoteIpAddress.Addr[10],
+      IPDevPath->RemoteIpAddress.Addr[11],
+      IPDevPath->RemoteIpAddress.Addr[12],
+      IPDevPath->RemoteIpAddress.Addr[13],
+      IPDevPath->RemoteIpAddress.Addr[14],
+      IPDevPath->RemoteIpAddress.Addr[15]
+      );
+    return ;
+  }
+
+  IntCatPrint (
+    Str,
+    L"IPv6(%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x,",
+    IPDevPath->RemoteIpAddress.Addr[0],
+    IPDevPath->RemoteIpAddress.Addr[1],
+    IPDevPath->RemoteIpAddress.Addr[2],
+    IPDevPath->RemoteIpAddress.Addr[3],
+    IPDevPath->RemoteIpAddress.Addr[4],
+    IPDevPath->RemoteIpAddress.Addr[5],
+    IPDevPath->RemoteIpAddress.Addr[6],
+    IPDevPath->RemoteIpAddress.Addr[7],
+    IPDevPath->RemoteIpAddress.Addr[8],
+    IPDevPath->RemoteIpAddress.Addr[9],
+    IPDevPath->RemoteIpAddress.Addr[10],
+    IPDevPath->RemoteIpAddress.Addr[11],
+    IPDevPath->RemoteIpAddress.Addr[12],
+    IPDevPath->RemoteIpAddress.Addr[13],
+    IPDevPath->RemoteIpAddress.Addr[14],
+    IPDevPath->RemoteIpAddress.Addr[15]
+    );
+    
+  CatNetworkProtocol (
+    Str,
+    IPDevPath->Protocol
+    );
+
+  switch (IPDevPath->IpAddressOrigin) {
+    case 0:
+      IntCatPrint (Str, L",Static");
+      break;
+    case 1:
+      IntCatPrint (Str, L",StatelessAutoConfigure");
+      break;
+    default:
+      IntCatPrint (Str, L",StatefulAutoConfigure");
+      break;
+  }
+
+  IntCatPrint (
+    Str,
+    L",%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+    IPDevPath->LocalIpAddress.Addr[0],
+    IPDevPath->LocalIpAddress.Addr[1],
+    IPDevPath->LocalIpAddress.Addr[2],
+    IPDevPath->LocalIpAddress.Addr[3],
+    IPDevPath->LocalIpAddress.Addr[4],
+    IPDevPath->LocalIpAddress.Addr[5],
+    IPDevPath->LocalIpAddress.Addr[6],
+    IPDevPath->LocalIpAddress.Addr[7],
+    IPDevPath->LocalIpAddress.Addr[8],
+    IPDevPath->LocalIpAddress.Addr[9],
+    IPDevPath->LocalIpAddress.Addr[10],
+    IPDevPath->LocalIpAddress.Addr[11],
+    IPDevPath->LocalIpAddress.Addr[12],
+    IPDevPath->LocalIpAddress.Addr[13],
+    IPDevPath->LocalIpAddress.Addr[14],
+    IPDevPath->LocalIpAddress.Addr[15]
+    );
+
+  if (DevicePathNodeLength (IPDevPath) == sizeof (IPv6_DEVICE_PATH)) {
+    IntCatPrint (
+      Str,
+      L",0x%x,%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+      IPDevPath->PrefixLength,
+      IPDevPath->GatewayIpAddress.Addr[0],
+      IPDevPath->GatewayIpAddress.Addr[1],
+      IPDevPath->GatewayIpAddress.Addr[2],
+      IPDevPath->GatewayIpAddress.Addr[3],
+      IPDevPath->GatewayIpAddress.Addr[4],
+      IPDevPath->GatewayIpAddress.Addr[5],
+      IPDevPath->GatewayIpAddress.Addr[6],
+      IPDevPath->GatewayIpAddress.Addr[7],
+      IPDevPath->GatewayIpAddress.Addr[8],
+      IPDevPath->GatewayIpAddress.Addr[9],
+      IPDevPath->GatewayIpAddress.Addr[10],
+      IPDevPath->GatewayIpAddress.Addr[11],
+      IPDevPath->GatewayIpAddress.Addr[12],
+      IPDevPath->GatewayIpAddress.Addr[13],
+      IPDevPath->GatewayIpAddress.Addr[14],
+      IPDevPath->GatewayIpAddress.Addr[15]
+      );
+  }
+  IntCatPrint (Str, L")");
+}
+
+/**
+  Converts an Infini Band device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextInfiniBand (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  INFINIBAND_DEVICE_PATH  *InfiniBand;
+
+  InfiniBand = DevPath;
+  IntCatPrint (
+    Str,
+    L"Infiniband(0x%x,%g,0x%lx,0x%lx,0x%lx)",
+    InfiniBand->ResourceFlags,
+    InfiniBand->PortGid,
+    InfiniBand->ServiceId,
+    InfiniBand->TargetPortId,
+    InfiniBand->DeviceId
+    );
+}
+
+/**
+  Converts a UART device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextUart (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  UART_DEVICE_PATH  *Uart;
+  CHAR8             Parity;
+
+  Uart = DevPath;
+  switch (Uart->Parity) {
+  case 0:
+    Parity = 'D';
+    break;
+
+  case 1:
+    Parity = 'N';
+    break;
+
+  case 2:
+    Parity = 'E';
+    break;
+
+  case 3:
+    Parity = 'O';
+    break;
+
+  case 4:
+    Parity = 'M';
+    break;
+
+  case 5:
+    Parity = 'S';
+    break;
+
+  default:
+    Parity = 'x';
+    break;
+  }
+
+  if (Uart->BaudRate == 0) {
+    IntCatPrint (Str, L"Uart(DEFAULT,");
+  } else {
+    IntCatPrint (Str, L"Uart(%ld,", Uart->BaudRate);
+  }
+
+  if (Uart->DataBits == 0) {
+    IntCatPrint (Str, L"DEFAULT,");
+  } else {
+    IntCatPrint (Str, L"%d,", Uart->DataBits);
+  }
+
+  IntCatPrint (Str, L"%c,", Parity);
+
+  switch (Uart->StopBits) {
+  case 0:
+    IntCatPrint (Str, L"D)");
+    break;
+
+  case 1:
+    IntCatPrint (Str, L"1)");
+    break;
+
+  case 2:
+    IntCatPrint (Str, L"1.5)");
+    break;
+
+  case 3:
+    IntCatPrint (Str, L"2)");
+    break;
+
+  default:
+    IntCatPrint (Str, L"x)");
+    break;
+  }
+}
+
+/**
+  Converts an iSCSI device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextiSCSI (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  ISCSI_DEVICE_PATH_WITH_NAME *ISCSIDevPath;
+  UINT16                      Options;
+
+  ISCSIDevPath = DevPath;
+  IntCatPrint (
+    Str,
+    L"iSCSI(%a,0x%x,0x%lx,",
+    ISCSIDevPath->TargetName,
+    ISCSIDevPath->TargetPortalGroupTag,
+    ISCSIDevPath->Lun
+    );
+
+  Options = ISCSIDevPath->LoginOption;
+  IntCatPrint (Str, L"%s,", (((Options >> 1) & 0x0001) != 0) ? L"CRC32C" : L"None");
+  IntCatPrint (Str, L"%s,", (((Options >> 3) & 0x0001) != 0) ? L"CRC32C" : L"None");
+  if (((Options >> 11) & 0x0001) != 0) {
+    IntCatPrint (Str, L"%s,", L"None");
+  } else if (((Options >> 12) & 0x0001) != 0) {
+    IntCatPrint (Str, L"%s,", L"CHAP_UNI");
+  } else {
+    IntCatPrint (Str, L"%s,", L"CHAP_BI");
+
+  }
+
+  IntCatPrint (Str, L"%s)", (ISCSIDevPath->NetworkProtocol == 0) ? L"TCP" : L"reserved");
+}
+
+/**
+  Converts a VLAN device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextVlan (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  VLAN_DEVICE_PATH  *Vlan;
+
+  Vlan = DevPath;
+  IntCatPrint (Str, L"Vlan(%d)", Vlan->VlanId);
+}
+
+/**
+  Converts a Hard drive device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextHardDrive (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  HARDDRIVE_DEVICE_PATH *Hd;
+
+  Hd = DevPath;
+  switch (Hd->SignatureType) {
+  case SIGNATURE_TYPE_MBR:
+    IntCatPrint (
+      Str,
+      L"HD(%d,%s,0x%08x,",
+      Hd->PartitionNumber,
+      L"MBR",
+      *((UINT32 *) (&(Hd->Signature[0])))
+      );
+    break;
+
+  case SIGNATURE_TYPE_GUID:
+    IntCatPrint (
+      Str,
+      L"HD(%d,%s,%g,",
+      Hd->PartitionNumber,
+      L"GPT",
+      (EFI_GUID *) &(Hd->Signature[0])
+      );
+    break;
+
+  default:
+    IntCatPrint (
+      Str,
+      L"HD(%d,%d,0,",
+      Hd->PartitionNumber,
+      Hd->SignatureType
+      );
+    break;
+  }
+
+  IntCatPrint (Str, L"0x%lx,0x%lx)", Hd->PartitionStart, Hd->PartitionSize);
+}
+
+/**
+  Converts a CDROM device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextCDROM (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  CDROM_DEVICE_PATH *Cd;
+
+  Cd = DevPath;
+  if (DisplayOnly) {
+    IntCatPrint (Str, L"CDROM(0x%x)", Cd->BootEntry);
+    return ;
+  }
+
+  IntCatPrint (Str, L"CDROM(0x%x,0x%lx,0x%lx)", Cd->BootEntry, Cd->PartitionStart, Cd->PartitionSize);
+}
+
+/**
+  Converts a File device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextFilePath (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  FILEPATH_DEVICE_PATH  *Fp;
+
+  Fp = DevPath;
+  IntCatPrint (Str, L"%s", Fp->PathName);
+}
+
+/**
+  Converts a Media protocol device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextMediaProtocol (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  MEDIA_PROTOCOL_DEVICE_PATH  *MediaProt;
+
+  MediaProt = DevPath;
+  IntCatPrint (Str, L"Media(%g)", &MediaProt->Protocol);
+}
+
+/**
+  Converts a Firmware Volume device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextFv (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  MEDIA_FW_VOL_DEVICE_PATH  *Fv;
+
+  Fv = DevPath;
+  IntCatPrint (Str, L"Fv(%g)", &Fv->FvName);
+}
+
+/**
+  Converts a Firmware Volume File device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextFvFile (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  MEDIA_FW_VOL_FILEPATH_DEVICE_PATH  *FvFile;
+
+  FvFile = DevPath;
+  IntCatPrint (Str, L"FvFile(%g)", &FvFile->FvFileName);
+}
+
+/**
+  Converts a Relative Offset device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathRelativeOffsetRange (
+  IN OUT POOL_PRINT       *Str,
+  IN VOID                 *DevPath,
+  IN BOOLEAN              DisplayOnly,
+  IN BOOLEAN              AllowShortcuts
+  )
+{
+  MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH *Offset;
+
+  Offset = DevPath;
+  IntCatPrint (
+    Str,
+    L"Offset(0x%lx,0x%lx)",
+    Offset->StartingOffset,
+    Offset->EndingOffset
+    );
+}
+
+/**
+  Converts a BIOS Boot Specification device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextBBS (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  BBS_BBS_DEVICE_PATH *Bbs;
+  CHAR16              *Type;
+
+  Bbs = DevPath;
+  switch (Bbs->DeviceType) {
+  case BBS_TYPE_FLOPPY:
+    Type = L"Floppy";
+    break;
+
+  case BBS_TYPE_HARDDRIVE:
+    Type = L"HD";
+    break;
+
+  case BBS_TYPE_CDROM:
+    Type = L"CDROM";
+    break;
+
+  case BBS_TYPE_PCMCIA:
+    Type = L"PCMCIA";
+    break;
+
+  case BBS_TYPE_USB:
+    Type = L"USB";
+    break;
+
+  case BBS_TYPE_EMBEDDED_NETWORK:
+    Type = L"Network";
+    break;
+
+  default:
+    Type = NULL;
+    break;
+  }
+
+  if (Type != NULL) {
+    IntCatPrint (Str, L"BBS(%s,%a", Type, Bbs->String);
+  } else {
+    IntCatPrint (Str, L"BBS(0x%x,%a", Bbs->DeviceType, Bbs->String);
+  }
+
+  if (DisplayOnly) {
+    IntCatPrint (Str, L")");
+    return ;
+  }
+
+  IntCatPrint (Str, L",0x%x)", Bbs->StatusFlag);
+}
+
+/**
+  Converts an End-of-Device-Path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextEndInstance (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  IntCatPrint (Str, L",");
+}
+
+/**
+  Converts an unknown device path structure to its string representative.
+
+  @param Str             The string representative of input device.
+  @param DevPath         The input device path structure.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+**/
+VOID
+DevPathToTextNodeUnknown (
+  IN OUT POOL_PRINT  *Str,
+  IN VOID            *DevPath,
+  IN BOOLEAN         DisplayOnly,
+  IN BOOLEAN         AllowShortcuts
+  )
+{
+  IntCatPrint (Str, L"?");
+}
+
+GLOBAL_REMOVE_IF_UNREFERENCED const DEVICE_PATH_TO_TEXT_TABLE DevPathToTextTable[] = {
+  {HARDWARE_DEVICE_PATH, HW_PCI_DP, DevPathToTextPci},
+  {HARDWARE_DEVICE_PATH, HW_PCCARD_DP, DevPathToTextPccard},
+  {HARDWARE_DEVICE_PATH, HW_MEMMAP_DP, DevPathToTextMemMap},
+  {HARDWARE_DEVICE_PATH, HW_VENDOR_DP, DevPathToTextVendor},
+  {HARDWARE_DEVICE_PATH, HW_CONTROLLER_DP, DevPathToTextController},
+  {ACPI_DEVICE_PATH, ACPI_DP, DevPathToTextAcpi},
+  {ACPI_DEVICE_PATH, ACPI_EXTENDED_DP, DevPathToTextAcpiEx},
+  {ACPI_DEVICE_PATH, ACPI_ADR_DP, DevPathToTextAcpiAdr},
+  {MESSAGING_DEVICE_PATH, MSG_ATAPI_DP, DevPathToTextAtapi},
+  {MESSAGING_DEVICE_PATH, MSG_SCSI_DP, DevPathToTextScsi},
+  {MESSAGING_DEVICE_PATH, MSG_FIBRECHANNEL_DP, DevPathToTextFibre},
+  {MESSAGING_DEVICE_PATH, MSG_FIBRECHANNELEX_DP, DevPathToTextFibreEx},
+  {MESSAGING_DEVICE_PATH, MSG_SASEX_DP, DevPathToTextSasEx},
+  {MESSAGING_DEVICE_PATH, MSG_1394_DP, DevPathToText1394},
+  {MESSAGING_DEVICE_PATH, MSG_USB_DP, DevPathToTextUsb},
+  {MESSAGING_DEVICE_PATH, MSG_USB_WWID_DP, DevPathToTextUsbWWID},
+  {MESSAGING_DEVICE_PATH, MSG_DEVICE_LOGICAL_UNIT_DP, DevPathToTextLogicalUnit},
+  {MESSAGING_DEVICE_PATH, MSG_USB_CLASS_DP, DevPathToTextUsbClass},
+  {MESSAGING_DEVICE_PATH, MSG_SATA_DP, DevPathToTextSata},
+  {MESSAGING_DEVICE_PATH, MSG_I2O_DP, DevPathToTextI2O},
+  {MESSAGING_DEVICE_PATH, MSG_MAC_ADDR_DP, DevPathToTextMacAddr},
+  {MESSAGING_DEVICE_PATH, MSG_IPv4_DP, DevPathToTextIPv4},
+  {MESSAGING_DEVICE_PATH, MSG_IPv6_DP, DevPathToTextIPv6},
+  {MESSAGING_DEVICE_PATH, MSG_INFINIBAND_DP, DevPathToTextInfiniBand},
+  {MESSAGING_DEVICE_PATH, MSG_UART_DP, DevPathToTextUart},
+  {MESSAGING_DEVICE_PATH, MSG_VENDOR_DP, DevPathToTextVendor},
+  {MESSAGING_DEVICE_PATH, MSG_ISCSI_DP, DevPathToTextiSCSI},
+  {MESSAGING_DEVICE_PATH, MSG_VLAN_DP, DevPathToTextVlan},
+  {MEDIA_DEVICE_PATH, MEDIA_HARDDRIVE_DP, DevPathToTextHardDrive},
+  {MEDIA_DEVICE_PATH, MEDIA_CDROM_DP, DevPathToTextCDROM},
+  {MEDIA_DEVICE_PATH, MEDIA_VENDOR_DP, DevPathToTextVendor},
+  {MEDIA_DEVICE_PATH, MEDIA_PROTOCOL_DP, DevPathToTextMediaProtocol},
+  {MEDIA_DEVICE_PATH, MEDIA_FILEPATH_DP, DevPathToTextFilePath},
+  {MEDIA_DEVICE_PATH, MEDIA_PIWG_FW_VOL_DP, DevPathToTextFv},
+  {MEDIA_DEVICE_PATH, MEDIA_PIWG_FW_FILE_DP, DevPathToTextFvFile},
+  {MEDIA_DEVICE_PATH, MEDIA_RELATIVE_OFFSET_RANGE_DP, DevPathRelativeOffsetRange},
+  {BBS_DEVICE_PATH, BBS_BBS_DP, DevPathToTextBBS},
+  {END_DEVICE_PATH_TYPE, END_INSTANCE_DEVICE_PATH_SUBTYPE, DevPathToTextEndInstance},
+  {0, 0, NULL}
+};
+
+/**
+  Converts a device node to its string representation.
+
+  @param DeviceNode        A Pointer to the device node to be converted.
+  @param DisplayOnly       If DisplayOnly is TRUE, then the shorter text representation
+                           of the display node is used, where applicable. If DisplayOnly
+                           is FALSE, then the longer text representation of the display node
+                           is used.
+  @param AllowShortcuts    If AllowShortcuts is TRUE, then the shortcut forms of text
+                           representation for a device node can be used, where applicable.
+
+  @return A pointer to the allocated text representation of the device node or NULL if DeviceNode
+          is NULL or there was insufficient memory.
+
+**/
+CHAR16 *
+EFIAPI
+ConvertDeviceNodeToText (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL  *DeviceNode,
+  IN BOOLEAN                         DisplayOnly,
+  IN BOOLEAN                         AllowShortcuts
+  )
+{
+  POOL_PRINT  Str;
+  UINTN       Index;
+  VOID        (*DumpNode)(POOL_PRINT *, VOID *, BOOLEAN, BOOLEAN);
+
+  if (DeviceNode == NULL) {
+    return NULL;
+  }
+
+  ZeroMem (&Str, sizeof (Str));
+
+  //
+  // Process the device path node
+  //
+  DumpNode = NULL;
+  for (Index = 0; DevPathToTextTable[Index].Function != NULL; Index++) {
+    if (DevicePathType (DeviceNode) == DevPathToTextTable[Index].Type &&
+        DevicePathSubType (DeviceNode) == DevPathToTextTable[Index].SubType
+        ) {
+      DumpNode = DevPathToTextTable[Index].Function;
+      break;
+    }
+  }
+  //
+  // If not found, use a generic function
+  //
+  if (DumpNode == NULL) {
+    DumpNode = DevPathToTextNodeUnknown;
+  }
+
+  //
+  // Print this node
+  //
+  DumpNode (&Str, (VOID *) DeviceNode, DisplayOnly, AllowShortcuts);
+
+  ASSERT (Str.Str != NULL);
+  return Str.Str;
+}
+
+/**
+  Converts a device path to its text representation.
+
+  @param DevicePath      A Pointer to the device to be converted.
+  @param DisplayOnly     If DisplayOnly is TRUE, then the shorter text representation
+                         of the display node is used, where applicable. If DisplayOnly
+                         is FALSE, then the longer text representation of the display node
+                         is used.
+  @param AllowShortcuts  If AllowShortcuts is TRUE, then the shortcut forms of text
+                         representation for a device node can be used, where applicable.
+
+  @return A pointer to the allocated text representation of the device path or
+          NULL if DeviceNode is NULL or there was insufficient memory.
+
+**/
+CHAR16 *
+EFIAPI
+ConvertDevicePathToText (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL   *DevicePath,
+  IN BOOLEAN                          DisplayOnly,
+  IN BOOLEAN                          AllowShortcuts
+  )
+{
+  POOL_PRINT                Str;
+  EFI_DEVICE_PATH_PROTOCOL  *DevPathNode;
+  EFI_DEVICE_PATH_PROTOCOL  *AlignedDevPathNode;
+  UINTN                     Index;
+  VOID                      (*DumpNode) (POOL_PRINT *, VOID *, BOOLEAN, BOOLEAN);
+
+  if (DevicePath == NULL) {
+    return NULL;
+  }
+
+  ZeroMem (&Str, sizeof (Str));
+
+  //
+  // Process each device path node
+  //
+  DevPathNode = (EFI_DEVICE_PATH_PROTOCOL *) DevicePath;
+  while (!IsDevicePathEnd (DevPathNode)) {
+    //
+    // Find the handler to dump this device path node
+    //
+    DumpNode = NULL;
+    for (Index = 0; DevPathToTextTable[Index].Function != NULL; Index += 1) {
+
+      if (DevicePathType (DevPathNode) == DevPathToTextTable[Index].Type &&
+          DevicePathSubType (DevPathNode) == DevPathToTextTable[Index].SubType
+          ) {
+        DumpNode = DevPathToTextTable[Index].Function;
+        break;
+      }
+    }
+    //
+    // If not found, use a generic function
+    //
+    if (!DumpNode) {
+      DumpNode = DevPathToTextNodeUnknown;
+    }
+    //
+    //  Put a path separator in if needed
+    //
+    if ((Str.Length != 0) && (DumpNode != DevPathToTextEndInstance)) {
+      if (*(Str.Str + Str.Length / sizeof (CHAR16) - 1) != L',') {
+        IntCatPrint (&Str, L"/");
+      }
+    }
+    
+    AlignedDevPathNode = AllocateCopyPool (DevicePathNodeLength (DevPathNode), DevPathNode);
+    //
+    // Print this node of the device path
+    //
+    DumpNode (&Str, AlignedDevPathNode, DisplayOnly, AllowShortcuts);
+    FreePool (AlignedDevPathNode);
+    
+    //
+    // Next device path node
+    //
+    DevPathNode = NextDevicePathNode (DevPathNode);
+  }
+
+  if (Str.Str == NULL) {
+    return AllocateZeroPool (sizeof (CHAR16));
+  } else {
+    return Str.Str;
+  }
+}
Index: Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathUtilities.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathUtilities.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/DevicePathDxe/DevicePathUtilities.c	(working copy)
@@ -0,0 +1,234 @@
+/** @file
+  Implementation file for Device Path Utilities Protocol
+
+Copyright (c) 2006 - 2008, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "DevicePath.h"
+
+/**
+  Returns the size of a device path in bytes.
+
+  This function returns the size, in bytes, of the device path data structure specified by
+  DevicePath including the end of device path node.  If DevicePath is NULL, then 0 is returned.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+
+  @return The size of a device path in bytes.
+
+**/
+UINTN
+EFIAPI
+GetDevicePathSizeProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL  *DevicePath
+  )
+{
+  return GetDevicePathSize (DevicePath);
+}
+
+
+/**
+  Creates a new device path by appending a second device path to a first device path.
+
+  This function allocates space for a new copy of the device path specified by DevicePath.  If
+  DevicePath is NULL, then NULL is returned.  If the memory is successfully allocated, then the
+  contents of DevicePath are copied to the newly allocated buffer, and a pointer to that buffer
+  is returned.  Otherwise, NULL is returned.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+
+  @return A pointer to the duplicated device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+DuplicateDevicePathProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL  *DevicePath
+  )
+{
+  return DuplicateDevicePath (DevicePath);
+}
+
+/**
+  Creates a new device path by appending a second device path to a first device path.
+
+  This function creates a new device path by appending a copy of SecondDevicePath to a copy of
+  FirstDevicePath in a newly allocated buffer.  Only the end-of-device-path device node from
+  SecondDevicePath is retained. The newly created device path is returned.
+  If FirstDevicePath is NULL, then it is ignored, and a duplicate of SecondDevicePath is returned.
+  If SecondDevicePath is NULL, then it is ignored, and a duplicate of FirstDevicePath is returned.
+  If both FirstDevicePath and SecondDevicePath are NULL, then a copy of an end-of-device-path is
+  returned.
+  If there is not enough memory for the newly allocated buffer, then NULL is returned.
+  The memory for the new device path is allocated from EFI boot services memory. It is the
+  responsibility of the caller to free the memory allocated.
+
+  @param  FirstDevicePath            A pointer to a device path data structure.
+  @param  SecondDevicePath           A pointer to a device path data structure.
+
+  @return A pointer to the new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+AppendDevicePathProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *FirstDevicePath,
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *SecondDevicePath
+  )
+{
+  return AppendDevicePath (FirstDevicePath, SecondDevicePath);
+}
+
+/**
+  Creates a new path by appending the device node to the device path.
+
+  This function creates a new device path by appending a copy of the device node specified by
+  DevicePathNode to a copy of the device path specified by DevicePath in an allocated buffer.
+  The end-of-device-path device node is moved after the end of the appended device node.
+  If DevicePathNode is NULL then a copy of DevicePath is returned.
+  If DevicePath is NULL then a copy of DevicePathNode, followed by an end-of-device path device
+  node is returned.
+  If both DevicePathNode and DevicePath are NULL then a copy of an end-of-device-path device node
+  is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+  @param  DevicePathNode             A pointer to a single device path node.
+
+  @return A pointer to the new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+AppendDeviceNodeProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath,
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePathNode
+  )
+{
+  return AppendDevicePathNode (DevicePath, DevicePathNode);
+}
+
+/**
+  Creates a new device path by appending the specified device path instance to the specified device
+  path.
+
+  This function creates a new device path by appending a copy of the device path instance specified
+  by DevicePathInstance to a copy of the device path specified by DevicePath in a allocated buffer.
+  The end-of-device-path device node is moved after the end of the appended device path instance
+  and a new end-of-device-path-instance node is inserted between.
+  If DevicePath is NULL, then a copy if DevicePathInstance is returned.
+  If DevicePathInstance is NULL, then NULL is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+  @param  DevicePathInstance         A pointer to a device path instance.
+
+  @return A pointer to the new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+AppendDevicePathInstanceProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath,
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePathInstance
+  )
+{
+  return AppendDevicePathInstance (DevicePath, DevicePathInstance);
+}
+
+/**
+  Creates a copy of the current device path instance and returns a pointer to the next device path
+  instance.
+
+  This function creates a copy of the current device path instance. It also updates DevicePath to
+  point to the next device path instance in the device path (or NULL if no more) and updates Size
+  to hold the size of the device path instance copy.
+  If DevicePath is NULL, then NULL is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+  If Size is NULL, then ASSERT().
+
+  @param  DevicePath                 On input, this holds the pointer to the current device path
+                                     instance. On output, this holds the pointer to the next device
+                                     path instance or NULL if there are no more device path
+                                     instances in the device path pointer to a device path data
+                                     structure.
+  @param  Size                       On output, this holds the size of the device path instance, in
+                                     bytes or zero, if DevicePath is NULL.
+
+  @return A pointer to the current device path instance.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+GetNextDevicePathInstanceProtocolInterface (
+  IN OUT EFI_DEVICE_PATH_PROTOCOL   **DevicePath,
+  OUT UINTN                         *Size
+  )
+{
+  return GetNextDevicePathInstance (DevicePath, Size);
+}
+
+/**
+  Determines if a device path is single or multi-instance.
+
+  This function returns TRUE if the device path specified by DevicePath is multi-instance.
+  Otherwise, FALSE is returned.  If DevicePath is NULL, then FALSE is returned.
+
+  @param  DevicePath                 A pointer to a device path data structure.
+
+  @retval  TRUE                      DevicePath is multi-instance.
+  @retval  FALSE                     DevicePath is not multi-instance or DevicePath is NULL.
+
+**/
+BOOLEAN
+EFIAPI
+IsDevicePathMultiInstanceProtocolInterface (
+  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath
+  )
+{
+  return IsDevicePathMultiInstance (DevicePath);
+}
+
+/**
+  Creates a copy of the current device path instance and returns a pointer to the next device path
+  instance.
+
+  This function creates a new device node in a newly allocated buffer of size NodeLength and
+  initializes the device path node header with NodeType and NodeSubType.  The new device path node
+  is returned.
+  If NodeLength is smaller than a device path header, then NULL is returned.
+  If there is not enough memory to allocate space for the new device path, then NULL is returned.
+  The memory is allocated from EFI boot services memory. It is the responsibility of the caller to
+  free the memory allocated.
+
+  @param  NodeType                   The device node type for the new device node.
+  @param  NodeSubType                The device node sub-type for the new device node.
+  @param  NodeLength                 The length of the new device node.
+
+  @return The new device path.
+
+**/
+EFI_DEVICE_PATH_PROTOCOL *
+EFIAPI
+CreateDeviceNodeProtocolInterface (
+  IN UINT8  NodeType,
+  IN UINT8  NodeSubType,
+  IN UINT16 NodeLength
+  )
+{
+  return CreateDeviceNode (NodeType, NodeSubType, NodeLength);
+}
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/ConfigRouting.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/ConfigRouting.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/ConfigRouting.c	(working copy)
@@ -0,0 +1,4171 @@
+/** @file
+Implementation of interfaces function for EFI_HII_CONFIG_ROUTING_PROTOCOL.
+
+Copyright (c) 2007 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "HiiDatabase.h"
+extern HII_DATABASE_PRIVATE_DATA mPrivate;
+
+/**
+  Calculate the number of Unicode characters of the incoming Configuration string,
+  not including NULL terminator.
+
+  This is a internal function.
+
+  @param  String                 String in <MultiConfigRequest> or
+                                 <MultiConfigResp> format.
+
+  @return The number of Unicode characters.
+
+**/
+UINTN
+CalculateConfigStringLen (
+  IN EFI_STRING                    String
+  )
+{
+  EFI_STRING  TmpPtr;
+
+  //
+  // "GUID=" should be the first element of incoming string.
+  //
+  ASSERT (String != NULL);
+  ASSERT (StrnCmp (String, L"GUID=", StrLen (L"GUID=")) == 0);
+
+  //
+  // The beginning of next <ConfigRequest>/<ConfigResp> should be "&GUID=".
+  // Will meet '\0' if there is only one <ConfigRequest>/<ConfigResp>.
+  // 
+  TmpPtr = StrStr (String, L"&GUID=");
+  if (TmpPtr == NULL) {
+    return StrLen (String);
+  }
+
+  return (TmpPtr - String);
+}
+
+
+/**
+  Convert the hex UNICODE %02x encoding of a UEFI device path to binary
+  from <PathHdr> of <ConfigHdr>.
+
+  This is a internal function.
+
+  @param  String                 UEFI configuration string
+  @param  DevicePathData         Binary of a UEFI device path.
+
+  @retval EFI_NOT_FOUND          The device path is not invalid.
+  @retval EFI_INVALID_PARAMETER  Any incoming parameter is invalid.
+  @retval EFI_OUT_OF_RESOURCES   Lake of resources to store neccesary structures.
+  @retval EFI_SUCCESS            The device path is retrieved and translated to
+                                 binary format.
+
+**/
+EFI_STATUS
+GetDevicePath (
+  IN  EFI_STRING                   String,
+  OUT UINT8                        **DevicePathData
+  )
+{
+  UINTN                    Length;
+  EFI_STRING               PathHdr;
+  UINT8                    *DevicePathBuffer;
+  CHAR16                   TemStr[2];
+  UINTN                    Index;
+  UINT8                    DigitUint8;
+  EFI_DEVICE_PATH_PROTOCOL *DevicePath;
+
+
+  if (String == NULL || DevicePathData == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Find the 'PATH=' of <PathHdr> and skip it.
+  //
+  for (; (*String != 0 && StrnCmp (String, L"PATH=", StrLen (L"PATH=")) != 0); String++);
+  if (*String == 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+  //
+  // Check whether path data does exist.
+  //
+  String += StrLen (L"PATH=");
+  if (*String == 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+  PathHdr = String;
+
+  //
+  // The content between 'PATH=' of <ConfigHdr> and '&' of next element
+  // or '\0' (end of configuration string) is the UNICODE %02x bytes encoding
+  // of UEFI device path.
+  //
+  for (Length = 0; *String != 0 && *String != L'&'; String++, Length++);
+  //
+  // Check DevicePath Length
+  //
+  if (((Length + 1) / 2) < sizeof (EFI_DEVICE_PATH_PROTOCOL)) {
+    return EFI_NOT_FOUND;
+  }
+  
+  //
+  // The data in <PathHdr> is encoded as hex UNICODE %02x bytes in the same order
+  // as the device path resides in RAM memory.
+  // Translate the data into binary.
+  //
+  DevicePathBuffer = (UINT8 *) AllocateZeroPool ((Length + 1) / 2);
+  if (DevicePathBuffer == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+  
+  //
+  // Convert DevicePath
+  //
+  ZeroMem (TemStr, sizeof (TemStr));
+  for (Index = 0; Index < Length; Index ++) {
+    TemStr[0] = PathHdr[Index];
+    DigitUint8 = (UINT8) StrHexToUint64 (TemStr);
+    if ((Index & 1) == 0) {
+      DevicePathBuffer [Index/2] = DigitUint8;
+    } else {
+      DevicePathBuffer [Index/2] = (UINT8) ((DevicePathBuffer [Index/2] << 4) + DigitUint8);
+    }
+  }
+  
+  //
+  // Validate DevicePath
+  //
+  DevicePath  = (EFI_DEVICE_PATH_PROTOCOL *) DevicePathBuffer;
+  while (!IsDevicePathEnd (DevicePath)) {
+    if ((DevicePath->Type == 0) || (DevicePath->SubType == 0) || (DevicePathNodeLength (DevicePath) < sizeof (EFI_DEVICE_PATH_PROTOCOL))) {
+      //
+      // Invalid device path
+      //
+      FreePool (DevicePathBuffer);
+      return EFI_NOT_FOUND;
+    }
+    DevicePath = NextDevicePathNode (DevicePath);
+  }
+
+  //
+  // return the device path
+  //
+  *DevicePathData = DevicePathBuffer;
+  return EFI_SUCCESS;
+}
+
+/**
+  Converts the unicode character of the string from uppercase to lowercase.
+  This is a internal function.
+
+  @param ConfigString  String to be converted
+
+**/
+VOID
+EFIAPI
+IntHiiToLower (
+  IN EFI_STRING  ConfigString
+  )
+{
+  EFI_STRING  String;
+  BOOLEAN     Lower;
+
+  ASSERT (ConfigString != NULL);
+
+  //
+  // Convert all hex digits in range [A-F] in the configuration header to [a-f]
+  //
+  for (String = ConfigString, Lower = FALSE; *String != L'\0'; String++) {
+    if (*String == L'=') {
+      Lower = TRUE;
+    } else if (*String == L'&') {
+      Lower = FALSE;
+    } else if (Lower && *String >= L'A' && *String <= L'F') {
+      *String = (CHAR16) (*String - L'A' + L'a');
+    }
+  }
+
+  return;
+}
+
+/**
+  Generate a sub string then output it.
+
+  This is a internal function.
+
+  @param  String                 A constant string which is the prefix of the to be
+                                 generated string, e.g. GUID=
+
+  @param  BufferLen              The length of the Buffer in bytes.
+
+  @param  Buffer                 Points to a buffer which will be converted to be the 
+                                 content of the generated string.
+
+  @param  Flag                   If 1, the buffer contains data for the value of GUID or PATH stored in 
+                                 UINT8 *; if 2, the buffer contains unicode string for the value of NAME;
+                                 if 3, the buffer contains other data.
+
+  @param  SubStr                 Points to the output string. It's caller's
+                                 responsibility to free this buffer.
+
+
+**/
+VOID
+GenerateSubStr (
+  IN CONST EFI_STRING              String,
+  IN  UINTN                        BufferLen,
+  IN  VOID                         *Buffer,
+  IN  UINT8                        Flag,
+  OUT EFI_STRING                   *SubStr
+  )
+{
+  UINTN       Length;
+  EFI_STRING  Str;
+  EFI_STRING  StringHeader;
+  CHAR16      *TemString;
+  CHAR16      *TemName;
+  UINT8       *TemBuffer;
+  UINTN       Index;
+
+  ASSERT (String != NULL && SubStr != NULL);
+
+  if (Buffer == NULL) {
+    *SubStr = AllocateCopyPool (StrSize (String), String);
+    ASSERT (*SubStr != NULL);
+    return ;
+  }
+  
+  //
+  // Header + Data + '&' + '\0'
+  //
+  Length = StrLen (String) + BufferLen * 2 + 1 + 1;
+  Str    = AllocateZeroPool (Length * sizeof (CHAR16));
+  ASSERT (Str != NULL);
+
+  StrCpy (Str, String);
+  Length = (BufferLen * 2 + 1) * sizeof (CHAR16);
+
+  StringHeader = Str + StrLen (String);
+  TemString    = (CHAR16 *) StringHeader;
+
+  switch (Flag) {
+  case 1:
+    //
+    // Convert Buffer to Hex String in reverse order
+    //
+    TemBuffer = ((UINT8 *) Buffer);
+    for (Index = 0; Index < BufferLen; Index ++, TemBuffer ++) {
+      TemString += UnicodeValueToString (TemString, PREFIX_ZERO | RADIX_HEX, *TemBuffer, 2);
+    }
+    break;
+  case 2:
+    //
+    // Check buffer is enough
+    //
+    TemName = (CHAR16 *) Buffer;
+    ASSERT ((BufferLen * 2 + 1) >= (StrLen (TemName) * 4 + 1));
+    //
+    // Convert Unicode String to Config String, e.g. "ABCD" => "0041004200430044"
+    //
+    for (; *TemName != L'\0'; TemName++) {
+      TemString += UnicodeValueToString (TemString, PREFIX_ZERO | RADIX_HEX, *TemName, 4);
+    }
+    break;
+  case 3:
+    //
+    // Convert Buffer to Hex String
+    //
+    TemBuffer = ((UINT8 *) Buffer) + BufferLen - 1;
+    for (Index = 0; Index < BufferLen; Index ++, TemBuffer --) {
+      TemString += UnicodeValueToString (TemString, PREFIX_ZERO | RADIX_HEX, *TemBuffer, 2);
+    }
+    break;
+  default:
+    break;
+  }
+
+  //
+  // Convert the uppercase to lowercase since <HexAf> is defined in lowercase format.
+  //
+  StrCat (Str, L"&");  
+  IntHiiToLower (Str);
+
+  *SubStr = Str;
+}
+
+
+/**
+  Retrieve the <ConfigBody> from String then output it.
+
+  This is a internal function.
+
+  @param  String                 A sub string of a configuration string in
+                                 <MultiConfigAltResp> format.
+  @param  ConfigBody             Points to the output string. It's caller's
+                                 responsibility to free this buffer.
+
+  @retval EFI_INVALID_PARAMETER  There is no form package in current hii database.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to finish this operation.
+  @retval EFI_SUCCESS            All existing storage is exported.
+
+**/
+EFI_STATUS
+OutputConfigBody (
+  IN  EFI_STRING                   String,
+  OUT EFI_STRING                   *ConfigBody
+  )
+{
+  EFI_STRING  TmpPtr;
+  EFI_STRING  Result;
+  UINTN       Length;
+
+  if (String == NULL || ConfigBody == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  
+  //
+  // The setting information should start OFFSET, not ALTCFG.
+  //
+  if (StrnCmp (String, L"&ALTCFG=", StrLen (L"&ALTCFG=")) == 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  TmpPtr = StrStr (String, L"GUID=");
+  if (TmpPtr == NULL) {
+    //
+    // It is the last <ConfigResp> of the incoming configuration string.
+    //
+    Result = AllocateCopyPool (StrSize (String), String);
+    if (Result == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    } else {
+      *ConfigBody = Result;
+      return EFI_SUCCESS;
+    }
+  }
+
+  Length = TmpPtr - String;
+  Result = AllocateCopyPool (Length * sizeof (CHAR16), String);
+  if (Result == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  *(Result + Length - 1) = 0;
+  *ConfigBody = Result;
+  return EFI_SUCCESS;
+}
+
+/**
+  Append a string to a multi-string format.
+
+  This is a internal function.
+
+  @param  MultiString            String in <MultiConfigRequest>,
+                                 <MultiConfigAltResp>, or <MultiConfigResp>. On
+                                 input, the buffer length of  this string is
+                                 MAX_STRING_LENGTH. On output, the  buffer length
+                                 might be updated.
+  @param  AppendString           NULL-terminated Unicode string.
+
+  @retval EFI_INVALID_PARAMETER  Any incoming parameter is invalid.
+  @retval EFI_SUCCESS            AppendString is append to the end of MultiString
+
+**/
+EFI_STATUS
+AppendToMultiString (
+  IN OUT EFI_STRING                *MultiString,
+  IN EFI_STRING                    AppendString
+  )
+{
+  UINTN AppendStringSize;
+  UINTN MultiStringSize;
+
+  if (MultiString == NULL || *MultiString == NULL || AppendString == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  AppendStringSize = StrSize (AppendString);
+  MultiStringSize  = StrSize (*MultiString);
+
+  //
+  // Enlarge the buffer each time when length exceeds MAX_STRING_LENGTH.
+  //
+  if (MultiStringSize + AppendStringSize > MAX_STRING_LENGTH ||
+      MultiStringSize > MAX_STRING_LENGTH) {
+    *MultiString = (EFI_STRING) ReallocatePool (
+                                  MultiStringSize,
+                                  MultiStringSize + AppendStringSize,
+                                  (VOID *) (*MultiString)
+                                  );
+    ASSERT (*MultiString != NULL);
+  }
+  //
+  // Append the incoming string
+  //
+  StrCat (*MultiString, AppendString);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Get the value of <Number> in <BlockConfig> format, i.e. the value of OFFSET
+  or WIDTH or VALUE.
+  <BlockConfig> ::= 'OFFSET='<Number>&'WIDTH='<Number>&'VALUE'=<Number>
+
+  This is a internal function.
+
+  @param  StringPtr              String in <BlockConfig> format and points to the
+                                 first character of <Number>.
+  @param  Number                 The output value. Caller takes the responsibility
+                                 to free memory.
+  @param  Len                    Length of the <Number>, in characters.
+
+  @retval EFI_OUT_OF_RESOURCES   Insufficient resources to store neccessary
+                                 structures.
+  @retval EFI_SUCCESS            Value of <Number> is outputted in Number
+                                 successfully.
+
+**/
+EFI_STATUS
+GetValueOfNumber (
+  IN EFI_STRING                    StringPtr,
+  OUT UINT8                        **Number,
+  OUT UINTN                        *Len
+  )
+{
+  EFI_STRING               TmpPtr;
+  UINTN                    Length;
+  EFI_STRING               Str;
+  UINT8                    *Buf;
+  EFI_STATUS               Status;
+  UINT8                    DigitUint8;
+  UINTN                    Index;
+  CHAR16                   TemStr[2];
+
+  if (StringPtr == NULL || *StringPtr == L'\0' || Number == NULL || Len == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Buf = NULL;
+
+  TmpPtr = StringPtr;
+  while (*StringPtr != L'\0' && *StringPtr != L'&') {
+    StringPtr++;
+  }
+  *Len   = StringPtr - TmpPtr;
+  Length = *Len + 1;
+
+  Str = (EFI_STRING) AllocateZeroPool (Length * sizeof (CHAR16));
+  if (Str == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+  CopyMem (Str, TmpPtr, *Len * sizeof (CHAR16));
+  *(Str + *Len) = L'\0';
+
+  Length = (Length + 1) / 2;
+  Buf = (UINT8 *) AllocateZeroPool (Length);
+  if (Buf == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+  
+  Length = *Len;
+  ZeroMem (TemStr, sizeof (TemStr));
+  for (Index = 0; Index < Length; Index ++) {
+    TemStr[0] = Str[Length - Index - 1];
+    DigitUint8 = (UINT8) StrHexToUint64 (TemStr);
+    if ((Index & 1) == 0) {
+      Buf [Index/2] = DigitUint8;
+    } else {
+      Buf [Index/2] = (UINT8) ((DigitUint8 << 4) + Buf [Index/2]);
+    }
+  }
+
+  *Number = Buf;
+  Status  = EFI_SUCCESS;
+
+Exit:
+  if (Str != NULL) {
+    FreePool (Str);
+  }
+
+  return Status;
+}
+
+/**
+  This function merges DefaultAltCfgResp string into AltCfgResp string for
+  the missing AltCfgId in AltCfgResq.
+
+  @param  AltCfgResp             Pointer to a null-terminated Unicode string in
+                                 <ConfigAltResp> format. The default value string 
+                                 will be merged into it. 
+  @param  DefaultAltCfgResp      Pointer to a null-terminated Unicode string in
+                                 <MultiConfigAltResp> format. The default value 
+                                 string may contain more than one ConfigAltResp
+                                 string for the different varstore buffer.
+
+  @retval EFI_SUCCESS            The merged string returns.
+  @retval EFI_INVALID_PARAMETER  *AltCfgResp is to NULL.
+**/
+EFI_STATUS
+EFIAPI
+MergeDefaultString (
+  IN OUT EFI_STRING  *AltCfgResp,
+  IN     EFI_STRING  DefaultAltCfgResp
+  )
+{
+  EFI_STRING   StringPtrDefault;
+  EFI_STRING   StringPtrEnd;
+  CHAR16       TempChar;
+  EFI_STRING   StringPtr;
+  EFI_STRING   AltConfigHdr;
+  UINTN        HeaderLength;
+  UINTN        SizeAltCfgResp;
+  
+  if (*AltCfgResp == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  
+  //
+  // Get the requestr ConfigHdr
+  //
+  SizeAltCfgResp  = 0;
+  StringPtr       = *AltCfgResp;
+  
+  //
+  // Find <ConfigHdr> GUID=...&NAME=...&PATH=...
+  //
+  if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+  while (*StringPtr != L'\0' && StrnCmp (StringPtr, L"&NAME=", StrLen (L"&NAME=")) != 0) {
+    StringPtr++;
+  }
+  while (*StringPtr != L'\0' && StrnCmp (StringPtr, L"&PATH=", StrLen (L"&PATH=")) != 0) {
+    StringPtr++;
+  }
+  if (*StringPtr == L'\0') {
+    return EFI_INVALID_PARAMETER;
+  }
+  StringPtr += StrLen (L"&PATH=");
+  while (*StringPtr != L'\0' && *StringPtr != L'&') {
+    StringPtr ++;
+  }
+  HeaderLength = StringPtr - *AltCfgResp;
+
+  //
+  // Construct AltConfigHdr string  "&<ConfigHdr>&ALTCFG=XXXX\0"
+  //                                  |1| StrLen (ConfigHdr) | 8 | 4 | 1 |
+  //
+  AltConfigHdr = AllocateZeroPool ((1 + HeaderLength + 8 + 4 + 1) * sizeof (CHAR16));
+  if (AltConfigHdr == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+  StrCpy (AltConfigHdr, L"&");
+  StrnCat (AltConfigHdr, *AltCfgResp, HeaderLength);
+  StrCat (AltConfigHdr, L"&ALTCFG=");
+  HeaderLength = StrLen (AltConfigHdr);
+  
+  StringPtrDefault = StrStr (DefaultAltCfgResp, AltConfigHdr);
+  while (StringPtrDefault != NULL) {
+    //
+    // Get AltCfg Name
+    //
+    StrnCat (AltConfigHdr, StringPtrDefault + HeaderLength, 4);
+    StringPtr = StrStr (*AltCfgResp, AltConfigHdr); 
+    
+    //
+    // Append the found default value string to the input AltCfgResp
+    // 
+    if (StringPtr == NULL) {
+      StringPtrEnd   = StrStr (StringPtrDefault + 1, L"&GUID");
+      SizeAltCfgResp = StrSize (*AltCfgResp);
+      if (StringPtrEnd == NULL) {
+        //
+        // No more default string is found.
+        //
+        *AltCfgResp    = (EFI_STRING) ReallocatePool (
+                                     SizeAltCfgResp,
+                                     SizeAltCfgResp + StrSize (StringPtrDefault),
+                                     (VOID *) (*AltCfgResp)
+                                     );
+        if (*AltCfgResp == NULL) {
+          FreePool (AltConfigHdr);
+          return EFI_OUT_OF_RESOURCES;
+        }
+        StrCat (*AltCfgResp, StringPtrDefault);
+        break;
+      } else {
+        TempChar = *StringPtrEnd;
+        *StringPtrEnd = L'\0';
+        *AltCfgResp = (EFI_STRING) ReallocatePool (
+                                     SizeAltCfgResp,
+                                     SizeAltCfgResp + StrSize (StringPtrDefault),
+                                     (VOID *) (*AltCfgResp)
+                                     );
+        if (*AltCfgResp == NULL) {
+          FreePool (AltConfigHdr);
+          return EFI_OUT_OF_RESOURCES;
+        }
+        StrCat (*AltCfgResp, StringPtrDefault);
+        *StringPtrEnd = TempChar;
+      }
+    }
+    
+    //
+    // Find next AltCfg String
+    //
+    *(AltConfigHdr + HeaderLength) = L'\0';
+    StringPtrDefault = StrStr (StringPtrDefault + 1, AltConfigHdr);    
+  }
+  
+  FreePool (AltConfigHdr);
+  return EFI_SUCCESS;  
+}
+
+/**
+  This function inserts new DefaultValueData into the BlockData DefaultValue array.
+
+  @param  BlockData         The BlockData is updated to add new default value.
+  @param  DefaultValueData  The DefaultValue is added.
+
+**/
+VOID
+InsertDefaultValue (
+  IN IFR_BLOCK_DATA         *BlockData,
+  IN IFR_DEFAULT_DATA       *DefaultValueData
+  )
+{
+  LIST_ENTRY             *Link;
+  IFR_DEFAULT_DATA       *DefaultValueArray;
+
+  for (Link = BlockData->DefaultValueEntry.ForwardLink; Link != &BlockData->DefaultValueEntry; Link = Link->ForwardLink) {
+    DefaultValueArray = BASE_CR (Link, IFR_DEFAULT_DATA, Entry);
+    if (DefaultValueArray->DefaultId == DefaultValueData->DefaultId) {
+      //
+      // DEFAULT_VALUE_FROM_OPCODE has high priority, DEFAULT_VALUE_FROM_DEFAULT has low priority.
+      //
+      if (DefaultValueData->Type > DefaultValueArray->Type) {
+        //
+        // Update the default value array in BlockData.
+        //
+        CopyMem (&DefaultValueArray->Value, &DefaultValueData->Value, sizeof (EFI_IFR_TYPE_VALUE));
+        DefaultValueArray->Type  = DefaultValueData->Type;
+        DefaultValueArray->Cleaned = DefaultValueData->Cleaned;
+      }
+      return;
+    } 
+  }
+
+  //
+  // Insert new default value data in tail.
+  //
+  DefaultValueArray = AllocateZeroPool (sizeof (IFR_DEFAULT_DATA));
+  ASSERT (DefaultValueArray != NULL);
+  CopyMem (DefaultValueArray, DefaultValueData, sizeof (IFR_DEFAULT_DATA));
+  InsertTailList (Link, &DefaultValueArray->Entry);
+}
+
+/**
+  This function inserts new BlockData into the block link
+
+  @param  BlockLink   The list entry points to block array.
+  @param  BlockData   The point to BlockData is added.
+  
+**/
+VOID
+InsertBlockData (
+  IN LIST_ENTRY        *BlockLink,
+  IN IFR_BLOCK_DATA    **BlockData
+  )
+{
+  LIST_ENTRY      *Link;
+  IFR_BLOCK_DATA  *BlockArray;
+  IFR_BLOCK_DATA  *BlockSingleData;
+
+  BlockSingleData = *BlockData;
+  
+  //
+  // Insert block data in its Offset and Width order.
+  //
+  for (Link = BlockLink->ForwardLink; Link != BlockLink; Link = Link->ForwardLink) {
+    BlockArray = BASE_CR (Link, IFR_BLOCK_DATA, Entry);
+    if (BlockArray->Offset == BlockSingleData->Offset) {
+      if (BlockArray->Width > BlockSingleData->Width) {
+        //
+        // Insert this block data in the front of block array
+        //
+        InsertTailList (Link, &BlockSingleData->Entry);
+        return;
+      }
+
+      if (BlockArray->Width == BlockSingleData->Width) {
+        //
+        // The same block array has been added.
+        //
+        FreePool (BlockSingleData);
+        *BlockData = BlockArray;
+        return;
+      }
+    } else if (BlockArray->Offset > BlockSingleData->Offset) {
+      //
+      // Insert new block data in the front of block array 
+      //
+      InsertTailList (Link, &BlockSingleData->Entry);
+      return;
+    }
+  }
+  
+  //
+  // Add new block data into the tail.
+  //
+  InsertTailList (Link, &BlockSingleData->Entry);
+  return;  
+}
+
+/**
+  This function checks VarOffset and VarWidth is in the block range.
+
+  @param  RequestBlockArray  The block array is to be checked. 
+  @param  VarOffset          Offset of var to the structure
+  @param  VarWidth           Width of var.
+  
+  @retval TRUE   This Var is in the block range.
+  @retval FALSE  This Var is not in the block range.
+**/
+BOOLEAN
+IntBlockArrayCheck (
+  IN IFR_BLOCK_DATA  *RequestBlockArray,
+  IN UINT16          VarOffset,
+  IN UINT16          VarWidth
+  )
+{
+  LIST_ENTRY          *Link;
+  IFR_BLOCK_DATA      *BlockData;
+  
+  //
+  // No Request Block array, all vars are got.
+  //
+  if (RequestBlockArray == NULL) {
+    return TRUE;
+  }
+  
+  //
+  // Check the input var is in the request block range.
+  //
+  for (Link = RequestBlockArray->Entry.ForwardLink; Link != &RequestBlockArray->Entry; Link = Link->ForwardLink) {
+    BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);
+    if ((VarOffset >= BlockData->Offset) && ((VarOffset + VarWidth) <= (BlockData->Offset + BlockData->Width))) {
+      return TRUE;
+    }
+  }
+
+  return FALSE;
+}
+
+/**
+  Get form package data from data base.
+
+  @param  DataBaseRecord         The DataBaseRecord instance contains the found Hii handle and package.
+  @param  HiiFormPackage         The buffer saves the package data.
+  @param  PackageSize            The buffer size of the package data.
+
+**/
+EFI_STATUS
+GetFormPackageData (
+  IN     HII_DATABASE_RECORD        *DataBaseRecord,
+  IN OUT UINT8                      **HiiFormPackage,
+  OUT    UINTN                      *PackageSize
+  )
+{
+  EFI_STATUS                   Status;
+  UINTN                        Size;
+  UINTN                        ResultSize;
+
+  if (DataBaseRecord == NULL || HiiFormPackage == NULL || PackageSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Size       = 0;
+  ResultSize = 0;
+  //
+  // 0. Get Hii Form Package by HiiHandle
+  //
+  Status = ExportFormPackages (
+             &mPrivate, 
+             DataBaseRecord->Handle, 
+             DataBaseRecord->PackageList, 
+             0, 
+             Size, 
+             HiiFormPackage,
+             &ResultSize
+           );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+ 
+  (*HiiFormPackage) = AllocatePool (ResultSize);
+  if (*HiiFormPackage == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    return Status;
+  }
+
+  //
+  // Get HiiFormPackage by HiiHandle
+  //
+  Size   = ResultSize;
+  ResultSize    = 0;
+  Status = ExportFormPackages (
+             &mPrivate, 
+             DataBaseRecord->Handle, 
+             DataBaseRecord->PackageList, 
+             0,
+             Size, 
+             *HiiFormPackage,
+             &ResultSize
+           );
+  if (EFI_ERROR (Status)) {
+    FreePool (*HiiFormPackage);
+  }
+  
+  *PackageSize = Size;
+
+  return Status;
+}
+
+
+/**
+  This function parses Form Package to get the efi varstore info according to the request ConfigHdr.
+
+  @param  DataBaseRecord        The DataBaseRecord instance contains the found Hii handle and package.
+  @param  ConfigHdr             Request string ConfigHdr. If it is NULL,
+                                the first found varstore will be as ConfigHdr.
+  @param  IsEfiVarstore         Whether the request storage type is efi varstore type.
+  @param  EfiVarStore           The efi varstore info which will return.
+**/                                
+EFI_STATUS
+GetVarStoreType (
+  IN     HII_DATABASE_RECORD        *DataBaseRecord,
+  IN     EFI_STRING                 ConfigHdr,
+  OUT    BOOLEAN                    *IsEfiVarstore,
+  OUT    EFI_IFR_VARSTORE_EFI       **EfiVarStore
+  
+  )
+{
+  EFI_STATUS               Status;
+  UINTN                    IfrOffset;
+  EFI_IFR_OP_HEADER        *IfrOpHdr;
+  CHAR16                   *VarStoreName;
+  EFI_STRING               GuidStr;
+  EFI_STRING               NameStr;
+  EFI_STRING               TempStr;
+  UINTN                    LengthString;  
+  UINT8                    *HiiFormPackage;
+  UINTN                    PackageSize;
+  EFI_IFR_VARSTORE_EFI     *IfrEfiVarStore;
+  
+  HiiFormPackage = NULL;
+  LengthString     = 0;
+  Status           = EFI_SUCCESS;
+  GuidStr          = NULL;
+  NameStr          = NULL;
+  TempStr          = NULL;
+
+  Status = GetFormPackageData(DataBaseRecord, &HiiFormPackage, &PackageSize);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  IfrOffset   = sizeof (EFI_HII_PACKAGE_HEADER);
+  while (IfrOffset < PackageSize) {
+    IfrOpHdr  = (EFI_IFR_OP_HEADER *) (HiiFormPackage + IfrOffset);    
+    IfrOffset += IfrOpHdr->Length;
+
+    if (IfrOpHdr->OpCode == EFI_IFR_VARSTORE_EFI_OP ) {
+      IfrEfiVarStore = (EFI_IFR_VARSTORE_EFI *) IfrOpHdr;
+      //
+      // If the length is small than the structure, this is from old efi 
+      // varstore definition. Old efi varstore get config directly from 
+      // GetVariable function.
+      //
+      if (IfrOpHdr->Length < sizeof (EFI_IFR_VARSTORE_EFI)) {
+        continue;
+      }
+
+      VarStoreName = AllocateZeroPool (AsciiStrSize ((CHAR8 *)IfrEfiVarStore->Name) * sizeof (CHAR16));
+      if (VarStoreName == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      AsciiStrToUnicodeStr ((CHAR8 *) IfrEfiVarStore->Name, VarStoreName);
+
+      GenerateSubStr (L"GUID=", sizeof (EFI_GUID), (VOID *) &IfrEfiVarStore->Guid, 1, &GuidStr);
+      GenerateSubStr (L"NAME=", StrLen (VarStoreName) * sizeof (CHAR16), (VOID *) VarStoreName, 2, &NameStr);
+      LengthString = StrLen (GuidStr);
+      LengthString = LengthString + StrLen (NameStr) + 1;
+      TempStr = AllocateZeroPool (LengthString * sizeof (CHAR16));
+      if (TempStr == NULL) {
+        FreePool (GuidStr);
+        FreePool (NameStr);
+        FreePool (VarStoreName);
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      StrCpy (TempStr, GuidStr);
+      StrCat (TempStr, NameStr);
+      if (ConfigHdr == NULL || StrnCmp (ConfigHdr, TempStr, StrLen (TempStr)) == 0) {
+        *EfiVarStore = (EFI_IFR_VARSTORE_EFI *) AllocateZeroPool (IfrOpHdr->Length);
+        if (*EfiVarStore == NULL) {
+          FreePool (VarStoreName);
+          FreePool (GuidStr);
+          FreePool (NameStr);
+          FreePool (TempStr);
+          Status = EFI_OUT_OF_RESOURCES;
+          goto Done;
+        }
+        *IsEfiVarstore = TRUE;
+        CopyMem (*EfiVarStore, IfrEfiVarStore, IfrOpHdr->Length);
+      } 
+        
+      //
+      // Free alllocated temp string.
+      //
+      FreePool (VarStoreName);
+      FreePool (GuidStr);
+      FreePool (NameStr);
+      FreePool (TempStr);
+    }
+  }
+Done:
+  if (HiiFormPackage != NULL) {
+    FreePool (HiiFormPackage);
+  }
+
+  return Status;
+}
+
+/**
+  This function parses Form Package to get the block array and the default
+  value array according to the request ConfigHdr.
+
+  @param  Package               Pointer to the form package data.
+  @param  PackageLength         Length of the pacakge.
+  @param  ConfigHdr             Request string ConfigHdr. If it is NULL,
+                                the first found varstore will be as ConfigHdr.
+  @param  RequestBlockArray     The block array is retrieved from the request string.
+  @param  VarStorageData        VarStorage structure contains the got block and default value.
+  @param  PIfrDefaultIdArray    Point to the got default id and default name array.
+
+  @retval EFI_SUCCESS           The block array and the default value array are got.
+  @retval EFI_INVALID_PARAMETER The varstore defintion in the differnt form pacakges
+                                are conflicted. 
+  @retval EFI_OUT_OF_RESOURCES  No enough memory.
+**/
+EFI_STATUS
+EFIAPI
+ParseIfrData (
+  IN     UINT8               *Package,
+  IN     UINT32              PackageLength,
+  IN     EFI_STRING          ConfigHdr,
+  IN     IFR_BLOCK_DATA      *RequestBlockArray,
+  IN OUT IFR_VARSTORAGE_DATA *VarStorageData,
+  OUT    IFR_DEFAULT_DATA    *DefaultIdArray
+  )
+{
+  EFI_STATUS               Status;
+  UINTN                    IfrOffset;
+  EFI_IFR_VARSTORE         *IfrVarStore;
+  EFI_IFR_VARSTORE_EFI     *IfrEfiVarStore;
+  EFI_IFR_OP_HEADER        *IfrOpHdr;
+  EFI_IFR_ONE_OF           *IfrOneOf;
+  EFI_IFR_REF4             *IfrRef;
+  EFI_IFR_ONE_OF_OPTION    *IfrOneOfOption;
+  EFI_IFR_DEFAULT          *IfrDefault;
+  EFI_IFR_ORDERED_LIST     *IfrOrderedList;
+  EFI_IFR_CHECKBOX         *IfrCheckBox;
+  EFI_IFR_PASSWORD         *IfrPassword;
+  EFI_IFR_STRING           *IfrString;
+  IFR_DEFAULT_DATA         DefaultData;
+  IFR_DEFAULT_DATA         *DefaultDataPtr;
+  IFR_BLOCK_DATA           *BlockData;
+  CHAR16                   *VarStoreName;
+  UINT16                   VarOffset;
+  UINT16                   VarWidth;
+  UINT16                   VarDefaultId;
+  EFI_STRING               GuidStr;
+  EFI_STRING               NameStr;
+  EFI_STRING               TempStr;
+  UINTN                    LengthString;
+  BOOLEAN                  FirstOneOfOption;
+  LIST_ENTRY               *LinkData;
+  LIST_ENTRY               *LinkDefault;
+
+  LengthString     = 0;
+  Status           = EFI_SUCCESS;
+  GuidStr          = NULL;
+  NameStr          = NULL;
+  TempStr          = NULL;
+  BlockData        = NULL;
+  DefaultDataPtr   = NULL;
+  FirstOneOfOption = FALSE;
+  ZeroMem (&DefaultData, sizeof (IFR_DEFAULT_DATA));
+
+  //
+  // Go through the form package to parse OpCode one by one.
+  //
+  IfrOffset   = sizeof (EFI_HII_PACKAGE_HEADER);
+  while (IfrOffset < PackageLength) {
+    IfrOpHdr  = (EFI_IFR_OP_HEADER *) (Package + IfrOffset);
+
+    switch (IfrOpHdr->OpCode) {
+    case EFI_IFR_VARSTORE_OP:
+      //
+      // VarStore is found. Don't need to search any more.
+      //
+      if (VarStorageData->Size != 0) {
+        break;
+      }
+
+      //
+      // Get the requied varstore information
+      // Add varstore by Guid and Name in ConfigHdr
+      // Make sure Offset is in varstore size and varstoreid
+      //
+      IfrVarStore = (EFI_IFR_VARSTORE *) IfrOpHdr;
+      VarStoreName = AllocateZeroPool (AsciiStrSize ((CHAR8 *)IfrVarStore->Name) * sizeof (CHAR16));
+      if (VarStoreName == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      AsciiStrToUnicodeStr ((CHAR8 *) IfrVarStore->Name, VarStoreName);
+
+      GenerateSubStr (L"GUID=", sizeof (EFI_GUID), (VOID *) &IfrVarStore->Guid, 1, &GuidStr);
+      GenerateSubStr (L"NAME=", StrLen (VarStoreName) * sizeof (CHAR16), (VOID *) VarStoreName, 2, &NameStr);
+      LengthString = StrLen (GuidStr);
+      LengthString = LengthString + StrLen (NameStr) + 1;
+      TempStr = AllocateZeroPool (LengthString * sizeof (CHAR16));
+      if (TempStr == NULL) {
+        FreePool (GuidStr);
+        FreePool (NameStr);
+        FreePool (VarStoreName);
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      StrCpy (TempStr, GuidStr);
+      StrCat (TempStr, NameStr);
+      if (ConfigHdr == NULL || StrnCmp (ConfigHdr, TempStr, StrLen (TempStr)) == 0) {
+        //
+        // Find the matched VarStore
+        //
+        CopyGuid (&VarStorageData->Guid, (EFI_GUID *) (VOID *) &IfrVarStore->Guid);
+        VarStorageData->VarStoreId = IfrVarStore->VarStoreId;
+        VarStorageData->Size       = IfrVarStore->Size;
+        VarStorageData->Name       = VarStoreName;
+      } else {
+        //
+        // No found, free the allocated memory 
+        //
+        FreePool (VarStoreName);
+      }
+      //
+      // Free alllocated temp string.
+      //
+      FreePool (GuidStr);
+      FreePool (NameStr);
+      FreePool (TempStr);
+      break;
+
+    case EFI_IFR_VARSTORE_EFI_OP:
+      //
+      // VarStore is found. Don't need to search any more.
+      //
+      if (VarStorageData->Size != 0) {
+        break;
+      }
+
+      //
+      // Get the requied varstore information
+      // Add varstore by Guid and Name in ConfigHdr
+      // Make sure Offset is in varstore size and varstoreid
+      //
+      IfrEfiVarStore = (EFI_IFR_VARSTORE_EFI *) IfrOpHdr;
+
+      //
+      // If the length is small than the structure, this is from old efi 
+      // varstore definition. Old efi varstore get config directly from 
+      // GetVariable function.
+      //      
+      if (IfrOpHdr->Length < sizeof (EFI_IFR_VARSTORE_EFI)) {
+        break;
+      }
+
+      VarStoreName = AllocateZeroPool (AsciiStrSize ((CHAR8 *)IfrEfiVarStore->Name) * sizeof (CHAR16));
+      if (VarStoreName == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      AsciiStrToUnicodeStr ((CHAR8 *) IfrEfiVarStore->Name, VarStoreName);
+
+      GenerateSubStr (L"GUID=", sizeof (EFI_GUID), (VOID *) &IfrEfiVarStore->Guid, 1, &GuidStr);
+      GenerateSubStr (L"NAME=", StrLen (VarStoreName) * sizeof (CHAR16), (VOID *) VarStoreName, 2, &NameStr);
+      LengthString = StrLen (GuidStr);
+      LengthString = LengthString + StrLen (NameStr) + 1;
+      TempStr = AllocateZeroPool (LengthString * sizeof (CHAR16));
+      if (TempStr == NULL) {
+        FreePool (GuidStr);
+        FreePool (NameStr);
+        FreePool (VarStoreName);
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      StrCpy (TempStr, GuidStr);
+      StrCat (TempStr, NameStr);
+      if (ConfigHdr == NULL || StrnCmp (ConfigHdr, TempStr, StrLen (TempStr)) == 0) {
+        //
+        // Find the matched VarStore
+        //
+        CopyGuid (&VarStorageData->Guid, (EFI_GUID *) (VOID *) &IfrEfiVarStore->Guid);
+        VarStorageData->VarStoreId = IfrEfiVarStore->VarStoreId;
+        VarStorageData->Size       = IfrEfiVarStore->Size;
+        VarStorageData->Name       = VarStoreName;
+      } else {
+        //
+        // No found, free the allocated memory 
+        //
+        FreePool (VarStoreName);
+      }
+      //
+      // Free alllocated temp string.
+      //
+      FreePool (GuidStr);
+      FreePool (NameStr);
+      FreePool (TempStr);
+      break;
+
+    case EFI_IFR_DEFAULTSTORE_OP:
+      //
+      // Add new the map between default id and default name.
+      //
+      DefaultDataPtr = (IFR_DEFAULT_DATA *) AllocateZeroPool (sizeof (IFR_DEFAULT_DATA));
+      if (DefaultDataPtr == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      DefaultDataPtr->DefaultId   = ((EFI_IFR_DEFAULTSTORE *) IfrOpHdr)->DefaultId;
+      InsertTailList (&DefaultIdArray->Entry, &DefaultDataPtr->Entry);
+      DefaultDataPtr = NULL;
+      break;
+
+    case EFI_IFR_FORM_OP:
+    case EFI_IFR_FORM_MAP_OP:
+      //
+      // No matched varstore is found and directly return.
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_SUCCESS;
+        goto Done;
+      }
+      break;
+
+    case EFI_IFR_REF_OP:
+      //
+      // Ref question is not in IFR Form. This IFR form is not valid. 
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      //
+      // Check whether this question is for the requested varstore.
+      //
+      IfrRef = (EFI_IFR_REF4 *) IfrOpHdr;
+      if (IfrRef->Question.VarStoreId != VarStorageData->VarStoreId) {
+        break;
+      }
+      
+      //
+      // Get Offset/Width by Question header.
+      //
+      VarOffset = IfrRef->Question.VarStoreInfo.VarOffset;
+      VarWidth  = (UINT16) (sizeof (EFI_HII_REF));
+      //
+      // Check whether this question is in requested block array.
+      //
+      if (!IntBlockArrayCheck (RequestBlockArray, VarOffset, VarWidth)) {
+        //
+        // This question is not in the requested string. Skip it.
+        //
+        break;
+      }
+
+      //
+      // Check this var question is in the var storage 
+      //
+      if ((VarOffset + VarWidth) > VarStorageData->Size) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset     = VarOffset;
+      BlockData->Width      = VarWidth;
+      BlockData->QuestionId = IfrRef->Question.QuestionId;
+      BlockData->OpCode     = IfrOpHdr->OpCode;
+      BlockData->Scope      = IfrOpHdr->Scope;
+      InitializeListHead (&BlockData->DefaultValueEntry);
+      //
+      // Add Block Data into VarStorageData BlockEntry
+      //
+      InsertBlockData (&VarStorageData->BlockEntry, &BlockData);
+      break;
+
+    case EFI_IFR_ONE_OF_OP:
+    case EFI_IFR_NUMERIC_OP:
+      //
+      // Numeric and OneOf has the same opcode structure.
+      //
+
+      //
+      // Numeric and OneOf question is not in IFR Form. This IFR form is not valid. 
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      //
+      // Check whether this question is for the requested varstore.
+      //
+      IfrOneOf = (EFI_IFR_ONE_OF *) IfrOpHdr;
+      if (IfrOneOf->Question.VarStoreId != VarStorageData->VarStoreId) {
+        break;
+      }
+      
+      //
+      // Get Offset/Width by Question header and OneOf Flags
+      //
+      VarOffset = IfrOneOf->Question.VarStoreInfo.VarOffset;
+      VarWidth  = (UINT16) (1 << (IfrOneOf->Flags & EFI_IFR_NUMERIC_SIZE));
+      //
+      // Check whether this question is in requested block array.
+      //
+      if (!IntBlockArrayCheck (RequestBlockArray, VarOffset, VarWidth)) {
+        //
+        // This question is not in the requested string. Skip it.
+        //
+        break;
+      }
+
+      //
+      // Check this var question is in the var storage 
+      //
+      if ((VarOffset + VarWidth) > VarStorageData->Size) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset     = VarOffset;
+      BlockData->Width      = VarWidth;
+      BlockData->QuestionId = IfrOneOf->Question.QuestionId;
+      BlockData->OpCode     = IfrOpHdr->OpCode;
+      BlockData->Scope      = IfrOpHdr->Scope;
+      InitializeListHead (&BlockData->DefaultValueEntry);
+      //
+      // Add Block Data into VarStorageData BlockEntry
+      //
+      InsertBlockData (&VarStorageData->BlockEntry, &BlockData);
+      
+      if (IfrOpHdr->OpCode == EFI_IFR_ONE_OF_OP) {
+        //
+        // Set this flag to TRUE for the first oneof option.
+        //
+        FirstOneOfOption = TRUE;
+      } else if (IfrOpHdr->OpCode == EFI_IFR_NUMERIC_OP) {
+        //
+        // Numeric minimum value will be used as default value when no default is specified. 
+        //
+        DefaultData.Type        = DefaultValueFromDefault;
+        switch (IfrOneOf->Flags & EFI_IFR_NUMERIC_SIZE) {
+        case EFI_IFR_NUMERIC_SIZE_1:
+          DefaultData.Value.u8 = IfrOneOf->data.u8.MinValue;
+          break;
+  
+        case EFI_IFR_NUMERIC_SIZE_2:
+          CopyMem (&DefaultData.Value.u16, &IfrOneOf->data.u16.MinValue, sizeof (UINT16));
+          break;
+  
+        case EFI_IFR_NUMERIC_SIZE_4:
+          CopyMem (&DefaultData.Value.u32, &IfrOneOf->data.u32.MinValue, sizeof (UINT32));
+          break;
+  
+        case EFI_IFR_NUMERIC_SIZE_8:
+          CopyMem (&DefaultData.Value.u64, &IfrOneOf->data.u64.MinValue, sizeof (UINT64));
+          break;
+        }
+        //
+        // Set default value base on the DefaultId list get from IFR data.
+        //        
+        for (LinkData = DefaultIdArray->Entry.ForwardLink; LinkData != &DefaultIdArray->Entry; LinkData = LinkData->ForwardLink) {
+          DefaultDataPtr = BASE_CR (LinkData, IFR_DEFAULT_DATA, Entry);     
+          DefaultData.DefaultId   = DefaultDataPtr->DefaultId;
+          InsertDefaultValue (BlockData, &DefaultData);
+        }
+      }
+      break;
+
+    case EFI_IFR_ORDERED_LIST_OP:
+      //
+      // offset by question header
+      // width by EFI_IFR_ORDERED_LIST MaxContainers * OneofOption Type
+      // no default value and default id, how to define its default value?
+      //
+
+      //
+      // OrderedList question is not in IFR Form. This IFR form is not valid. 
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      //
+      // Check whether this question is for the requested varstore.
+      //
+      IfrOrderedList = (EFI_IFR_ORDERED_LIST *) IfrOpHdr;
+      if (IfrOrderedList->Question.VarStoreId != VarStorageData->VarStoreId) {
+        BlockData = NULL;
+        break;
+      }
+
+      //
+      // Get Offset/Width by Question header and OneOf Flags
+      //
+      VarOffset = IfrOrderedList->Question.VarStoreInfo.VarOffset;
+      VarWidth  = IfrOrderedList->MaxContainers;
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset     = VarOffset;
+      BlockData->Width      = VarWidth;
+      BlockData->QuestionId = IfrOrderedList->Question.QuestionId;
+      BlockData->OpCode     = IfrOpHdr->OpCode;
+      BlockData->Scope      = IfrOpHdr->Scope;
+      InitializeListHead (&BlockData->DefaultValueEntry);
+      break;
+
+    case EFI_IFR_CHECKBOX_OP:
+      //
+      // EFI_IFR_DEFAULT_OP
+      // offset by question header
+      // width is 1 sizeof (BOOLEAN)
+      // default id by CheckBox Flags if CheckBox flags (Default or Mau) is set, the default value is 1 to be set.
+      // value by DefaultOption
+      // default id by DeaultOption DefaultId can override CheckBox Flags and Default value.
+      // 
+
+      //
+      // CheckBox question is not in IFR Form. This IFR form is not valid. 
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      //
+      // Check whether this question is for the requested varstore.
+      //
+      IfrCheckBox = (EFI_IFR_CHECKBOX *) IfrOpHdr;
+      if (IfrCheckBox->Question.VarStoreId != VarStorageData->VarStoreId) {
+        break;
+      }
+      
+      //
+      // Get Offset/Width by Question header and OneOf Flags
+      //
+      VarOffset = IfrCheckBox->Question.VarStoreInfo.VarOffset;
+      VarWidth  = (UINT16) sizeof (BOOLEAN);
+
+      //
+      // Check whether this question is in requested block array.
+      //
+      if (!IntBlockArrayCheck (RequestBlockArray, VarOffset, VarWidth)) {
+        //
+        // This question is not in the requested string. Skip it.
+        //
+        break;
+      }
+
+      //
+      // Check this var question is in the var storage 
+      //
+      if ((VarOffset + VarWidth) > VarStorageData->Size) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset     = VarOffset;
+      BlockData->Width      = VarWidth;
+      BlockData->QuestionId = IfrCheckBox->Question.QuestionId;
+      BlockData->OpCode     = IfrOpHdr->OpCode;
+      BlockData->Scope      = IfrOpHdr->Scope;
+      InitializeListHead (&BlockData->DefaultValueEntry);
+      //
+      // Add Block Data into VarStorageData BlockEntry
+      //
+      InsertBlockData (&VarStorageData->BlockEntry, &BlockData);
+      
+      //
+      // Add default value for standard ID by CheckBox Flag
+      //
+      VarDefaultId = EFI_HII_DEFAULT_CLASS_STANDARD;
+      //
+      // Prepare new DefaultValue
+      //
+      DefaultData.DefaultId   = VarDefaultId;
+      if ((IfrCheckBox->Flags & EFI_IFR_CHECKBOX_DEFAULT) == EFI_IFR_CHECKBOX_DEFAULT) {
+        //
+        // When flag is set, defautl value is TRUE.
+        //
+        DefaultData.Type    = DefaultValueFromFlag;
+        DefaultData.Value.b = TRUE;
+      } else {
+        //
+        // When flag is not set, defautl value is FASLE.
+        //
+        DefaultData.Type    = DefaultValueFromDefault;
+        DefaultData.Value.b = FALSE;
+      }
+      //
+      // Add DefaultValue into current BlockData
+      //
+      InsertDefaultValue (BlockData, &DefaultData);
+
+      //
+      // Add default value for Manufacture ID by CheckBox Flag
+      //
+      VarDefaultId = EFI_HII_DEFAULT_CLASS_MANUFACTURING;
+      //
+      // Prepare new DefaultValue
+      //
+      DefaultData.DefaultId   = VarDefaultId;
+      if ((IfrCheckBox->Flags & EFI_IFR_CHECKBOX_DEFAULT_MFG) == EFI_IFR_CHECKBOX_DEFAULT_MFG) {
+        //
+        // When flag is set, defautl value is TRUE.
+        //
+        DefaultData.Type    = DefaultValueFromFlag;
+        DefaultData.Value.b = TRUE;
+      } else {
+        //
+        // When flag is not set, defautl value is FASLE.
+        //
+        DefaultData.Type    = DefaultValueFromDefault;        
+        DefaultData.Value.b = FALSE;
+      }
+      //
+      // Add DefaultValue into current BlockData
+      //
+      InsertDefaultValue (BlockData, &DefaultData);
+      break;
+
+    case EFI_IFR_STRING_OP:
+      //
+      // offset by question header
+      // width MaxSize * sizeof (CHAR16)
+      // no default value, only block array
+      //
+
+      //
+      // String question is not in IFR Form. This IFR form is not valid. 
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      //
+      // Check whether this question is for the requested varstore.
+      //
+      IfrString = (EFI_IFR_STRING *) IfrOpHdr;
+      if (IfrString->Question.VarStoreId != VarStorageData->VarStoreId) {
+        break;
+      }
+      
+      //
+      // Get Offset/Width by Question header and OneOf Flags
+      //
+      VarOffset = IfrString->Question.VarStoreInfo.VarOffset;
+      VarWidth  = (UINT16) (IfrString->MaxSize * sizeof (UINT16));
+
+      //
+      // Check whether this question is in requested block array.
+      //
+      if (!IntBlockArrayCheck (RequestBlockArray, VarOffset, VarWidth)) {
+        //
+        // This question is not in the requested string. Skip it.
+        //
+        break;
+      }
+
+      //
+      // Check this var question is in the var storage 
+      //
+      if ((VarOffset + VarWidth) > VarStorageData->Size) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset     = VarOffset;
+      BlockData->Width      = VarWidth;
+      BlockData->QuestionId = IfrString->Question.QuestionId;
+      BlockData->OpCode     = IfrOpHdr->OpCode;
+      InitializeListHead (&BlockData->DefaultValueEntry);
+      
+      //
+      // Add Block Data into VarStorageData BlockEntry
+      //
+      InsertBlockData (&VarStorageData->BlockEntry, &BlockData);
+      
+      //
+      // No default value for string.
+      //
+      BlockData = NULL;
+      break;
+
+    case EFI_IFR_PASSWORD_OP:
+      //
+      // offset by question header
+      // width MaxSize * sizeof (CHAR16)
+      // no default value, only block array
+      //
+
+      //
+      // Password question is not in IFR Form. This IFR form is not valid. 
+      //
+      if (VarStorageData->Size == 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      //
+      // Check whether this question is for the requested varstore.
+      //
+      IfrPassword = (EFI_IFR_PASSWORD *) IfrOpHdr;
+      if (IfrPassword->Question.VarStoreId != VarStorageData->VarStoreId) {
+        break;
+      }
+      
+      //
+      // Get Offset/Width by Question header and OneOf Flags
+      //
+      VarOffset = IfrPassword->Question.VarStoreInfo.VarOffset;
+      VarWidth  = (UINT16) (IfrPassword->MaxSize * sizeof (UINT16));
+
+      //
+      // Check whether this question is in requested block array.
+      //
+      if (!IntBlockArrayCheck (RequestBlockArray, VarOffset, VarWidth)) {
+        //
+        // This question is not in the requested string. Skip it.
+        //
+        break;
+      }
+
+      //
+      // Check this var question is in the var storage 
+      //
+      if ((VarOffset + VarWidth) > VarStorageData->Size) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset     = VarOffset;
+      BlockData->Width      = VarWidth;
+      BlockData->QuestionId = IfrPassword->Question.QuestionId;
+      BlockData->OpCode     = IfrOpHdr->OpCode;
+      InitializeListHead (&BlockData->DefaultValueEntry);
+      
+      //
+      // Add Block Data into VarStorageData BlockEntry
+      //
+      InsertBlockData (&VarStorageData->BlockEntry, &BlockData);
+      
+      //
+      // No default value for string.
+      //
+      BlockData = NULL;
+      break;
+
+    case EFI_IFR_ONE_OF_OPTION_OP:
+      //
+      // No matched block data is ignored.
+      //
+      if (BlockData == NULL || BlockData->Scope == 0) {
+        break;
+      }
+      
+      IfrOneOfOption = (EFI_IFR_ONE_OF_OPTION *) IfrOpHdr;
+      if (BlockData->OpCode == EFI_IFR_ORDERED_LIST_OP) {
+        //
+        // Get ordered list option data type.
+        //
+        if (IfrOneOfOption->Type == EFI_IFR_TYPE_NUM_SIZE_8 || IfrOneOfOption->Type == EFI_IFR_TYPE_BOOLEAN) {
+          VarWidth = 1;
+        } else if (IfrOneOfOption->Type == EFI_IFR_TYPE_NUM_SIZE_16) {
+          VarWidth = 2;
+        } else if (IfrOneOfOption->Type == EFI_IFR_TYPE_NUM_SIZE_32) {
+          VarWidth = 4;
+        } else if (IfrOneOfOption->Type == EFI_IFR_TYPE_NUM_SIZE_64) {
+          VarWidth = 8;
+        } else {
+          //
+          // Invalid ordered list option data type.
+          //
+          Status = EFI_INVALID_PARAMETER;
+          FreePool (BlockData);
+          goto Done;
+        }
+
+        //
+        // Calculate Ordered list QuestionId width.
+        //
+        BlockData->Width = (UINT16) (BlockData->Width * VarWidth);
+        //
+        // Check whether this question is in requested block array.
+        //
+        if (!IntBlockArrayCheck (RequestBlockArray, BlockData->Offset, BlockData->Width)) {
+          //
+          // This question is not in the requested string. Skip it.
+          //
+          FreePool (BlockData);
+          BlockData = NULL;
+          break;
+        }
+        //
+        // Check this var question is in the var storage 
+        //
+        if ((BlockData->Offset + BlockData->Width) > VarStorageData->Size) {
+          Status = EFI_INVALID_PARAMETER;
+          FreePool (BlockData);
+          goto Done;
+        }
+        //
+        // Add Block Data into VarStorageData BlockEntry
+        //
+        InsertBlockData (&VarStorageData->BlockEntry, &BlockData);
+        //
+        // No default data for OrderedList.
+        //
+        BlockData = NULL;
+        break;
+      }
+
+      //
+      // 1. Set default value for OneOf option when flag field has default attribute.
+      //
+      if (((IfrOneOfOption->Flags & EFI_IFR_OPTION_DEFAULT) == EFI_IFR_OPTION_DEFAULT) ||
+          ((IfrOneOfOption->Flags & EFI_IFR_OPTION_DEFAULT_MFG) == EFI_IFR_OPTION_DEFAULT_MFG)) {
+        //
+        // This flag is used to specify whether this option is the first. Set it to FALSE for the following options. 
+        // The first oneof option value will be used as default value when no default value is specified. 
+        //
+        FirstOneOfOption = FALSE;
+        
+        // Prepare new DefaultValue
+        //
+        DefaultData.Type  = DefaultValueFromFlag;
+        CopyMem (&DefaultData.Value.u64, &IfrOneOfOption->Value.u64, sizeof (UINT64));
+        if ((IfrOneOfOption->Flags & EFI_IFR_OPTION_DEFAULT) == EFI_IFR_OPTION_DEFAULT) {
+          DefaultData.DefaultId = EFI_HII_DEFAULT_CLASS_STANDARD;
+          InsertDefaultValue (BlockData, &DefaultData);
+        } 
+        if ((IfrOneOfOption->Flags & EFI_IFR_OPTION_DEFAULT_MFG) == EFI_IFR_OPTION_DEFAULT_MFG) {
+          DefaultData.DefaultId = EFI_HII_DEFAULT_CLASS_MANUFACTURING;
+          InsertDefaultValue (BlockData, &DefaultData);
+        }
+
+        
+      }
+      
+      //
+      // 2. Set as the default value when this is the first option.
+      // The first oneof option value will be used as default value when no default value is specified. 
+      //
+      if (FirstOneOfOption) {
+        // This flag is used to specify whether this option is the first. Set it to FALSE for the following options. 
+        FirstOneOfOption = FALSE;
+        
+        //
+        // Prepare new DefaultValue
+        //        
+        DefaultData.Type        = DefaultValueFromDefault;
+        CopyMem (&DefaultData.Value.u64, &IfrOneOfOption->Value.u64, sizeof (UINT64));      
+        for (LinkData = DefaultIdArray->Entry.ForwardLink; LinkData != &DefaultIdArray->Entry; LinkData = LinkData->ForwardLink) {
+          DefaultDataPtr = BASE_CR (LinkData, IFR_DEFAULT_DATA, Entry); 
+          DefaultData.DefaultId   = DefaultDataPtr->DefaultId;
+          InsertDefaultValue (BlockData, &DefaultData);
+        }        
+      }
+      break;
+
+    case EFI_IFR_DEFAULT_OP:
+      //
+      // Update Current BlockData to the default value.
+      //
+      if (BlockData == NULL || BlockData->Scope == 0) {
+        //
+        // No matched block data is ignored.        
+        //
+        break;
+      }
+
+      if (BlockData->OpCode == EFI_IFR_ORDERED_LIST_OP) {
+        //
+        // OrderedList Opcode is no default value.
+        //
+        break;
+      }
+      //
+      // Get the DefaultId
+      //
+      IfrDefault     = (EFI_IFR_DEFAULT *) IfrOpHdr;
+      VarDefaultId   = IfrDefault->DefaultId;
+      //
+      // Prepare new DefaultValue
+      //
+      DefaultData.Type        = DefaultValueFromOpcode;
+      DefaultData.DefaultId   = VarDefaultId;
+      CopyMem (&DefaultData.Value, &IfrDefault->Value, sizeof (EFI_IFR_TYPE_VALUE));
+      
+      // If the value field is expression, set the cleaned flag.
+      if (IfrDefault->Type ==  EFI_IFR_TYPE_OTHER) {
+        DefaultData.Cleaned = TRUE;
+      }
+      //
+      // Add DefaultValue into current BlockData
+      //
+      InsertDefaultValue (BlockData, &DefaultData);
+       
+      //
+      // After insert the default value, reset the cleaned value for next 
+      // time used. If not set here, need to set the value before everytime 
+      // use it.
+      //
+      DefaultData.Cleaned     = FALSE;
+      break;
+    case EFI_IFR_END_OP:
+      //
+      // End Opcode is for Var question.
+      //
+      if (BlockData != NULL && BlockData->Scope > 0) {
+        BlockData->Scope--;
+      }
+      break;
+    default:
+      if (BlockData != NULL && BlockData->Scope > 0) {
+        BlockData->Scope = (UINT8) (BlockData->Scope + IfrOpHdr->Scope);
+      }
+      break;
+    }
+
+    IfrOffset += IfrOpHdr->Length;
+  }
+
+Done:
+  for (LinkData = VarStorageData->BlockEntry.ForwardLink; LinkData != &VarStorageData->BlockEntry; LinkData = LinkData->ForwardLink) {
+    BlockData = BASE_CR (LinkData, IFR_BLOCK_DATA, Entry);
+    for (LinkDefault = BlockData->DefaultValueEntry.ForwardLink; LinkDefault != &BlockData->DefaultValueEntry; ) {
+      DefaultDataPtr = BASE_CR (LinkDefault, IFR_DEFAULT_DATA, Entry);
+      LinkDefault = LinkDefault->ForwardLink;
+      if (DefaultDataPtr->Cleaned == TRUE) {
+        RemoveEntryList (&DefaultDataPtr->Entry);
+        FreePool (DefaultDataPtr);
+      }
+    }
+  }
+
+  return Status;  
+}
+
+/**
+  This function gets the full request string and full default value string by 
+  parsing IFR data in HII form packages. 
+  
+  When Request points to NULL string, the request string and default value string 
+  for each varstore in form package will return. 
+
+  @param  DataBaseRecord         The DataBaseRecord instance contains the found Hii handle and package.
+  @param  DevicePath             Device Path which Hii Config Access Protocol is registered.
+  @param  Request                Pointer to a null-terminated Unicode string in
+                                 <ConfigRequest> format. When it doesn't contain
+                                 any RequestElement, it will be updated to return 
+                                 the full RequestElement retrieved from IFR data.
+                                 If it points to NULL, the request string for the first
+                                 varstore in form package will be merged into a
+                                 <MultiConfigRequest> format string and return. 
+  @param  AltCfgResp             Pointer to a null-terminated Unicode string in
+                                 <ConfigAltResp> format. When the pointer is to NULL,
+                                 the full default value string retrieved from IFR data
+                                 will return. When the pinter is to a string, the
+                                 full default value string retrieved from IFR data
+                                 will be merged into the input string and return.
+                                 When Request points to NULL, the default value string 
+                                 for each varstore in form package will be merged into 
+                                 a <MultiConfigAltResp> format string and return.
+  @param  PointerProgress        Optional parameter, it can be be NULL. 
+                                 When it is not NULL, if Request is NULL, it returns NULL. 
+                                 On return, points to a character in the Request
+                                 string. Points to the string's null terminator if
+                                 request was successful. Points to the most recent
+                                 & before the first failing name / value pair (or
+                                 the beginning of the string if the failure is in
+                                 the first name / value pair) if the request was
+                                 not successful.
+  @retval EFI_SUCCESS            The Results string is set to the full request string.
+                                 And AltCfgResp contains all default value string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory for the return string.
+  @retval EFI_NOT_FOUND          The varstore (Guid and Name) in Request string 
+                                 can't be found in Form package.
+  @retval EFI_NOT_FOUND          HiiPackage can't be got on the input HiiHandle.
+  @retval EFI_INVALID_PARAMETER  Request points to NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+GetFullStringFromHiiFormPackages (
+  IN     HII_DATABASE_RECORD        *DataBaseRecord,
+  IN     EFI_DEVICE_PATH_PROTOCOL   *DevicePath,
+  IN OUT EFI_STRING                 *Request,
+  IN OUT EFI_STRING                 *AltCfgResp,
+  OUT    EFI_STRING                 *PointerProgress OPTIONAL
+  )
+{
+  EFI_STATUS                   Status;
+  UINT8                        *HiiFormPackage;
+  UINTN                        PackageSize;
+  IFR_BLOCK_DATA               *RequestBlockArray;
+  IFR_BLOCK_DATA               *BlockData;
+  IFR_BLOCK_DATA               *NextBlockData;
+  IFR_DEFAULT_DATA             *DefaultValueData;
+  IFR_DEFAULT_DATA             *DefaultId;
+  IFR_DEFAULT_DATA             *DefaultIdArray;
+  IFR_VARSTORAGE_DATA          *VarStorageData;
+  EFI_STRING                   DefaultAltCfgResp;
+  EFI_STRING                   FullConfigRequest;
+  EFI_STRING                   ConfigHdr;
+  EFI_STRING                   GuidStr;
+  EFI_STRING                   NameStr;
+  EFI_STRING                   PathStr;
+  EFI_STRING                   StringPtr;
+  EFI_STRING                   Progress;
+  UINTN                        Length;
+  UINT8                        *TmpBuffer;
+  UINT16                       Offset;
+  UINT16                       Width;
+  LIST_ENTRY                   *Link;
+  LIST_ENTRY                   *LinkData;
+  LIST_ENTRY                   *LinkDefault;
+  BOOLEAN                      DataExist;
+
+  if (DataBaseRecord == NULL || DevicePath == NULL || Request == NULL || AltCfgResp == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Initialize the local variables.
+  //
+  RequestBlockArray = NULL;
+  DefaultIdArray    = NULL;
+  VarStorageData    = NULL;
+  DefaultAltCfgResp = NULL;
+  FullConfigRequest = NULL;
+  ConfigHdr         = NULL;
+  GuidStr           = NULL;
+  NameStr           = NULL;
+  PathStr           = NULL;
+  HiiFormPackage    = NULL;
+  PackageSize       = 0;
+  DataExist         = FALSE;
+  Progress          = *Request;
+
+  Status = GetFormPackageData (DataBaseRecord, &HiiFormPackage, &PackageSize);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // 1. Get the request block array by Request String when Request string containts the block array.
+  //
+  StringPtr = NULL;
+  if (*Request != NULL) {
+    StringPtr = *Request;
+    //
+    // Jump <ConfigHdr>
+    //
+    if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+      Status   = EFI_INVALID_PARAMETER;
+      goto Done;
+    }
+    StringPtr += StrLen (L"GUID=");
+    while (*StringPtr != L'\0' && StrnCmp (StringPtr, L"&NAME=", StrLen (L"&NAME=")) != 0) {
+      StringPtr++;
+    }
+    if (*StringPtr == L'\0') {
+      Status = EFI_INVALID_PARAMETER;
+      goto Done;
+    }
+    StringPtr += StrLen (L"&NAME=");
+    while (*StringPtr != L'\0' && StrnCmp (StringPtr, L"&PATH=", StrLen (L"&PATH=")) != 0) {
+      StringPtr++;
+    }
+    if (*StringPtr == L'\0') {
+      Status = EFI_INVALID_PARAMETER;
+      goto Done;
+    }
+    StringPtr += StrLen (L"&PATH=");
+    while (*StringPtr != L'\0' && *StringPtr != L'&') {
+      StringPtr ++;
+    }
+    //
+    // Check the following string &OFFSET=
+    //
+    if (*StringPtr != L'\0' && StrnCmp (StringPtr, L"&OFFSET=", StrLen (L"&OFFSET=")) != 0) {
+      Progress = StringPtr;
+      Status   = EFI_INVALID_PARAMETER;
+      goto Done;
+    } else if (*StringPtr == L'\0') {
+      //
+      // No request block is found.
+      //
+      StringPtr = NULL;
+    }
+  }
+  if (StringPtr != NULL) {
+    //
+    // Init RequestBlockArray
+    //
+    RequestBlockArray = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+    if (RequestBlockArray == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+    InitializeListHead (&RequestBlockArray->Entry);
+
+    //
+    // Get the request Block array from the request string
+    // Offset and Width
+    //
+
+    //
+    // Parse each <RequestElement> if exists
+    // Only <BlockName> format is supported by this help function.
+    // <BlockName> ::= &'OFFSET='<Number>&'WIDTH='<Number>
+    //
+    while (*StringPtr != 0 && StrnCmp (StringPtr, L"&OFFSET=", StrLen (L"&OFFSET=")) == 0) {
+      //
+      // Skip the OFFSET string
+      //
+      Progress   = StringPtr;
+      StringPtr += StrLen (L"&OFFSET=");
+      //
+      // Get Offset
+      //
+      Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+      if (EFI_ERROR (Status)) {
+        goto Done;
+      }
+      Offset = 0;
+      CopyMem (
+        &Offset,
+        TmpBuffer,
+        (((Length + 1) / 2) < sizeof (UINT16)) ? ((Length + 1) / 2) : sizeof (UINT16)
+        );
+      FreePool (TmpBuffer);
+  
+      StringPtr += Length;
+      if (StrnCmp (StringPtr, L"&WIDTH=", StrLen (L"&WIDTH=")) != 0) {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      StringPtr += StrLen (L"&WIDTH=");
+  
+      //
+      // Get Width
+      //
+      Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+      if (EFI_ERROR (Status)) {
+        goto Done;
+      }
+      Width = 0;
+      CopyMem (
+        &Width,
+        TmpBuffer,
+        (((Length + 1) / 2) < sizeof (UINT16)) ? ((Length + 1) / 2) : sizeof (UINT16)
+        );
+      FreePool (TmpBuffer);
+
+      StringPtr += Length;
+      if (*StringPtr != 0 && *StringPtr != L'&') {
+        Status = EFI_INVALID_PARAMETER;
+        goto Done;
+      }
+      
+      //
+      // Set Block Data
+      //
+      BlockData = (IFR_BLOCK_DATA *) AllocateZeroPool (sizeof (IFR_BLOCK_DATA));
+      if (BlockData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      BlockData->Offset = Offset;
+      BlockData->Width  = Width;
+      InsertBlockData (&RequestBlockArray->Entry, &BlockData);
+      
+      //
+      // Skip &VALUE string if &VALUE does exists.
+      //
+      if (StrnCmp (StringPtr, L"&VALUE=", StrLen (L"&VALUE=")) == 0) {
+        StringPtr += StrLen (L"&VALUE=");
+
+        //
+        // Get Value
+        //
+        Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+        if (EFI_ERROR (Status)) {
+          Status = EFI_INVALID_PARAMETER;
+          goto Done;
+        }
+
+        StringPtr += Length;
+        if (*StringPtr != 0 && *StringPtr != L'&') {
+          Status = EFI_INVALID_PARAMETER;
+          goto Done;
+        }
+      }
+      //
+      // If '\0', parsing is finished. 
+      //
+      if (*StringPtr == 0) {
+        break;
+      }
+    }
+    
+    //
+    // Merge the requested block data.
+    //
+    Link = RequestBlockArray->Entry.ForwardLink;
+    while ((Link != &RequestBlockArray->Entry) && (Link->ForwardLink != &RequestBlockArray->Entry)) {
+      BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);
+      NextBlockData = BASE_CR (Link->ForwardLink, IFR_BLOCK_DATA, Entry);
+      if ((NextBlockData->Offset >= BlockData->Offset) && (NextBlockData->Offset <= (BlockData->Offset + BlockData->Width))) {
+        if ((NextBlockData->Offset + NextBlockData->Width) > (BlockData->Offset + BlockData->Width)) {
+          BlockData->Width = (UINT16) (NextBlockData->Offset + NextBlockData->Width - BlockData->Offset);
+        }
+        RemoveEntryList (Link->ForwardLink);
+        FreePool (NextBlockData);
+        continue;
+      }
+      Link = Link->ForwardLink;      
+    }
+  }
+  
+  //
+  // 2. Parse FormPackage to get BlockArray and DefaultId Array for the request BlockArray.
+  //
+
+  //
+  // Initialize DefaultIdArray to store the map between DeaultId and DefaultName
+  //
+  DefaultIdArray   = (IFR_DEFAULT_DATA *) AllocateZeroPool (sizeof (IFR_DEFAULT_DATA));
+  if (DefaultIdArray == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Done;
+  }
+  InitializeListHead (&DefaultIdArray->Entry);
+
+  //
+  // Initialize VarStorageData to store the var store Block and Default value information.
+  //
+  VarStorageData = (IFR_VARSTORAGE_DATA *) AllocateZeroPool (sizeof (IFR_VARSTORAGE_DATA));
+  if (VarStorageData == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Done;
+  }
+  InitializeListHead (&VarStorageData->Entry);
+  InitializeListHead (&VarStorageData->BlockEntry);
+
+  //
+  // Parse the opcode in form pacakge to get the default setting.
+  //
+  Status = ParseIfrData (HiiFormPackage, (UINT32) PackageSize, *Request, RequestBlockArray, VarStorageData, DefaultIdArray);
+  if (EFI_ERROR (Status)) {
+    goto Done;
+  }
+  
+  //
+  // No requested varstore in IFR data and directly return
+  //
+  if (VarStorageData->Size == 0) {
+    Status = EFI_SUCCESS;
+    goto Done;
+  }
+
+  //
+  // 3. Construct Request Element (Block Name) for 2.1 and 2.2 case.
+  //
+
+  //
+  // Construct <ConfigHdr> : "GUID=...&NAME=...&PATH=..." by VarStorageData Guid, Name and DriverHandle
+  //
+  GenerateSubStr (L"GUID=", sizeof (EFI_GUID), (VOID *) &VarStorageData->Guid, 1, &GuidStr);
+  GenerateSubStr (L"NAME=", StrLen (VarStorageData->Name) * sizeof (CHAR16), (VOID *) VarStorageData->Name, 2, &NameStr);
+  GenerateSubStr (
+    L"PATH=",
+    GetDevicePathSize ((EFI_DEVICE_PATH_PROTOCOL *) DevicePath),
+    (VOID *) DevicePath,
+    1,
+    &PathStr
+    );
+  Length = StrLen (GuidStr);
+  Length = Length + StrLen (NameStr);
+  Length = Length + StrLen (PathStr) + 1;
+  ConfigHdr = AllocateZeroPool (Length * sizeof (CHAR16));
+  if (ConfigHdr == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Done;    
+  }
+  StrCpy (ConfigHdr, GuidStr);
+  StrCat (ConfigHdr, NameStr);
+  StrCat (ConfigHdr, PathStr);
+
+  //
+  // Remove the last character L'&'
+  //
+  *(ConfigHdr + StrLen (ConfigHdr) - 1) = L'\0';
+
+  if (RequestBlockArray == NULL) {
+    //
+    // Append VarStorageData BlockEntry into *Request string
+    // Now support only one varstore in a form package.
+    //
+
+    //
+    // Go through all VarStorageData Entry and get BlockEntry for each one for the multiple varstore in a single form package
+    // Then construct them all to return MultiRequest string : ConfigHdr BlockConfig
+    //
+
+    //
+    // Compute the length of the entire request starting with <ConfigHdr> and a 
+    // Null-terminator
+    //
+    DataExist = FALSE;
+    Length    = StrLen (ConfigHdr) + 1;
+
+    for (Link = VarStorageData->BlockEntry.ForwardLink; Link != &VarStorageData->BlockEntry; Link = Link->ForwardLink) {
+      //
+      // Add <BlockName> length for each Offset/Width pair
+      //
+      // <BlockName> ::= &OFFSET=1234&WIDTH=1234
+      //                 |  8   | 4 |   7  | 4 |
+      //
+      DataExist = TRUE;
+      Length = Length + (8 + 4 + 7 + 4);
+    }
+    
+    //
+    // No any request block data is found. The request string can't be constructed.
+    //
+    if (!DataExist) {
+      Status = EFI_SUCCESS;
+      goto Done;
+    }
+
+    //
+    // Allocate buffer for the entire <ConfigRequest>
+    //
+    FullConfigRequest = AllocateZeroPool (Length * sizeof (CHAR16));
+    if (FullConfigRequest == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+    StringPtr = FullConfigRequest;
+  
+    //
+    // Start with <ConfigHdr>
+    //
+    StrCpy (StringPtr, ConfigHdr);
+    StringPtr += StrLen (StringPtr);
+
+    //
+    // Loop through all the Offset/Width pairs and append them to ConfigRequest
+    //
+    for (Link = VarStorageData->BlockEntry.ForwardLink; Link != &VarStorageData->BlockEntry; Link = Link->ForwardLink) {
+      BlockData = BASE_CR (Link, IFR_BLOCK_DATA, Entry);
+      //
+      // Append &OFFSET=XXXX&WIDTH=YYYY\0
+      //
+      UnicodeSPrint (
+        StringPtr, 
+        (8 + 4 + 7 + 4 + 1) * sizeof (CHAR16), 
+        L"&OFFSET=%04X&WIDTH=%04X", 
+        BlockData->Offset, 
+        BlockData->Width
+      );
+      StringPtr += StrLen (StringPtr);
+    }
+    //
+    // Set to the got full request string.
+    //
+    IntHiiToLower (FullConfigRequest);
+    if (*Request != NULL) {
+      FreePool (*Request);
+    }
+    *Request = FullConfigRequest;
+  }
+  
+  //
+  // 4. Construct Default Value string in AltResp according to request element.
+  // Go through all VarStorageData Entry and get the DefaultId array for each one
+  // Then construct them all to : ConfigHdr AltConfigHdr ConfigBody AltConfigHdr ConfigBody
+  //
+  DataExist = FALSE;
+  //
+  // Add length for <ConfigHdr> + '\0'
+  //
+  Length = StrLen (ConfigHdr) + 1;
+  
+  for (Link = DefaultIdArray->Entry.ForwardLink; Link != &DefaultIdArray->Entry; Link = Link->ForwardLink) {
+    DefaultId = BASE_CR (Link, IFR_DEFAULT_DATA, Entry);
+    //
+    // Add length for "&<ConfigHdr>&ALTCFG=XXXX"
+    //                |1| StrLen (ConfigHdr) | 8 | 4 |
+    //
+    Length += (1 + StrLen (ConfigHdr) + 8 + 4);
+    
+    for (LinkData = VarStorageData->BlockEntry.ForwardLink; LinkData != &VarStorageData->BlockEntry; LinkData = LinkData->ForwardLink) {
+      BlockData = BASE_CR (LinkData, IFR_BLOCK_DATA, Entry);
+      for (LinkDefault = BlockData->DefaultValueEntry.ForwardLink; LinkDefault != &BlockData->DefaultValueEntry; LinkDefault = LinkDefault->ForwardLink) {
+        DefaultValueData = BASE_CR (LinkDefault, IFR_DEFAULT_DATA, Entry);
+        if (DefaultValueData->DefaultId == DefaultId->DefaultId) {
+          //
+          // Add length for "&OFFSET=XXXX&WIDTH=YYYY&VALUE=zzzzzzzzzzzz"
+          //                |    8  | 4 |   7  | 4 |   7  | Width * 2 |
+          //
+          Length += (8 + 4 + 7 + 4 + 7 + BlockData->Width * 2);
+          DataExist = TRUE;
+        }
+      }
+    }
+  }
+  
+  //
+  // No default value is found. The default string doesn't exist.
+  //
+  if (!DataExist) {
+    Status = EFI_SUCCESS;
+    goto Done;
+  }
+
+  //
+  // Allocate buffer for the entire <DefaultAltCfgResp>
+  //
+  DefaultAltCfgResp = AllocateZeroPool (Length * sizeof (CHAR16));
+  if (DefaultAltCfgResp == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Done;
+  }
+  StringPtr = DefaultAltCfgResp;
+
+  //
+  // Start with <ConfigHdr>
+  //
+  StrCpy (StringPtr, ConfigHdr);
+  StringPtr += StrLen (StringPtr);
+
+  for (Link = DefaultIdArray->Entry.ForwardLink; Link != &DefaultIdArray->Entry; Link = Link->ForwardLink) {
+    DefaultId = BASE_CR (Link, IFR_DEFAULT_DATA, Entry);
+    //
+    // Add <AltConfigHdr> of the form "&<ConfigHdr>&ALTCFG=XXXX\0"
+    //                                |1| StrLen (ConfigHdr) | 8 | 4 |
+    //
+    UnicodeSPrint (
+      StringPtr, 
+      (1 + StrLen (ConfigHdr) + 8 + 4 + 1) * sizeof (CHAR16), 
+      L"&%s&ALTCFG=%04X", 
+      ConfigHdr, 
+      DefaultId->DefaultId
+      );
+    StringPtr += StrLen (StringPtr);
+    
+    for (LinkData = VarStorageData->BlockEntry.ForwardLink; LinkData != &VarStorageData->BlockEntry; LinkData = LinkData->ForwardLink) {
+      BlockData = BASE_CR (LinkData, IFR_BLOCK_DATA, Entry);
+      for (LinkDefault = BlockData->DefaultValueEntry.ForwardLink; LinkDefault != &BlockData->DefaultValueEntry; LinkDefault = LinkDefault->ForwardLink) {
+        DefaultValueData = BASE_CR (LinkDefault, IFR_DEFAULT_DATA, Entry);
+        if (DefaultValueData->DefaultId == DefaultId->DefaultId) {
+          //
+          // Add <BlockConfig>
+          // <BlockConfig> ::= 'OFFSET='<Number>&'WIDTH='<Number>&'VALUE'=<Number>
+          //
+          UnicodeSPrint (
+            StringPtr, 
+            (8 + 4 + 7 + 4 + 7 + 1) * sizeof (CHAR16),
+            L"&OFFSET=%04X&WIDTH=%04X&VALUE=", 
+            BlockData->Offset, 
+            BlockData->Width
+            );
+          StringPtr += StrLen (StringPtr);
+
+          //
+          // Convert Value to a hex string in "%x" format
+          // NOTE: This is in the opposite byte that GUID and PATH use
+          //
+          Width     = BlockData->Width;
+          TmpBuffer = (UINT8 *) &(DefaultValueData->Value);
+          for (; Width > 0; Width--) {
+            StringPtr += UnicodeValueToString (StringPtr, PREFIX_ZERO | RADIX_HEX, TmpBuffer[Width - 1], 2);
+          }
+        }
+      }
+    }
+  }
+  IntHiiToLower (DefaultAltCfgResp);
+
+  //
+  // 5. Merge string into the input AltCfgResp if the iput *AltCfgResp is not NULL.
+  //
+  if (*AltCfgResp != NULL && DefaultAltCfgResp != NULL) {
+    Status = MergeDefaultString (AltCfgResp, DefaultAltCfgResp);
+    FreePool (DefaultAltCfgResp);
+  } else if (*AltCfgResp == NULL) {
+    *AltCfgResp = DefaultAltCfgResp;
+  }
+
+Done:
+  if (RequestBlockArray != NULL) {
+    //
+    // Free Link Array RequestBlockArray
+    //
+    while (!IsListEmpty (&RequestBlockArray->Entry)) {
+      BlockData = BASE_CR (RequestBlockArray->Entry.ForwardLink, IFR_BLOCK_DATA, Entry);
+      RemoveEntryList (&BlockData->Entry);
+      FreePool (BlockData);
+    }
+
+    FreePool (RequestBlockArray);
+  }
+  
+  if (VarStorageData != NULL) {
+    //
+    // Free link array VarStorageData
+    //
+    while (!IsListEmpty (&VarStorageData->BlockEntry)) {
+      BlockData = BASE_CR (VarStorageData->BlockEntry.ForwardLink, IFR_BLOCK_DATA, Entry);
+      RemoveEntryList (&BlockData->Entry);
+      //
+      // Free default value link array
+      //
+      while (!IsListEmpty (&BlockData->DefaultValueEntry)) {
+        DefaultValueData = BASE_CR (BlockData->DefaultValueEntry.ForwardLink, IFR_DEFAULT_DATA, Entry);
+        RemoveEntryList (&DefaultValueData->Entry);
+        FreePool (DefaultValueData);
+      }
+      FreePool (BlockData);
+    }
+    FreePool (VarStorageData);
+  }
+
+  if (DefaultIdArray != NULL) {
+    //
+    // Free DefaultId Array
+    //
+    while (!IsListEmpty (&DefaultIdArray->Entry)) {
+      DefaultId = BASE_CR (DefaultIdArray->Entry.ForwardLink, IFR_DEFAULT_DATA, Entry);
+      RemoveEntryList (&DefaultId->Entry);
+      FreePool (DefaultId);
+    }
+    FreePool (DefaultIdArray);
+  }
+  
+  //
+  // Free the allocated string 
+  //
+  if (GuidStr != NULL) {
+    FreePool (GuidStr);
+  }
+  if (NameStr != NULL) {
+    FreePool (NameStr);
+  }
+  if (PathStr != NULL) {
+    FreePool (PathStr);
+  }
+  if (ConfigHdr != NULL) {
+    FreePool (ConfigHdr);
+  }
+
+  //
+  // Free Pacakge data
+  //
+  if (HiiFormPackage != NULL) {
+    FreePool (HiiFormPackage);
+  }
+
+  if (PointerProgress != NULL) {
+    if (*Request == NULL) {
+      *PointerProgress = NULL;
+    } else if (EFI_ERROR (Status)) {
+      *PointerProgress = Progress;
+    } else {
+      *PointerProgress = *Request + StrLen (*Request);
+    }
+  }
+
+  return Status;
+}
+
+/**
+  This function gets the full request resp string by 
+  parsing IFR data in HII form packages.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  EfiVarStoreInfo        The efi varstore info which is save in the EFI 
+                                 varstore data structure.                       
+  @param  Request                Pointer to a null-terminated Unicode string in
+                                 <ConfigRequest> format.
+  @param  RequestResp            Pointer to a null-terminated Unicode string in
+                                 <ConfigResp> format.
+  @param  AccessProgress         On return, points to a character in the Request
+                                 string. Points to the string's null terminator if
+                                 request was successful. Points to the most recent
+                                 & before the first failing name / value pair (or
+                                 the beginning of the string if the failure is in
+                                 the first name / value pair) if the request was
+                                 not successful.
+
+  @retval EFI_SUCCESS            The Results string is set to the full request string.
+                                 And AltCfgResp contains all default value string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory for the return string.
+  @retval EFI_INVALID_PARAMETER  Request points to NULL.
+
+**/
+EFI_STATUS
+GetConfigRespFromEfiVarStore (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  EFI_IFR_VARSTORE_EFI                   *EfiVarStoreInfo,    
+  IN  EFI_STRING                             Request,
+  OUT EFI_STRING                             *RequestResp,
+  OUT EFI_STRING                             *AccessProgress
+  )
+{
+  EFI_STATUS Status;
+  EFI_STRING VarStoreName;
+  UINT8      *VarStore;
+  UINTN      BufferSize;
+
+  Status       = EFI_SUCCESS;
+  BufferSize   = 0;
+  VarStore     = NULL;
+  VarStoreName = NULL;
+  
+  VarStoreName = AllocateZeroPool (AsciiStrSize ((CHAR8 *)EfiVarStoreInfo->Name) * sizeof (CHAR16));
+  if (VarStoreName == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Done;
+  }
+  AsciiStrToUnicodeStr ((CHAR8 *) EfiVarStoreInfo->Name, VarStoreName);
+   
+  
+  Status = gRT->GetVariable (VarStoreName, &EfiVarStoreInfo->Guid, NULL, &BufferSize, NULL);
+  if (Status != EFI_BUFFER_TOO_SMALL) {
+    goto Done;
+  }
+
+  VarStore = AllocateZeroPool (BufferSize);
+  ASSERT (VarStore != NULL);
+  Status = gRT->GetVariable (VarStoreName, &EfiVarStoreInfo->Guid, NULL, &BufferSize, VarStore);
+  if (EFI_ERROR (Status)) {
+    goto Done;
+  }
+
+  Status = HiiBlockToConfig(This, Request, VarStore, BufferSize, RequestResp, AccessProgress);
+  if (EFI_ERROR (Status)) {
+    goto Done;
+  }
+
+Done:
+  if (VarStoreName != NULL) {
+    FreePool (VarStoreName);
+  }
+
+  if (VarStore != NULL) {
+    FreePool (VarStore);
+  }
+
+  return Status;
+}
+
+
+/**
+  This function route the full request resp string for efi varstore. 
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  EfiVarStoreInfo        The efi varstore info which is save in the EFI 
+                                 varstore data structure.      
+  @param  RequestResp            Pointer to a null-terminated Unicode string in
+                                 <ConfigResp> format.
+  @param  Result                 Pointer to a null-terminated Unicode string in
+                                 <ConfigResp> format.
+                                 
+  @retval EFI_SUCCESS            The Results string is set to the full request string.
+                                 And AltCfgResp contains all default value string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory for the return string.
+  @retval EFI_INVALID_PARAMETER  Request points to NULL.
+
+**/
+EFI_STATUS
+RouteConfigRespForEfiVarStore (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  EFI_IFR_VARSTORE_EFI                   *EfiVarStoreInfo,  
+  IN  EFI_STRING                             RequestResp,
+  OUT EFI_STRING                             *Result
+  )
+{
+  EFI_STATUS Status;
+  EFI_STRING VarStoreName;
+  UINT8      *VarStore;
+  UINTN      BufferSize;
+  UINTN      BlockSize;
+
+  Status       = EFI_SUCCESS;
+  BufferSize   = 0;
+  VarStore     = NULL;
+  VarStoreName = NULL;
+
+  VarStoreName = AllocateZeroPool (AsciiStrSize ((CHAR8 *)EfiVarStoreInfo->Name) * sizeof (CHAR16));
+  if (VarStoreName == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Done;
+  }
+  AsciiStrToUnicodeStr ((CHAR8 *) EfiVarStoreInfo->Name, VarStoreName);
+      
+  Status = gRT->GetVariable (VarStoreName, &EfiVarStoreInfo->Guid, NULL, &BufferSize, NULL);
+  if (Status != EFI_BUFFER_TOO_SMALL) {
+    goto Done;
+  }
+
+  BlockSize = BufferSize;
+  VarStore = AllocateZeroPool (BufferSize);
+  ASSERT (VarStore != NULL);
+  Status = gRT->GetVariable (VarStoreName, &EfiVarStoreInfo->Guid, NULL, &BufferSize, VarStore);
+  if (EFI_ERROR (Status)) {
+    goto Done;
+  }
+
+  Status = HiiConfigToBlock(This, RequestResp, VarStore, &BlockSize, Result);
+  if (EFI_ERROR (Status)) {
+    goto Done;
+  }
+
+  Status = gRT->SetVariable (VarStoreName, &EfiVarStoreInfo->Guid, EfiVarStoreInfo->Attributes, BufferSize, VarStore);
+  if (EFI_ERROR (Status)) {
+    goto Done;
+  }
+
+Done:
+  if (VarStoreName != NULL) {
+    FreePool (VarStoreName);
+  }
+
+  if (VarStore != NULL) {
+    FreePool (VarStore);
+  }
+
+  return Status;
+}
+
+/**
+  This function allows a caller to extract the current configuration
+  for one or more named elements from one or more drivers.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  Request                A null-terminated Unicode string in
+                                 <MultiConfigRequest> format.
+  @param  Progress               On return, points to a character in the Request
+                                 string. Points to the string's null terminator if
+                                 request was successful. Points to the most recent
+                                 & before the first failing name / value pair (or
+                                 the beginning of the string if the failure is in
+                                 the first name / value pair) if the request was
+                                 not successful.
+  @param  Results                Null-terminated Unicode string in
+                                 <MultiConfigAltResp> format which has all values
+                                 filled in for the names in the Request string.
+                                 String to be allocated by the called function.
+
+  @retval EFI_SUCCESS            The Results string is filled with the values
+                                 corresponding to all requested names.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to store the parts of the
+                                 results that must be stored awaiting possible
+                                 future        protocols.
+  @retval EFI_NOT_FOUND          Routing data doesn't match any known driver.
+                                   Progress set to the "G" in "GUID" of the routing
+                                  header that doesn't match. Note: There is no
+                                    requirement that all routing data be validated
+                                 before any configuration extraction.
+  @retval EFI_INVALID_PARAMETER  For example, passing in a NULL for the Request
+                                 parameter would result in this type of error. The
+                                 Progress parameter is set to NULL.
+  @retval EFI_INVALID_PARAMETER  Illegal syntax. Progress set to most recent &
+                                 before the error or the beginning of the string.
+  @retval EFI_INVALID_PARAMETER  Unknown name. Progress points to the & before the
+                                 name in question.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigRoutingExtractConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  CONST EFI_STRING                       Request,
+  OUT EFI_STRING                             *Progress,
+  OUT EFI_STRING                             *Results
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  EFI_STRING                          StringPtr;
+  EFI_STRING                          ConfigRequest;
+  UINTN                               Length;
+  EFI_DEVICE_PATH_PROTOCOL            *DevicePath;
+  EFI_DEVICE_PATH_PROTOCOL            *TempDevicePath;
+  EFI_STATUS                          Status;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *Database;
+  UINT8                               *DevicePathPkg;
+  UINT8                               *CurrentDevicePath;
+  EFI_HANDLE                          DriverHandle;
+  EFI_HII_HANDLE                      HiiHandle;
+  EFI_HII_CONFIG_ACCESS_PROTOCOL      *ConfigAccess;
+  EFI_STRING                          AccessProgress;
+  EFI_STRING                          AccessResults;
+  EFI_STRING                          DefaultResults;
+  BOOLEAN                             FirstElement;
+  BOOLEAN                             IfrDataParsedFlag;
+  BOOLEAN                             IsEfiVarStore;
+  EFI_IFR_VARSTORE_EFI                *EfiVarStoreInfo; 
+
+  if (This == NULL || Progress == NULL || Results == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (Request == NULL) {
+    *Progress = NULL;
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private   = CONFIG_ROUTING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  StringPtr = Request;
+  *Progress = StringPtr;
+  DefaultResults = NULL;
+  ConfigRequest  = NULL;
+  Status         = EFI_SUCCESS;
+  AccessResults  = NULL;
+  AccessProgress = NULL;
+  DevicePath     = NULL;
+  IfrDataParsedFlag = FALSE;
+  IsEfiVarStore     = FALSE;
+  EfiVarStoreInfo   = NULL;
+
+  //
+  // The first element of <MultiConfigRequest> should be
+  // <GuidHdr>, which is in 'GUID='<Guid> syntax.
+  //
+  if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  FirstElement = TRUE;
+
+  //
+  // Allocate a fix length of memory to store Results. Reallocate memory for
+  // Results if this fix length is insufficient.
+  //
+  *Results = (EFI_STRING) AllocateZeroPool (MAX_STRING_LENGTH);
+  if (*Results == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  while (*StringPtr != 0 && StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) == 0) {
+    //
+    // If parsing error, set Progress to the beginning of the <MultiConfigRequest>
+    // or most recent & before the error.
+    //
+    if (StringPtr == Request) {
+      *Progress = StringPtr;
+    } else {
+      *Progress = StringPtr - 1;
+    }
+
+    //
+    // Process each <ConfigRequest> of <MultiConfigRequest>
+    //
+    Length = CalculateConfigStringLen (StringPtr);
+    ConfigRequest = AllocateCopyPool ((Length + 1) * sizeof (CHAR16), StringPtr);
+    if (ConfigRequest == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+    *(ConfigRequest + Length) = 0;
+
+    //
+    // Get the UEFI device path
+    //
+    Status = GetDevicePath (ConfigRequest, (UINT8 **) &DevicePath);
+    if (EFI_ERROR (Status)) {
+      goto Done;
+    }
+
+    //
+    // Find driver which matches the routing data.
+    //
+    DriverHandle     = NULL;
+    HiiHandle        = NULL;
+    Database         = NULL;
+    for (Link = Private->DatabaseList.ForwardLink;
+         Link != &Private->DatabaseList;
+         Link = Link->ForwardLink
+        ) {
+      Database = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+      if ((DevicePathPkg = Database->PackageList->DevicePathPkg) != NULL) {
+        CurrentDevicePath = DevicePathPkg + sizeof (EFI_HII_PACKAGE_HEADER);
+        if (CompareMem (
+              DevicePath,
+              CurrentDevicePath,
+              GetDevicePathSize ((EFI_DEVICE_PATH_PROTOCOL *) CurrentDevicePath)
+              ) == 0) {
+          DriverHandle = Database->DriverHandle;
+          HiiHandle    = Database->Handle;
+          break;
+        }
+      }
+    }
+    
+    //
+    // Try to find driver handle by device path.
+    //
+    if (DriverHandle == NULL) {
+      TempDevicePath = DevicePath;
+      Status = gBS->LocateDevicePath (
+                      &gEfiDevicePathProtocolGuid,
+                      &TempDevicePath,
+                      &DriverHandle
+                      );
+      if (EFI_ERROR (Status) || (DriverHandle == NULL)) {
+        //
+        // Routing data does not match any known driver.
+        // Set Progress to the 'G' in "GUID" of the routing header.
+        //
+        *Progress = StringPtr;
+        Status = EFI_NOT_FOUND;
+        goto Done;
+      }
+    }
+    
+    //
+    // Check whether ConfigRequest contains request string OFFSET/WIDTH
+    //
+    IfrDataParsedFlag = FALSE;
+    if ((HiiHandle != NULL) && (StrStr (ConfigRequest, L"&OFFSET=") == NULL)) {
+      //
+      // Get the full request string from IFR when HiiPackage is registered to HiiHandle 
+      //
+      IfrDataParsedFlag = TRUE;
+      Status = GetFullStringFromHiiFormPackages (Database, DevicePath, &ConfigRequest, &DefaultResults, &AccessProgress);
+      if (EFI_ERROR (Status)) {
+        //
+        // AccessProgress indicates the parsing progress on <ConfigRequest>.
+        // Map it to the progress on <MultiConfigRequest> then return it.
+        //
+        *Progress = StrStr (StringPtr, AccessProgress);
+        goto Done;
+      }
+      //
+      // Not any request block is found.
+      //
+      if (StrStr (ConfigRequest, L"&OFFSET=") == NULL) {
+        AccessResults = AllocateCopyPool (StrSize (ConfigRequest), ConfigRequest);
+        goto NextConfigString;
+      }
+    }
+
+    //
+    // Check whether this ConfigRequest is search from Efi varstore type storage.
+    //
+    Status = GetVarStoreType(Database, ConfigRequest, &IsEfiVarStore, &EfiVarStoreInfo);
+    if (EFI_ERROR (Status)) {
+      goto Done;
+    }
+    
+    if (IsEfiVarStore) {
+      //
+      // Call the GetVariable function to extract settings.
+      //
+      Status = GetConfigRespFromEfiVarStore(This, EfiVarStoreInfo, ConfigRequest, &AccessResults, &AccessProgress);
+      FreePool (EfiVarStoreInfo);    
+    } else {
+      //
+      // Call corresponding ConfigAccess protocol to extract settings
+      //
+      Status = gBS->HandleProtocol (
+                      DriverHandle,
+                      &gEfiHiiConfigAccessProtocolGuid,
+                      (VOID **) &ConfigAccess
+                      );
+      ASSERT_EFI_ERROR (Status);
+
+      Status = ConfigAccess->ExtractConfig (
+                               ConfigAccess,
+                               ConfigRequest,
+                               &AccessProgress,
+                               &AccessResults
+                               );
+    }
+    if (EFI_ERROR (Status)) {
+      //
+      // AccessProgress indicates the parsing progress on <ConfigRequest>.
+      // Map it to the progress on <MultiConfigRequest> then return it.
+      //
+      *Progress = StrStr (StringPtr, AccessProgress);
+      goto Done;
+    }
+
+    //
+    // Attach this <ConfigAltResp> to a <MultiConfigAltResp>. There is a '&'
+    // which seperates the first <ConfigAltResp> and the following ones.
+    //
+    ASSERT (*AccessProgress == 0);
+
+    //
+    // Update AccessResults by getting default setting from IFR when HiiPackage is registered to HiiHandle 
+    //
+    if (!IfrDataParsedFlag && HiiHandle != NULL) {
+      Status = GetFullStringFromHiiFormPackages (Database, DevicePath, &ConfigRequest, &DefaultResults, NULL);
+      ASSERT_EFI_ERROR (Status);
+    }
+
+    FreePool (DevicePath);
+    DevicePath = NULL;
+
+    if (DefaultResults != NULL) {
+      Status = MergeDefaultString (&AccessResults, DefaultResults);
+      ASSERT_EFI_ERROR (Status);
+      FreePool (DefaultResults);
+      DefaultResults = NULL;
+    }
+    
+NextConfigString:   
+    if (!FirstElement) {
+      Status = AppendToMultiString (Results, L"&");
+      ASSERT_EFI_ERROR (Status);
+    }
+    
+    Status = AppendToMultiString (Results, AccessResults);
+    ASSERT_EFI_ERROR (Status);
+
+    FirstElement = FALSE;
+
+    FreePool (AccessResults);
+    AccessResults = NULL;
+    FreePool (ConfigRequest);
+    ConfigRequest = NULL;
+
+    //
+    // Go to next <ConfigRequest> (skip '&').
+    //
+    StringPtr += Length;
+    if (*StringPtr == 0) {
+      *Progress = StringPtr;
+      break;
+    }
+
+    StringPtr++;
+  }
+
+Done:
+  if (EFI_ERROR (Status)) {
+    FreePool (*Results);
+    *Results = NULL;
+  }
+  
+  if (ConfigRequest != NULL) {
+    FreePool (ConfigRequest);
+  }
+  
+  if (AccessResults != NULL) {
+    FreePool (AccessResults);
+  }
+  
+  if (DefaultResults != NULL) {
+    FreePool (DefaultResults);
+  }
+  
+  if (DevicePath != NULL) {
+    FreePool (DevicePath);
+  }  
+
+  return Status;
+}
+
+
+/**
+  This function allows the caller to request the current configuration for the
+  entirety of the current HII database and returns the data in a
+  null-terminated Unicode string.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  Results                Null-terminated Unicode string in
+                                 <MultiConfigAltResp> format which has all values
+                                 filled in for the names in the Request string.
+                                 String to be allocated by the  called function.
+                                 De-allocation is up to the caller.
+
+  @retval EFI_SUCCESS            The Results string is filled with the values
+                                 corresponding to all requested names.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to store the parts of the
+                                 results that must be stored awaiting possible
+                                 future        protocols.
+  @retval EFI_INVALID_PARAMETER  For example, passing in a NULL for the Results
+                                 parameter would result in this type of error.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigRoutingExportConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  OUT EFI_STRING                             *Results
+  )
+{
+  EFI_STATUS                          Status;
+  EFI_HII_CONFIG_ACCESS_PROTOCOL      *ConfigAccess;
+  EFI_STRING                          AccessResults;
+  EFI_STRING                          Progress;
+  EFI_STRING                          StringPtr;
+  EFI_STRING                          ConfigRequest;
+  UINTN                               Index;
+  EFI_HANDLE                          *ConfigAccessHandles;
+  UINTN                               NumberConfigAccessHandles;
+  BOOLEAN                             FirstElement;
+  EFI_DEVICE_PATH_PROTOCOL            *DevicePath;
+  EFI_HII_HANDLE                      HiiHandle;
+  EFI_STRING                          DefaultResults;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *Database;
+  UINT8                               *DevicePathPkg;
+  UINT8                               *CurrentDevicePath;
+  BOOLEAN                             IfrDataParsedFlag;
+
+  if (This == NULL || Results == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = CONFIG_ROUTING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Allocate a fix length of memory to store Results. Reallocate memory for
+  // Results if this fix length is insufficient.
+  //
+  *Results = (EFI_STRING) AllocateZeroPool (MAX_STRING_LENGTH);
+  if (*Results == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  NumberConfigAccessHandles = 0;
+  Status = gBS->LocateHandleBuffer (
+             ByProtocol,
+             &gEfiHiiConfigAccessProtocolGuid,
+             NULL,
+             &NumberConfigAccessHandles,
+             &ConfigAccessHandles
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  FirstElement = TRUE;
+
+  for (Index = 0; Index < NumberConfigAccessHandles; Index++) {
+    Status = gBS->HandleProtocol (
+                    ConfigAccessHandles[Index],
+                    &gEfiHiiConfigAccessProtocolGuid,
+                    (VOID **) &ConfigAccess
+                    );
+    if (EFI_ERROR (Status)) {
+      continue;
+    }
+
+    //
+    // Get DevicePath and HiiHandle for this ConfigAccess driver handle
+    //
+    IfrDataParsedFlag = FALSE;
+    Progress         = NULL;
+    HiiHandle        = NULL;
+    DefaultResults   = NULL;
+    Database         = NULL;
+    ConfigRequest    = NULL;
+    DevicePath       = DevicePathFromHandle (ConfigAccessHandles[Index]);
+    if (DevicePath != NULL) {
+      for (Link = Private->DatabaseList.ForwardLink;
+           Link != &Private->DatabaseList;
+           Link = Link->ForwardLink
+          ) {
+        Database = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+        if ((DevicePathPkg = Database->PackageList->DevicePathPkg) != NULL) {
+          CurrentDevicePath = DevicePathPkg + sizeof (EFI_HII_PACKAGE_HEADER);
+          if (CompareMem (
+                DevicePath,
+                CurrentDevicePath,
+                GetDevicePathSize ((EFI_DEVICE_PATH_PROTOCOL *) CurrentDevicePath)
+                ) == 0) {
+            HiiHandle = Database->Handle;
+            break;
+          }
+        }
+      }
+    }
+
+    Status = ConfigAccess->ExtractConfig (
+                             ConfigAccess,
+                             NULL,
+                             &Progress,
+                             &AccessResults
+                             );
+    if (EFI_ERROR (Status)) {
+      //
+      // Update AccessResults by getting default setting from IFR when HiiPackage is registered to HiiHandle 
+      //
+      if (HiiHandle != NULL && DevicePath != NULL) {
+        IfrDataParsedFlag = TRUE;
+        Status = GetFullStringFromHiiFormPackages (Database, DevicePath, &ConfigRequest, &DefaultResults, NULL);
+        //
+        // Get the full request string to get the Current setting again.
+        //
+        if (!EFI_ERROR (Status) && ConfigRequest != NULL) {
+          Status = ConfigAccess->ExtractConfig (
+                                   ConfigAccess,
+                                   ConfigRequest,
+                                   &Progress,
+                                   &AccessResults
+                                   );
+          FreePool (ConfigRequest);
+        } else {
+          Status = EFI_NOT_FOUND;
+        }
+      }
+    }
+
+    if (!EFI_ERROR (Status)) {
+      //
+      // Update AccessResults by getting default setting from IFR when HiiPackage is registered to HiiHandle 
+      //
+      if (!IfrDataParsedFlag && HiiHandle != NULL && DevicePath != NULL) {
+        StringPtr = StrStr (AccessResults, L"&GUID=");
+        if (StringPtr != NULL) {
+          *StringPtr = 0;
+        }
+        if (StrStr (AccessResults, L"&OFFSET=") != NULL) {
+          Status = GetFullStringFromHiiFormPackages (Database, DevicePath, &AccessResults, &DefaultResults, NULL);
+          ASSERT_EFI_ERROR (Status);
+        }
+        if (StringPtr != NULL) {
+          *StringPtr = L'&';
+        }
+      }
+      //
+      // Merge the default sting from IFR code into the got setting from driver.
+      //
+      if (DefaultResults != NULL) {
+        Status = MergeDefaultString (&AccessResults, DefaultResults);
+        ASSERT_EFI_ERROR (Status);
+        FreePool (DefaultResults);
+        DefaultResults = NULL;
+      }
+      
+      //
+      // Attach this <ConfigAltResp> to a <MultiConfigAltResp>. There is a '&'
+      // which seperates the first <ConfigAltResp> and the following ones.      
+      //
+      if (!FirstElement) {
+        Status = AppendToMultiString (Results, L"&");
+        ASSERT_EFI_ERROR (Status);
+      }
+      
+      Status = AppendToMultiString (Results, AccessResults);
+      ASSERT_EFI_ERROR (Status);
+
+      FirstElement = FALSE;
+      
+      FreePool (AccessResults);
+      AccessResults = NULL;
+    }
+  }
+  FreePool (ConfigAccessHandles);
+
+  return EFI_SUCCESS;  
+}
+
+
+/**
+  This function processes the results of processing forms and routes it to the
+  appropriate handlers or storage.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  Configuration          A null-terminated Unicode string in
+                                 <MulltiConfigResp> format.
+  @param  Progress               A pointer to a string filled in with the offset of
+                                 the most recent & before the first failing name /
+                                 value pair (or the beginning of the string if the
+                                 failure is in the first name / value pair) or the
+                                 terminating NULL if all was successful.
+
+  @retval EFI_SUCCESS            The results have been distributed or are awaiting
+                                 distribution.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to store the parts of the
+                                 results that must be stored awaiting possible
+                                 future        protocols.
+  @retval EFI_INVALID_PARAMETER  Passing in a NULL for the Configuration parameter
+                                 would result in this type of error.
+  @retval EFI_NOT_FOUND          Target for the specified routing data was not
+                                 found.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigRoutingRouteConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  CONST EFI_STRING                       Configuration,
+  OUT EFI_STRING                             *Progress
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  EFI_STRING                          StringPtr;
+  EFI_STRING                          ConfigResp;
+  UINTN                               Length;
+  EFI_STATUS                          Status;
+  EFI_DEVICE_PATH_PROTOCOL            *DevicePath;
+  EFI_DEVICE_PATH_PROTOCOL            *TempDevicePath;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *Database;
+  UINT8                               *DevicePathPkg;
+  UINT8                               *CurrentDevicePath;
+  EFI_HANDLE                          DriverHandle;
+  EFI_HII_CONFIG_ACCESS_PROTOCOL      *ConfigAccess;
+  EFI_STRING                          AccessProgress;
+  EFI_IFR_VARSTORE_EFI                *EfiVarStoreInfo;
+  BOOLEAN                             IsEfiVarstore;
+
+  if (This == NULL || Progress == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (Configuration == NULL) {
+    *Progress = NULL;
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private   = CONFIG_ROUTING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  StringPtr = Configuration;
+  *Progress = StringPtr;
+  Database       = NULL;
+  AccessProgress = NULL;
+  EfiVarStoreInfo= NULL;
+  IsEfiVarstore  = FALSE;
+
+  //
+  // The first element of <MultiConfigResp> should be
+  // <GuidHdr>, which is in 'GUID='<Guid> syntax.
+  //
+  if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  while (*StringPtr != 0 && StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) == 0) {
+    //
+    // If parsing error, set Progress to the beginning of the <MultiConfigResp>
+    // or most recent & before the error.
+    //
+    if (StringPtr == Configuration) {
+      *Progress = StringPtr;
+    } else {
+      *Progress = StringPtr - 1;
+    }
+
+    //
+    // Process each <ConfigResp> of <MultiConfigResp>
+    //
+    Length = CalculateConfigStringLen (StringPtr);
+    ConfigResp = AllocateCopyPool ((Length + 1) * sizeof (CHAR16), StringPtr);
+    if (ConfigResp == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    //
+    // Append '\0' to the end of ConfigRequest
+    //
+    *(ConfigResp + Length) = 0;
+
+    //
+    // Get the UEFI device path
+    //
+    Status = GetDevicePath (ConfigResp, (UINT8 **) &DevicePath);
+    if (EFI_ERROR (Status)) {
+      FreePool (ConfigResp);
+      return Status;
+    }
+
+    //
+    // Find driver which matches the routing data.
+    //
+    DriverHandle     = NULL;
+    for (Link = Private->DatabaseList.ForwardLink;
+         Link != &Private->DatabaseList;
+         Link = Link->ForwardLink
+        ) {
+      Database = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+
+      if ((DevicePathPkg = Database->PackageList->DevicePathPkg) != NULL) {
+        CurrentDevicePath = DevicePathPkg + sizeof (EFI_HII_PACKAGE_HEADER);
+        if (CompareMem (
+              DevicePath,
+              CurrentDevicePath,
+              GetDevicePathSize ((EFI_DEVICE_PATH_PROTOCOL *) CurrentDevicePath)
+              ) == 0) {
+          DriverHandle = Database->DriverHandle;
+          break;
+        }
+      }
+    }
+
+    //
+    // Try to find driver handle by device path.
+    //
+    if (DriverHandle == NULL) {
+      TempDevicePath = DevicePath;
+      Status = gBS->LocateDevicePath (
+                      &gEfiDevicePathProtocolGuid,
+                      &TempDevicePath,
+                      &DriverHandle
+                      );
+      if (EFI_ERROR (Status) || (DriverHandle == NULL)) {
+        //
+        // Routing data does not match any known driver.
+        // Set Progress to the 'G' in "GUID" of the routing header.
+        //
+        FreePool (DevicePath);
+        *Progress = StringPtr;
+        FreePool (ConfigResp);
+        return EFI_NOT_FOUND;
+      }
+    }
+
+    FreePool (DevicePath);
+
+    //
+    // Check whether this ConfigRequest is search from Efi varstore type storage.
+    //
+    Status = GetVarStoreType(Database, ConfigResp, &IsEfiVarstore, &EfiVarStoreInfo);
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    if (IsEfiVarstore) {
+      //
+      // Call the SetVariable function to route settings.
+      //    
+      Status = RouteConfigRespForEfiVarStore(This, EfiVarStoreInfo, ConfigResp, &AccessProgress);
+      FreePool (EfiVarStoreInfo);
+    } else {
+      //
+      // Call corresponding ConfigAccess protocol to route settings
+      //
+      Status = gBS->HandleProtocol (
+                      DriverHandle,
+                      &gEfiHiiConfigAccessProtocolGuid,
+                      (VOID **)  &ConfigAccess
+                      );
+      ASSERT_EFI_ERROR (Status);
+
+      Status = ConfigAccess->RouteConfig (
+                               ConfigAccess,
+                               ConfigResp,
+                               &AccessProgress
+                               );
+    }
+    if (EFI_ERROR (Status)) {
+      //
+      // AccessProgress indicates the parsing progress on <ConfigResp>.
+      // Map it to the progress on <MultiConfigResp> then return it.
+      //
+      *Progress = StrStr (StringPtr, AccessProgress);
+
+      FreePool (ConfigResp);
+      return Status;
+    }
+
+    FreePool (ConfigResp);
+    ConfigResp = NULL;
+
+    //
+    // Go to next <ConfigResp> (skip '&').
+    //
+    StringPtr += Length;
+    if (*StringPtr == 0) {
+      *Progress = StringPtr;
+      break;
+    }
+
+    StringPtr++;
+
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This helper function is to be called by drivers to map configuration data
+  stored in byte array ("block") formats such as UEFI Variables into current
+  configuration strings.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  ConfigRequest          A null-terminated Unicode string in
+                                 <ConfigRequest> format.
+  @param  Block                  Array of bytes defining the block's configuration.
+  @param  BlockSize              Length in bytes of Block.
+  @param  Config                 Filled-in configuration string. String allocated
+                                 by  the function. Returned only if call is
+                                 successful. It is <ConfigResp> string format.
+  @param  Progress               A pointer to a string filled in with the offset of
+                                  the most recent & before the first failing
+                                 name/value pair (or the beginning of the string if
+                                 the failure is in the first name / value pair) or
+                                 the terminating NULL if all was successful.
+
+  @retval EFI_SUCCESS            The request succeeded. Progress points to the null
+                                 terminator at the end of the ConfigRequest
+                                 string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to allocate Config.     Progress
+                                 points to the first character of ConfigRequest.
+  @retval EFI_INVALID_PARAMETER  Passing in a NULL for the ConfigRequest or
+                                 Block parameter would result in this type of
+                                 error. Progress points to the first character of
+                                 ConfigRequest.
+  @retval EFI_DEVICE_ERROR       Block not large enough. Progress undefined.
+  @retval EFI_INVALID_PARAMETER  Encountered non <BlockName> formatted string.
+                                     Block is left updated and Progress points at
+                                 the "&" preceding the first non-<BlockName>.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiBlockToConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  CONST EFI_STRING                       ConfigRequest,
+  IN  CONST UINT8                            *Block,
+  IN  CONST UINTN                            BlockSize,
+  OUT EFI_STRING                             *Config,
+  OUT EFI_STRING                             *Progress
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  EFI_STRING                          StringPtr;
+  UINTN                               Length;
+  EFI_STATUS                          Status;
+  EFI_STRING                          TmpPtr;
+  UINT8                               *TmpBuffer;
+  UINTN                               Offset;
+  UINTN                               Width;
+  UINT8                               *Value;
+  EFI_STRING                          ValueStr;
+  EFI_STRING                          ConfigElement;
+  UINTN                               Index;
+  UINT8                               *TemBuffer;
+  CHAR16                              *TemString;
+  CHAR16                              TemChar;
+
+  if (This == NULL || Progress == NULL || Config == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (Block == NULL || ConfigRequest == NULL) {
+    *Progress = ConfigRequest;
+    return EFI_INVALID_PARAMETER;
+  }
+
+
+  Private = CONFIG_ROUTING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  ASSERT (Private != NULL);
+
+  StringPtr     = ConfigRequest;
+  ValueStr      = NULL;
+  Value         = NULL;
+  ConfigElement = NULL;
+
+  //
+  // Allocate a fix length of memory to store Results. Reallocate memory for
+  // Results if this fix length is insufficient.
+  //
+  *Config = (EFI_STRING) AllocateZeroPool (MAX_STRING_LENGTH);
+  if (*Config == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // Jump <ConfigHdr>
+  //
+  if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+    *Progress = StringPtr;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+  while (*StringPtr != 0 && StrnCmp (StringPtr, L"PATH=", StrLen (L"PATH=")) != 0) {
+    StringPtr++;
+  }
+  if (*StringPtr == 0) {
+    *Progress = StringPtr - 1;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+
+  while (*StringPtr != L'&' && *StringPtr != 0) {
+    StringPtr++;
+  }
+  if (*StringPtr == 0) {
+    *Progress = StringPtr;
+    Status = EFI_SUCCESS;
+
+    AppendToMultiString(Config, ConfigRequest);
+    IntHiiToLower (*Config);
+
+    goto Exit;
+  }
+  //
+  // Skip '&'
+  //
+  StringPtr++;
+
+  //
+  // Copy <ConfigHdr> and an additional '&' to <ConfigResp>
+  //
+  TemChar = *StringPtr;
+  *StringPtr = '\0';
+  AppendToMultiString(Config, ConfigRequest);
+  *StringPtr = TemChar;
+
+  //
+  // Parse each <RequestElement> if exists
+  // Only <BlockName> format is supported by this help function.
+  // <BlockName> ::= 'OFFSET='<Number>&'WIDTH='<Number>
+  //
+  while (*StringPtr != 0 && StrnCmp (StringPtr, L"OFFSET=", StrLen (L"OFFSET=")) == 0) {
+    //
+    // Back up the header of one <BlockName>
+    //
+    TmpPtr = StringPtr;
+
+    StringPtr += StrLen (L"OFFSET=");
+    //
+    // Get Offset
+    //
+    Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+    if (EFI_ERROR (Status)) {
+      *Progress = ConfigRequest;
+      goto Exit;
+    }
+    Offset = 0;
+    CopyMem (
+      &Offset,
+      TmpBuffer,
+      (((Length + 1) / 2) < sizeof (UINTN)) ? ((Length + 1) / 2) : sizeof (UINTN)
+      );
+    FreePool (TmpBuffer);
+
+    StringPtr += Length;
+    if (StrnCmp (StringPtr, L"&WIDTH=", StrLen (L"&WIDTH=")) != 0) {
+      *Progress = StringPtr - Length - StrLen (L"OFFSET=") - 1;
+      Status = EFI_INVALID_PARAMETER;
+      goto Exit;
+    }
+    StringPtr += StrLen (L"&WIDTH=");
+
+    //
+    // Get Width
+    //
+    Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+    if (EFI_ERROR (Status)) {
+      *Progress = ConfigRequest;
+      goto Exit;
+    }
+    Width = 0;
+    CopyMem (
+      &Width,
+      TmpBuffer,
+      (((Length + 1) / 2) < sizeof (UINTN)) ? ((Length + 1) / 2) : sizeof (UINTN)
+      );
+    FreePool (TmpBuffer);
+
+    StringPtr += Length;
+    if (*StringPtr != 0 && *StringPtr != L'&') {
+      *Progress = StringPtr - Length - StrLen (L"&WIDTH=");
+      Status = EFI_INVALID_PARAMETER;
+      goto Exit;
+    }
+
+    //
+    // Calculate Value and convert it to hex string.
+    //
+    if (Offset + Width > BlockSize) {
+      *Progress = StringPtr;
+      Status = EFI_DEVICE_ERROR;
+      goto Exit;
+    }
+
+    Value = (UINT8 *) AllocateZeroPool (Width);
+    if (Value == NULL) {
+      *Progress = ConfigRequest;
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+
+    CopyMem (Value, (UINT8 *) Block + Offset, Width);
+
+    Length = Width * 2 + 1;
+    ValueStr = (EFI_STRING) AllocateZeroPool (Length  * sizeof (CHAR16));
+    if (ValueStr == NULL) {
+      *Progress = ConfigRequest;
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+    
+    TemString = ValueStr;
+    TemBuffer = Value + Width - 1;
+    for (Index = 0; Index < Width; Index ++, TemBuffer --) {
+      TemString += UnicodeValueToString (TemString, PREFIX_ZERO | RADIX_HEX, *TemBuffer, 2);
+    }
+
+    FreePool (Value);
+    Value = NULL;
+
+    //
+    // Build a ConfigElement
+    //
+    Length += StringPtr - TmpPtr + 1 + StrLen (L"VALUE=");
+    ConfigElement = (EFI_STRING) AllocateZeroPool (Length * sizeof (CHAR16));
+    if (ConfigElement == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+    CopyMem (ConfigElement, TmpPtr, (StringPtr - TmpPtr + 1) * sizeof (CHAR16));
+    if (*StringPtr == 0) {
+      *(ConfigElement + (StringPtr - TmpPtr)) = L'&';
+    }
+    *(ConfigElement + (StringPtr - TmpPtr) + 1) = 0;
+    StrCat (ConfigElement, L"VALUE=");
+    StrCat (ConfigElement, ValueStr);
+
+    AppendToMultiString (Config, ConfigElement);
+
+    FreePool (ConfigElement);
+    FreePool (ValueStr);
+    ConfigElement = NULL;
+    ValueStr = NULL;
+
+    //
+    // If '\0', parsing is finished. Otherwise skip '&' to continue
+    //
+    if (*StringPtr == 0) {
+      break;
+    }
+    AppendToMultiString (Config, L"&");
+    StringPtr++;
+
+  }
+
+  if (*StringPtr != 0) {
+    *Progress = StringPtr - 1;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+  
+  IntHiiToLower (*Config);
+  *Progress = StringPtr;
+  return EFI_SUCCESS;
+
+Exit:
+  if (*Config != NULL) {
+  FreePool (*Config);
+  *Config = NULL;
+  }
+  if (ValueStr != NULL) {
+    FreePool (ValueStr);
+  }
+  if (Value != NULL) {
+    FreePool (Value);
+  }
+  if (ConfigElement != NULL) {
+    FreePool (ConfigElement);
+  }
+
+  return Status;
+
+}
+
+
+/**
+  This helper function is to be called by drivers to map configuration strings
+  to configurations stored in byte array ("block") formats such as UEFI Variables.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  ConfigResp             A null-terminated Unicode string in <ConfigResp>
+                                 format.
+  @param  Block                  A possibly null array of bytes representing the
+                                 current  block. Only bytes referenced in the
+                                 ConfigResp string  in the block are modified. If
+                                 this parameter is null or if the *BlockSize
+                                 parameter is (on input) shorter than required by
+                                 the Configuration string, only the BlockSize
+                                 parameter is updated and an appropriate status
+                                 (see below)  is returned.
+  @param  BlockSize              The length of the Block in units of UINT8.  On
+                                 input, this is the size of the Block. On output,
+                                 if successful, contains the index of the  last
+                                 modified byte in the Block.
+  @param  Progress               On return, points to an element of the ConfigResp
+                                 string filled in with the offset of the most
+                                 recent '&' before the first failing name / value
+                                 pair (or  the beginning of the string if the
+                                 failure is in the  first name / value pair) or the
+                                 terminating NULL if all was successful.
+
+  @retval EFI_SUCCESS            The request succeeded. Progress points to the null
+                                 terminator at the end of the ConfigResp string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to allocate Config.     Progress
+                                 points to the first character of ConfigResp.
+  @retval EFI_INVALID_PARAMETER  Passing in a NULL for the ConfigResp or
+                                 Block parameter would result in this type of
+                                 error. Progress points to the first character of
+                                         ConfigResp.
+  @retval EFI_INVALID_PARAMETER  Encountered non <BlockName> formatted name /
+                                 value pair. Block is left updated and
+                                 Progress points at the '&' preceding the first
+                                 non-<BlockName>.
+  @retval EFI_DEVICE_ERROR       Block not large enough. Progress undefined.
+  @retval EFI_NOT_FOUND          Target for the specified routing data was not found.
+                                 Progress points to the "G" in "GUID" of the errant
+                                 routing data.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigToBlock (
+  IN     CONST EFI_HII_CONFIG_ROUTING_PROTOCOL *This,
+  IN     CONST EFI_STRING                      ConfigResp,
+  IN OUT UINT8                                 *Block,
+  IN OUT UINTN                                 *BlockSize,
+  OUT    EFI_STRING                            *Progress
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  EFI_STRING                          StringPtr;
+  UINTN                               Length;
+  EFI_STATUS                          Status;
+  UINT8                               *TmpBuffer;
+  UINTN                               Offset;
+  UINTN                               Width;
+  UINT8                               *Value;
+  UINTN                               BufferSize;
+  UINTN                               MaxBlockSize;
+
+  if (This == NULL || BlockSize == NULL || Progress == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *Progress = ConfigResp;
+  if (ConfigResp == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = CONFIG_ROUTING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  ASSERT (Private != NULL);
+
+  StringPtr  = ConfigResp;
+  BufferSize = *BlockSize;
+  Value      = NULL;
+  MaxBlockSize = 0;
+
+  //
+  // Jump <ConfigHdr>
+  //
+  if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+    *Progress = StringPtr;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+  while (*StringPtr != 0 && StrnCmp (StringPtr, L"PATH=", StrLen (L"PATH=")) != 0) {
+    StringPtr++;
+  }
+  if (*StringPtr == 0) {
+    *Progress = StringPtr;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+
+  while (*StringPtr != L'&' && *StringPtr != 0) {
+    StringPtr++;
+  }
+  if (*StringPtr == 0) {
+    *Progress = StringPtr;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+  //
+  // Skip '&'
+  //
+  StringPtr++;
+
+  //
+  // Parse each <ConfigElement> if exists
+  // Only <BlockConfig> format is supported by this help function.
+  // <BlockConfig> ::= 'OFFSET='<Number>&'WIDTH='<Number>&'VALUE='<Number>
+  //
+  while (*StringPtr != 0 && StrnCmp (StringPtr, L"OFFSET=", StrLen (L"OFFSET=")) == 0) {
+    StringPtr += StrLen (L"OFFSET=");
+    //
+    // Get Offset
+    //
+    Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+    if (EFI_ERROR (Status)) {
+      *Progress = ConfigResp;
+      goto Exit;
+    }
+    Offset = 0;
+    CopyMem (
+      &Offset,
+      TmpBuffer,
+      (((Length + 1) / 2) < sizeof (UINTN)) ? ((Length + 1) / 2) : sizeof (UINTN)
+      );
+    FreePool (TmpBuffer);
+
+    StringPtr += Length;
+    if (StrnCmp (StringPtr, L"&WIDTH=", StrLen (L"&WIDTH=")) != 0) {
+      *Progress = StringPtr - Length - StrLen (L"OFFSET=") - 1;
+      Status = EFI_INVALID_PARAMETER;
+      goto Exit;
+    }
+    StringPtr += StrLen (L"&WIDTH=");
+
+    //
+    // Get Width
+    //
+    Status = GetValueOfNumber (StringPtr, &TmpBuffer, &Length);
+    if (EFI_ERROR (Status)) {
+      *Progress = ConfigResp;
+      goto Exit;
+    }
+    Width = 0;
+    CopyMem (
+      &Width,
+      TmpBuffer,
+      (((Length + 1) / 2) < sizeof (UINTN)) ? ((Length + 1) / 2) : sizeof (UINTN)
+      );
+    FreePool (TmpBuffer);
+
+    StringPtr += Length;
+    if (StrnCmp (StringPtr, L"&VALUE=", StrLen (L"&VALUE=")) != 0) {
+      *Progress = StringPtr - Length - StrLen (L"&WIDTH=");
+      Status = EFI_INVALID_PARAMETER;
+      goto Exit;
+    }
+    StringPtr += StrLen (L"&VALUE=");
+
+    //
+    // Get Value
+    //
+    Status = GetValueOfNumber (StringPtr, &Value, &Length);
+    if (EFI_ERROR (Status)) {
+      *Progress = ConfigResp;
+      goto Exit;
+    }
+
+    StringPtr += Length;
+    if (*StringPtr != 0 && *StringPtr != L'&') {
+      *Progress = StringPtr - Length - 7;
+      Status = EFI_INVALID_PARAMETER;
+      goto Exit;
+    }
+
+    //
+    // Update the Block with configuration info
+    //
+    if ((Block != NULL) && (Offset + Width <= BufferSize)) {
+      CopyMem (Block + Offset, Value, Width);
+    }
+    if (Offset + Width > MaxBlockSize) {
+      MaxBlockSize = Offset + Width;
+    }
+
+    FreePool (Value);
+    Value = NULL;
+
+    //
+    // If '\0', parsing is finished. Otherwise skip '&' to continue
+    //
+    if (*StringPtr == 0) {
+      break;
+    }
+
+    StringPtr++;
+  }
+  
+  //
+  // The input string is ConfigAltResp format.
+  //
+  if ((*StringPtr != 0) && (StrnCmp (StringPtr, L"&GUID=", StrLen (L"&GUID=")) != 0)) {
+    *Progress = StringPtr - 1;
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+
+  *Progress = StringPtr + StrLen (StringPtr);
+  *BlockSize = MaxBlockSize - 1;
+
+  if (MaxBlockSize > BufferSize) {
+    *BlockSize = MaxBlockSize;
+    if (Block != NULL) {
+      return EFI_DEVICE_ERROR;
+    }
+  }
+
+  if (Block == NULL) {
+    *Progress = ConfigResp;
+    return EFI_INVALID_PARAMETER;
+  }
+
+  return EFI_SUCCESS;
+
+Exit:
+
+  if (Value != NULL) {
+    FreePool (Value);
+  }
+  return Status;
+}
+
+
+/**
+  This helper function is to be called by drivers to extract portions of
+  a larger configuration string.
+
+  @param  This                   A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                 instance.
+  @param  Configuration          A null-terminated Unicode string in
+                                 <MultiConfigAltResp> format.
+  @param  Guid                   A pointer to the GUID value to search for in the
+                                 routing portion of the ConfigResp string when
+                                 retrieving  the requested data. If Guid is NULL,
+                                 then all GUID  values will be searched for.
+  @param  Name                   A pointer to the NAME value to search for in the
+                                 routing portion of the ConfigResp string when
+                                 retrieving  the requested data. If Name is NULL,
+                                 then all Name  values will be searched for.
+  @param  DevicePath             A pointer to the PATH value to search for in the
+                                 routing portion of the ConfigResp string when
+                                 retrieving  the requested data. If DevicePath is
+                                 NULL, then all  DevicePath values will be searched
+                                 for.
+  @param  AltCfgId               A pointer to the ALTCFG value to search for in the
+                                  routing portion of the ConfigResp string when
+                                 retrieving  the requested data.  If this parameter
+                                 is NULL,  then the current setting will be
+                                 retrieved.
+  @param  AltCfgResp             A pointer to a buffer which will be allocated by
+                                 the  function which contains the retrieved string
+                                 as requested.   This buffer is only allocated if
+                                 the call was successful. It is <ConfigResp> format.
+
+  @retval EFI_SUCCESS            The request succeeded. The requested data was
+                                 extracted  and placed in the newly allocated
+                                 AltCfgResp buffer.
+  @retval EFI_OUT_OF_RESOURCES   Not enough memory to allocate AltCfgResp.
+  @retval EFI_INVALID_PARAMETER  Any parameter is invalid.
+  @retval EFI_NOT_FOUND          Target for the specified routing data was not
+                                 found.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetAltCfg (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL    *This,
+  IN  CONST EFI_STRING                         Configuration,
+  IN  CONST EFI_GUID                           *Guid,
+  IN  CONST EFI_STRING                         Name,
+  IN  CONST EFI_DEVICE_PATH_PROTOCOL           *DevicePath,
+  IN  CONST UINT16                             *AltCfgId,
+  OUT EFI_STRING                               *AltCfgResp
+  )
+{
+  EFI_STATUS                          Status;
+  EFI_STRING                          StringPtr;
+  EFI_STRING                          HdrStart;
+  EFI_STRING                          HdrEnd;
+  EFI_STRING                          TmpPtr;
+  UINTN                               Length;
+  EFI_STRING                          GuidStr;
+  EFI_STRING                          NameStr;
+  EFI_STRING                          PathStr;
+  EFI_STRING                          AltIdStr;
+  EFI_STRING                          Result;
+  BOOLEAN                             GuidFlag;
+  BOOLEAN                             NameFlag;
+  BOOLEAN                             PathFlag;
+
+  HdrStart = NULL;
+  HdrEnd   = NULL;
+  GuidStr  = NULL;
+  NameStr  = NULL;
+  PathStr  = NULL;
+  AltIdStr = NULL;
+  Result   = NULL;
+  GuidFlag = FALSE;
+  NameFlag = FALSE;
+  PathFlag = FALSE;
+
+  if (This == NULL || Configuration == NULL || AltCfgResp == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  StringPtr = Configuration;
+  if (StrnCmp (StringPtr, L"GUID=", StrLen (L"GUID=")) != 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Generate the sub string for later matching.
+  //
+  GenerateSubStr (L"GUID=", sizeof (EFI_GUID), (VOID *) Guid, 1, &GuidStr);
+  GenerateSubStr (
+    L"PATH=",
+    GetDevicePathSize ((EFI_DEVICE_PATH_PROTOCOL *) DevicePath),
+    (VOID *) DevicePath,
+    1,
+    &PathStr
+    );
+  if (AltCfgId != NULL) {
+    GenerateSubStr (L"ALTCFG=", sizeof (UINT16), (VOID *) AltCfgId, 3, &AltIdStr);  
+  }
+  if (Name != NULL) {
+    GenerateSubStr (L"NAME=", StrLen (Name) * sizeof (CHAR16), (VOID *) Name, 2, &NameStr);    
+  } else {
+    GenerateSubStr (L"NAME=", 0, NULL, 2, &NameStr);
+  }
+
+  while (*StringPtr != 0) {
+    //
+    // Try to match the GUID
+    //
+    if (!GuidFlag) {
+      TmpPtr = StrStr (StringPtr, GuidStr);
+      if (TmpPtr == NULL) {
+        Status = EFI_NOT_FOUND;
+        goto Exit;
+      }
+      HdrStart = TmpPtr;
+
+      //
+      // Jump to <NameHdr>
+      //
+      if (Guid != NULL) {
+        StringPtr = TmpPtr + StrLen (GuidStr);
+      } else {
+        StringPtr = StrStr (TmpPtr, L"NAME=");
+        if (StringPtr == NULL) {
+          Status = EFI_NOT_FOUND;
+          goto Exit;
+        }
+      }
+      GuidFlag = TRUE;
+    }
+
+    //
+    // Try to match the NAME
+    //
+    if (GuidFlag && !NameFlag) {
+      if (StrnCmp (StringPtr, NameStr, StrLen (NameStr)) != 0) {
+        GuidFlag = FALSE;
+      } else {
+        //
+        // Jump to <PathHdr>
+        //
+        if (Name != NULL) {
+          StringPtr += StrLen (NameStr);
+        } else {
+          StringPtr = StrStr (StringPtr, L"PATH=");
+          if (StringPtr == NULL) {
+            Status = EFI_NOT_FOUND;
+            goto Exit;
+          }
+        }
+        NameFlag = TRUE;
+      }
+    }
+
+    //
+    // Try to match the DevicePath
+    //
+    if (GuidFlag && NameFlag && !PathFlag) {
+      if (StrnCmp (StringPtr, PathStr, StrLen (PathStr)) != 0) {
+        GuidFlag = FALSE;
+        NameFlag = FALSE;
+      } else {
+        //
+        // Jump to '&' before <DescHdr> or <ConfigBody>
+        //
+        if (DevicePath != NULL) {
+          StringPtr += StrLen (PathStr);
+        } else {
+          StringPtr = StrStr (StringPtr, L"&");
+          if (StringPtr == NULL) {
+            Status = EFI_NOT_FOUND;
+            goto Exit;
+          }
+          StringPtr ++;
+        }
+        PathFlag = TRUE;
+        HdrEnd   = StringPtr;
+      }
+    }
+
+    //
+    // Try to match the AltCfgId
+    //
+    if (GuidFlag && NameFlag && PathFlag) {
+      if (AltCfgId == NULL) {
+        //
+        // Return Current Setting when AltCfgId is NULL.
+        //
+        Status = OutputConfigBody (StringPtr, &Result);
+        goto Exit;
+      }
+      //
+      // Search the <ConfigAltResp> to get the <AltResp> with AltCfgId.
+      //
+      if (StrnCmp (StringPtr, AltIdStr, StrLen (AltIdStr)) != 0) {
+        GuidFlag = FALSE;
+        NameFlag = FALSE;
+        PathFlag = FALSE;
+      } else {
+        //
+        // Skip AltIdStr and &
+        //
+        StringPtr = StringPtr + StrLen (AltIdStr);
+        Status    = OutputConfigBody (StringPtr, &Result);
+        goto Exit;
+      }
+    }
+  }
+
+  Status = EFI_NOT_FOUND;
+
+Exit:
+  *AltCfgResp = NULL;
+  if (!EFI_ERROR (Status) && (Result != NULL)) {
+    //
+    // Copy the <ConfigHdr> and <ConfigBody>
+    //
+    Length = HdrEnd - HdrStart + StrLen (Result) + 1;
+    *AltCfgResp = AllocateZeroPool (Length * sizeof (CHAR16));
+    if (*AltCfgResp == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+    } else {
+      StrnCpy (*AltCfgResp, HdrStart, HdrEnd - HdrStart);
+      StrCat (*AltCfgResp, Result);
+      Status = EFI_SUCCESS;
+    }
+  }
+
+  if (GuidStr != NULL) {
+    FreePool (GuidStr);
+  }
+  if (NameStr != NULL) {
+    FreePool (NameStr);
+  }
+  if (PathStr != NULL) {
+    FreePool (PathStr);
+  }
+  if (AltIdStr != NULL) {
+    FreePool (AltIdStr);
+  }
+  if (Result != NULL) {
+    FreePool (Result);
+  }
+
+  return Status;
+
+}
+
+
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Database.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Database.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Database.c	(working copy)
@@ -0,0 +1,3848 @@
+/** @file
+Implementation for EFI_HII_DATABASE_PROTOCOL.
+
+Copyright (c) 2007 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "HiiDatabase.h"
+
+/**
+  This function generates a HII_DATABASE_RECORD node and adds into hii database.
+  This is a internal function.
+
+  @param  Private                hii database private structure
+  @param  DatabaseNode           HII_DATABASE_RECORD node which is used to store a
+                                 package list
+
+  @retval EFI_SUCCESS            A database record is generated successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 database contents.
+  @retval EFI_INVALID_PARAMETER  Private is NULL or DatabaseRecord is NULL.
+
+**/
+EFI_STATUS
+GenerateHiiDatabaseRecord (
+  IN  HII_DATABASE_PRIVATE_DATA *Private,
+  OUT HII_DATABASE_RECORD       **DatabaseNode
+  )
+{
+  HII_DATABASE_RECORD                *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList;
+  HII_HANDLE                         *HiiHandle;
+
+  if (Private == NULL || DatabaseNode == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  DatabaseRecord = (HII_DATABASE_RECORD *) AllocateZeroPool (sizeof (HII_DATABASE_RECORD));
+  if (DatabaseRecord == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+  DatabaseRecord->Signature = HII_DATABASE_RECORD_SIGNATURE;
+
+  DatabaseRecord->PackageList = AllocateZeroPool (sizeof (HII_DATABASE_PACKAGE_LIST_INSTANCE));
+  if (DatabaseRecord->PackageList == NULL) {
+    FreePool (DatabaseRecord);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  PackageList = DatabaseRecord->PackageList;
+
+  InitializeListHead (&PackageList->GuidPkgHdr);
+  InitializeListHead (&PackageList->FormPkgHdr);
+  InitializeListHead (&PackageList->KeyboardLayoutHdr);
+  InitializeListHead (&PackageList->StringPkgHdr);
+  InitializeListHead (&PackageList->FontPkgHdr);
+  InitializeListHead (&PackageList->SimpleFontPkgHdr);
+  PackageList->ImagePkg      = NULL;
+  PackageList->DevicePathPkg = NULL;
+
+  //
+  // Create a new hii handle
+  //
+  HiiHandle = (HII_HANDLE *) AllocateZeroPool (sizeof (HII_HANDLE));
+  if (HiiHandle == NULL) {
+    FreePool (DatabaseRecord->PackageList);
+    FreePool (DatabaseRecord);
+    return EFI_OUT_OF_RESOURCES;
+  }
+  HiiHandle->Signature = HII_HANDLE_SIGNATURE;
+  //
+  // Backup the number of Hii handles
+  //
+  Private->HiiHandleCount++;
+  HiiHandle->Key = (UINTN) Private->HiiHandleCount;
+  //
+  // Insert the handle to hii handle list of the whole database.
+  //
+  InsertTailList (&Private->HiiHandleList, &HiiHandle->Handle);
+
+  DatabaseRecord->Handle = (EFI_HII_HANDLE) HiiHandle;
+
+  //
+  // Insert the Package List node to Package List link of the whole database.
+  //
+  InsertTailList (&Private->DatabaseList, &DatabaseRecord->DatabaseEntry);
+
+  *DatabaseNode = DatabaseRecord;
+
+  return EFI_SUCCESS;
+
+}
+
+
+/**
+  This function checks whether a handle is a valid EFI_HII_HANDLE
+  This is a internal function.
+
+  @param  Handle                 Pointer to a EFI_HII_HANDLE
+
+  @retval TRUE                   Valid
+  @retval FALSE                  Invalid
+
+**/
+BOOLEAN
+IsHiiHandleValid (
+  EFI_HII_HANDLE Handle
+  )
+{
+  HII_HANDLE    *HiiHandle;
+
+  HiiHandle = (HII_HANDLE *) Handle;
+
+  if (HiiHandle == NULL) {
+    return FALSE;
+  }
+
+  if (HiiHandle->Signature != HII_HANDLE_SIGNATURE) {
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+/**
+  This function invokes the matching registered function.
+  This is a internal function.
+
+  @param  Private                HII Database driver private structure.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageInstance        Points to the package referred to by the
+                                 notification.
+  @param  PackageType            Package type
+  @param  Handle                 The handle of the package list which contains the
+                                 specified package.
+
+  @retval EFI_SUCCESS            Already checked all registered function and
+                                 invoked  if matched.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+InvokeRegisteredFunction (
+  IN HII_DATABASE_PRIVATE_DATA    *Private,
+  IN EFI_HII_DATABASE_NOTIFY_TYPE NotifyType,
+  IN VOID                         *PackageInstance,
+  IN UINT8                        PackageType,
+  IN EFI_HII_HANDLE               Handle
+  )
+{
+  HII_DATABASE_NOTIFY             *Notify;
+  LIST_ENTRY                      *Link;
+  EFI_HII_PACKAGE_HEADER          *Package;
+  UINT8                           *Buffer;
+  UINT32                          BufferSize;
+  UINT32                          HeaderSize;
+  UINT32                          ImageBlockSize;
+  UINT32                          PaletteInfoSize;
+
+  if (Private == NULL || (NotifyType & 0xF) == 0 || PackageInstance == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (Private->Signature != HII_DATABASE_PRIVATE_DATA_SIGNATURE) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (!IsHiiHandleValid (Handle)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Buffer  = NULL;
+  Package = NULL;
+
+  //
+  // Convert the incoming package from hii database storage format to UEFI
+  // storage format. e.g. HII_GUID_PACKAGE_INSTANCE to EFI_HII_GUID_PACKAGE_HDR.
+  //
+  switch (PackageType) {
+  case EFI_HII_PACKAGE_TYPE_GUID:
+    Package = (EFI_HII_PACKAGE_HEADER *) (((HII_GUID_PACKAGE_INSTANCE *) PackageInstance)->GuidPkg);
+    break;
+
+  case EFI_HII_PACKAGE_FORMS:
+    BufferSize = ((HII_IFR_PACKAGE_INSTANCE *) PackageInstance)->FormPkgHdr.Length;
+    Buffer = (UINT8 *) AllocateZeroPool (BufferSize);
+    ASSERT (Buffer != NULL);
+    CopyMem (
+      Buffer,
+      &((HII_IFR_PACKAGE_INSTANCE *) PackageInstance)->FormPkgHdr,
+      sizeof (EFI_HII_PACKAGE_HEADER)
+      );
+    CopyMem (
+      Buffer + sizeof (EFI_HII_PACKAGE_HEADER),
+      ((HII_IFR_PACKAGE_INSTANCE *) PackageInstance)->IfrData,
+      BufferSize - sizeof (EFI_HII_PACKAGE_HEADER)
+      );
+    Package = (EFI_HII_PACKAGE_HEADER *) Buffer;
+    break;
+
+  case EFI_HII_PACKAGE_KEYBOARD_LAYOUT:
+    Package = (EFI_HII_PACKAGE_HEADER *) (((HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *) PackageInstance)->KeyboardPkg);
+    break;
+
+  case EFI_HII_PACKAGE_STRINGS:
+    BufferSize = ((HII_STRING_PACKAGE_INSTANCE *) PackageInstance)->StringPkgHdr->Header.Length;
+    HeaderSize = ((HII_STRING_PACKAGE_INSTANCE *) PackageInstance)->StringPkgHdr->HdrSize;
+    Buffer = (UINT8 *) AllocateZeroPool (BufferSize);
+    ASSERT (Buffer != NULL);
+    CopyMem (
+      Buffer,
+      ((HII_STRING_PACKAGE_INSTANCE *) PackageInstance)->StringPkgHdr,
+      HeaderSize
+      );
+    CopyMem (
+      Buffer + HeaderSize,
+      ((HII_STRING_PACKAGE_INSTANCE *) PackageInstance)->StringBlock,
+      BufferSize - HeaderSize
+      );
+    Package = (EFI_HII_PACKAGE_HEADER *) Buffer;
+    break;
+
+  case EFI_HII_PACKAGE_FONTS:
+    BufferSize = ((HII_FONT_PACKAGE_INSTANCE *) PackageInstance)->FontPkgHdr->Header.Length;
+    HeaderSize = ((HII_FONT_PACKAGE_INSTANCE *) PackageInstance)->FontPkgHdr->HdrSize;
+    Buffer = (UINT8 *) AllocateZeroPool (BufferSize);
+    ASSERT (Buffer != NULL);
+    CopyMem (
+      Buffer,
+      ((HII_FONT_PACKAGE_INSTANCE *) PackageInstance)->FontPkgHdr,
+      HeaderSize
+      );
+    CopyMem (
+      Buffer + HeaderSize,
+      ((HII_FONT_PACKAGE_INSTANCE *) PackageInstance)->GlyphBlock,
+      BufferSize - HeaderSize
+      );
+    Package = (EFI_HII_PACKAGE_HEADER *) Buffer;
+    break;
+
+  case EFI_HII_PACKAGE_IMAGES:
+    BufferSize = ((HII_IMAGE_PACKAGE_INSTANCE *) PackageInstance)->ImagePkgHdr.Header.Length;
+    HeaderSize = sizeof (EFI_HII_IMAGE_PACKAGE_HDR);
+    Buffer = (UINT8 *) AllocateZeroPool (BufferSize);
+    ASSERT (Buffer != NULL);
+
+    CopyMem (
+      Buffer,
+      &((HII_IMAGE_PACKAGE_INSTANCE *) PackageInstance)->ImagePkgHdr,
+      HeaderSize
+      );
+    CopyMem (
+      Buffer + sizeof (EFI_HII_PACKAGE_HEADER),
+      &HeaderSize,
+      sizeof (UINT32)
+      );
+
+    ImageBlockSize = ((HII_IMAGE_PACKAGE_INSTANCE *) PackageInstance)->ImageBlockSize;
+    if (ImageBlockSize != 0) {
+      CopyMem (
+        Buffer + HeaderSize,
+        ((HII_IMAGE_PACKAGE_INSTANCE *) PackageInstance)->ImageBlock,
+        ImageBlockSize
+        );
+    }
+
+    PaletteInfoSize = ((HII_IMAGE_PACKAGE_INSTANCE *) PackageInstance)->PaletteInfoSize;
+    if (PaletteInfoSize != 0) {
+      CopyMem (
+        Buffer + HeaderSize + ImageBlockSize,
+        ((HII_IMAGE_PACKAGE_INSTANCE *) PackageInstance)->PaletteBlock,
+        PaletteInfoSize
+        );
+      HeaderSize += ImageBlockSize;
+      CopyMem (
+        Buffer + sizeof (EFI_HII_PACKAGE_HEADER) + sizeof (UINT32),
+        &HeaderSize,
+        sizeof (UINT32)
+        );
+    }
+    Package = (EFI_HII_PACKAGE_HEADER *) Buffer;
+    break;
+
+  case EFI_HII_PACKAGE_SIMPLE_FONTS:
+    BufferSize = ((HII_SIMPLE_FONT_PACKAGE_INSTANCE *) PackageInstance)->SimpleFontPkgHdr->Header.Length;
+    Buffer = (UINT8 *) AllocateZeroPool (BufferSize);
+    ASSERT (Buffer != NULL);
+    CopyMem (
+      Buffer,
+      ((HII_SIMPLE_FONT_PACKAGE_INSTANCE *) PackageInstance)->SimpleFontPkgHdr,
+      BufferSize
+      );
+    Package = (EFI_HII_PACKAGE_HEADER *) Buffer;
+    break;
+
+  case EFI_HII_PACKAGE_DEVICE_PATH:
+    Package = (EFI_HII_PACKAGE_HEADER *) PackageInstance;
+    break;
+
+  default:
+    return EFI_INVALID_PARAMETER;
+  }
+
+  for (Link = Private->DatabaseNotifyList.ForwardLink;
+       Link != &Private->DatabaseNotifyList;
+       Link = Link->ForwardLink
+      ) {
+    Notify = CR (Link, HII_DATABASE_NOTIFY, DatabaseNotifyEntry, HII_DATABASE_NOTIFY_SIGNATURE);
+    if (Notify->NotifyType == NotifyType && Notify->PackageType == PackageType) {
+      //
+      // Check in case PackageGuid is not NULL when Package is GUID package
+      //
+      if (PackageType != EFI_HII_PACKAGE_TYPE_GUID) {
+        Notify->PackageGuid = NULL;
+      }
+      //
+      // Status of Registered Function is unknown so did not check it
+      //
+      Notify->PackageNotifyFn (
+        Notify->PackageType,
+        Notify->PackageGuid,
+        Package,
+        Handle,
+        NotifyType
+        );
+    }
+  }
+
+  if (Buffer != NULL) {
+    FreePool (Buffer);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function insert a GUID package to a package list node.
+  This is a internal function.
+
+  @param  PackageHdr             Pointer to a buffer stored with GUID package
+                                 information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created GUID pacakge
+
+  @retval EFI_SUCCESS            Guid Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Guid package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+InsertGuidPackage (
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT    HII_GUID_PACKAGE_INSTANCE          **Package
+  )
+{
+  HII_GUID_PACKAGE_INSTANCE            *GuidPackage;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+
+  if (PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  CopyMem (&PackageHeader, PackageHdr, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  //
+  // Create a GUID package node
+  //
+  GuidPackage = (HII_GUID_PACKAGE_INSTANCE *) AllocateZeroPool (sizeof (HII_GUID_PACKAGE_INSTANCE));
+  if (GuidPackage == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+  GuidPackage->GuidPkg = (UINT8 *) AllocateZeroPool (PackageHeader.Length);
+  if (GuidPackage->GuidPkg == NULL) {
+    FreePool (GuidPackage);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  GuidPackage->Signature = HII_GUID_PACKAGE_SIGNATURE;
+  CopyMem (GuidPackage->GuidPkg, PackageHdr, PackageHeader.Length);
+  InsertTailList (&PackageList->GuidPkgHdr, &GuidPackage->GuidEntry);
+  *Package = GuidPackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += PackageHeader.Length;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function exports GUID packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Guid Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportGuidPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  HII_GUID_PACKAGE_INSTANCE            *GuidPackage;
+  LIST_ENTRY                           *Link;
+  UINTN                                PackageLength;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+  EFI_STATUS                           Status;
+
+  if (PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = 0;
+  Status        = EFI_SUCCESS;
+
+  for (Link = PackageList->GuidPkgHdr.ForwardLink; Link != &PackageList->GuidPkgHdr; Link = Link->ForwardLink) {
+    GuidPackage = CR (Link, HII_GUID_PACKAGE_INSTANCE, GuidEntry, HII_GUID_PACKAGE_SIGNATURE);
+    CopyMem (&PackageHeader, GuidPackage->GuidPkg, sizeof (EFI_HII_PACKAGE_HEADER));
+    PackageLength += PackageHeader.Length;
+    if (PackageLength + *ResultSize + UsedSize <= BufferSize) {
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+                 (VOID *) GuidPackage,
+                 EFI_HII_PACKAGE_TYPE_GUID,
+                 Handle
+                 );
+      ASSERT_EFI_ERROR (Status);
+      CopyMem (Buffer, GuidPackage->GuidPkg, PackageHeader.Length);
+      Buffer = (UINT8 *) Buffer + PackageHeader.Length;
+    }
+  }
+
+  *ResultSize += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes all GUID packages from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed GUID packages.
+  @param  PackageList            Pointer to a package list that contains removing
+                                 packages.
+
+  @retval EFI_SUCCESS            GUID Package(s) is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveGuidPackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  LIST_ENTRY                           *ListHead;
+  HII_GUID_PACKAGE_INSTANCE            *Package;
+  EFI_STATUS                           Status;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+
+  ListHead = &PackageList->GuidPkgHdr;
+
+  while (!IsListEmpty (ListHead)) {
+    Package = CR (
+                ListHead->ForwardLink,
+                HII_GUID_PACKAGE_INSTANCE,
+                GuidEntry,
+                HII_GUID_PACKAGE_SIGNATURE
+                );
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_TYPE_GUID,
+               Handle
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    RemoveEntryList (&Package->GuidEntry);
+    CopyMem (&PackageHeader, Package->GuidPkg, sizeof (EFI_HII_PACKAGE_HEADER));
+    PackageList->PackageListHdr.PackageLength -= PackageHeader.Length;
+    FreePool (Package->GuidPkg);
+    FreePool (Package);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function insert a Form package to a package list node.
+  This is a internal function.
+
+  @param  PackageHdr             Pointer to a buffer stored with Form package
+                                 information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created Form package
+
+  @retval EFI_SUCCESS            Form Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Form package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+InsertFormPackage (
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT    HII_IFR_PACKAGE_INSTANCE           **Package
+  )
+{
+  HII_IFR_PACKAGE_INSTANCE *FormPackage;
+  EFI_HII_PACKAGE_HEADER   PackageHeader;
+
+  if (PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Get the length of the package, including package header itself
+  //
+  CopyMem (&PackageHeader, PackageHdr, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  //
+  // Create a Form package node
+  //
+  FormPackage = (HII_IFR_PACKAGE_INSTANCE *) AllocateZeroPool (sizeof (HII_IFR_PACKAGE_INSTANCE));
+  if (FormPackage == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  FormPackage->IfrData = (UINT8 *) AllocateZeroPool (PackageHeader.Length - sizeof (EFI_HII_PACKAGE_HEADER));
+  if (FormPackage->IfrData == NULL) {
+    FreePool (FormPackage);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  FormPackage->Signature = HII_IFR_PACKAGE_SIGNATURE;
+  //
+  // Copy Package Header
+  //
+  CopyMem (&FormPackage->FormPkgHdr, &PackageHeader, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  //
+  // Copy Ifr contents
+  //
+  CopyMem (
+    FormPackage->IfrData,
+    (UINT8 *) PackageHdr + sizeof (EFI_HII_PACKAGE_HEADER),
+    PackageHeader.Length - sizeof (EFI_HII_PACKAGE_HEADER)
+    );
+
+  InsertTailList (&PackageList->FormPkgHdr, &FormPackage->IfrEntry);
+  *Package = FormPackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += FormPackage->FormPkgHdr.Length;
+  }
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function exports Form packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Form Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportFormPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  HII_IFR_PACKAGE_INSTANCE *FormPackage;
+  UINTN                    PackageLength;
+  LIST_ENTRY               *Link;
+  EFI_STATUS               Status;
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = 0;
+  Status        = EFI_SUCCESS;
+
+  //
+  // Export Form packages.
+  //
+  for (Link = PackageList->FormPkgHdr.ForwardLink; Link != &PackageList->FormPkgHdr; Link = Link->ForwardLink) {
+    FormPackage = CR (Link, HII_IFR_PACKAGE_INSTANCE, IfrEntry, HII_IFR_PACKAGE_SIGNATURE);
+    PackageLength += FormPackage->FormPkgHdr.Length;
+    if ((Buffer != NULL) && (PackageLength + *ResultSize + UsedSize <= BufferSize)) {
+      //
+      // Invoke registered notification if exists
+      //
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+                 (VOID *) FormPackage,
+                 EFI_HII_PACKAGE_FORMS,
+                 Handle
+                 );
+      ASSERT_EFI_ERROR (Status);
+      //
+      // Copy the Form package content.
+      //
+      CopyMem (Buffer, (VOID *) (&FormPackage->FormPkgHdr), sizeof (EFI_HII_PACKAGE_HEADER));
+      Buffer = (UINT8 *) Buffer + sizeof (EFI_HII_PACKAGE_HEADER);
+      CopyMem (
+        Buffer,
+        (VOID *) FormPackage->IfrData,
+        FormPackage->FormPkgHdr.Length - sizeof (EFI_HII_PACKAGE_HEADER)
+        );
+      Buffer = (UINT8 *) Buffer + FormPackage->FormPkgHdr.Length - sizeof (EFI_HII_PACKAGE_HEADER);
+    }
+  }
+
+  *ResultSize += PackageLength;
+
+  return EFI_SUCCESS;
+
+}
+
+
+/**
+  This function deletes all Form packages from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed Form packages.
+  @param  PackageList            Pointer to a package list that contains removing
+                                 packages.
+
+  @retval EFI_SUCCESS            Form Package(s) is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveFormPackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  LIST_ENTRY                      *ListHead;
+  HII_IFR_PACKAGE_INSTANCE        *Package;
+  EFI_STATUS                      Status;
+
+  ListHead = &PackageList->FormPkgHdr;
+
+  while (!IsListEmpty (ListHead)) {
+    Package = CR (
+                ListHead->ForwardLink,
+                HII_IFR_PACKAGE_INSTANCE,
+                IfrEntry,
+                HII_IFR_PACKAGE_SIGNATURE
+                );
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_FORMS,
+               Handle
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    RemoveEntryList (&Package->IfrEntry);
+    PackageList->PackageListHdr.PackageLength -= Package->FormPkgHdr.Length;
+    FreePool (Package->IfrData);
+    FreePool (Package);
+
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+
+/**
+  This function insert a String package to a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  PackageHdr             Pointer to a buffer stored with String package
+                                 information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created String package
+
+  @retval EFI_SUCCESS            String Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 String package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+  @retval EFI_UNSUPPORTED        A string package with the same language already
+                                 exists in current package list.
+
+**/
+EFI_STATUS
+InsertStringPackage (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT    HII_STRING_PACKAGE_INSTANCE        **Package
+  )
+{
+  HII_STRING_PACKAGE_INSTANCE *StringPackage;
+  UINT32                      HeaderSize;
+  EFI_STATUS                  Status;
+  EFI_HII_PACKAGE_HEADER      PackageHeader;
+  CHAR8                       *Language;
+  UINT32                      LanguageSize;
+  LIST_ENTRY                  *Link;
+
+  if (Private == NULL || PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (Private->Signature != HII_DATABASE_PRIVATE_DATA_SIGNATURE) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  CopyMem (&PackageHeader, PackageHdr, sizeof (EFI_HII_PACKAGE_HEADER));
+  CopyMem (&HeaderSize, (UINT8 *) PackageHdr + sizeof (EFI_HII_PACKAGE_HEADER), sizeof (UINT32));
+
+  //
+  // It is illegal to have two string packages with same language within one packagelist
+  // since the stringid will be duplicate if so. Check it to avoid this potential issue.
+  //
+  LanguageSize = HeaderSize - sizeof (EFI_HII_STRING_PACKAGE_HDR) + sizeof (CHAR8);
+  Language = (CHAR8 *) AllocateZeroPool (LanguageSize);
+  if (Language == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+  AsciiStrCpy (Language, (CHAR8 *) PackageHdr + HeaderSize - LanguageSize);
+  for (Link = PackageList->StringPkgHdr.ForwardLink; Link != &PackageList->StringPkgHdr; Link = Link->ForwardLink) {
+    StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    if (HiiCompareLanguage (Language, StringPackage->StringPkgHdr->Language)) {
+      FreePool (Language);
+      return EFI_UNSUPPORTED;
+    }
+  }
+  FreePool (Language);
+
+  //
+  // Create a String package node
+  //
+  StringPackage = (HII_STRING_PACKAGE_INSTANCE *) AllocateZeroPool (sizeof (HII_STRING_PACKAGE_INSTANCE));
+  if (StringPackage == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+
+  StringPackage->StringPkgHdr = (EFI_HII_STRING_PACKAGE_HDR *) AllocateZeroPool (HeaderSize);
+  if (StringPackage->StringPkgHdr == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+
+  StringPackage->StringBlock = (UINT8 *) AllocateZeroPool (PackageHeader.Length - HeaderSize);
+  if (StringPackage->StringBlock == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+
+  StringPackage->Signature = HII_STRING_PACKAGE_SIGNATURE;
+  StringPackage->FontId    = 0;
+  InitializeListHead (&StringPackage->FontInfoList);
+
+  //
+  // Copy the String package header.
+  //
+  CopyMem (StringPackage->StringPkgHdr, PackageHdr, HeaderSize);
+
+  //
+  // Copy the String blocks
+  //
+  CopyMem (
+    StringPackage->StringBlock,
+    (UINT8 *) PackageHdr + HeaderSize,
+    PackageHeader.Length - HeaderSize
+    );
+
+  //
+  // Collect all font block info
+  //
+  Status = FindStringBlock (Private, StringPackage, (EFI_STRING_ID) (-1), NULL, NULL, NULL, &StringPackage->MaxStringId, NULL);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Insert to String package array
+  //
+  InsertTailList (&PackageList->StringPkgHdr, &StringPackage->StringEntry);
+  *Package = StringPackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += StringPackage->StringPkgHdr->Header.Length;
+  }
+
+  return EFI_SUCCESS;
+
+Error:
+
+  if (StringPackage != NULL) {
+    if (StringPackage->StringBlock != NULL) {
+      FreePool (StringPackage->StringBlock);
+    }
+    if (StringPackage->StringPkgHdr != NULL) {
+      FreePool (StringPackage->StringPkgHdr);
+    }
+    FreePool (StringPackage);
+  }
+  return Status;
+
+}
+
+/**
+ Adjust all string packages in a single package list to have the same max string ID.
+ 
+ @param  PackageList        Pointer to a package list which will be adjusted.
+
+ @retval EFI_SUCCESS  Adjust all string packages successfully.
+ @retval others       Can't adjust string packges.
+
+**/
+EFI_STATUS
+AdjustStringPackage (
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+)
+{
+  LIST_ENTRY                  *Link;
+  HII_STRING_PACKAGE_INSTANCE *StringPackage;
+  UINT32                      Skip2BlockSize;
+  UINT32                      OldBlockSize;
+  UINT8                       *StringBlock;
+  UINT8                       *BlockPtr;
+  EFI_STRING_ID               MaxStringId;
+  UINT16                      SkipCount;
+
+  MaxStringId = 0;
+  for (Link = PackageList->StringPkgHdr.ForwardLink;
+       Link != &PackageList->StringPkgHdr;
+       Link = Link->ForwardLink
+      ) {
+    StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    if (MaxStringId < StringPackage->MaxStringId) {
+      MaxStringId = StringPackage->MaxStringId;
+    }
+  }
+
+  for (Link = PackageList->StringPkgHdr.ForwardLink;
+       Link != &PackageList->StringPkgHdr;
+       Link = Link->ForwardLink
+      ) {
+    StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    if (StringPackage->MaxStringId < MaxStringId) {
+      OldBlockSize = StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+      //
+      // Create SKIP2 EFI_HII_SIBT_SKIP2_BLOCKs to reserve the missing string IDs.
+      //
+      SkipCount      = (UINT16) (MaxStringId - StringPackage->MaxStringId);
+      Skip2BlockSize = (UINT32) sizeof (EFI_HII_SIBT_SKIP2_BLOCK);
+
+      StringBlock = (UINT8 *) AllocateZeroPool (OldBlockSize + Skip2BlockSize);
+      if (StringBlock == NULL) {
+        return EFI_OUT_OF_RESOURCES;
+      }
+      //
+      // Copy original string blocks, except the EFI_HII_SIBT_END.
+      //
+      CopyMem (StringBlock, StringPackage->StringBlock, OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK));
+      //
+      // Create SKIP2 EFI_HII_SIBT_SKIP2_BLOCK blocks
+      //
+      BlockPtr  = StringBlock + OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK);
+      *BlockPtr = EFI_HII_SIBT_SKIP2;
+      CopyMem (BlockPtr + 1, &SkipCount, sizeof (UINT16));
+      BlockPtr  += sizeof (EFI_HII_SIBT_SKIP2_BLOCK);
+
+      //
+      // Append a EFI_HII_SIBT_END block to the end.
+      //
+      *BlockPtr = EFI_HII_SIBT_END;
+      FreePool (StringPackage->StringBlock);
+      StringPackage->StringBlock = StringBlock;
+      StringPackage->StringPkgHdr->Header.Length += Skip2BlockSize;
+      PackageList->PackageListHdr.PackageLength += Skip2BlockSize;
+      StringPackage->MaxStringId = MaxStringId;
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  This function exports String packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            String Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportStringPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  LIST_ENTRY                  *Link;
+  UINTN                       PackageLength;
+  EFI_STATUS                  Status;
+  HII_STRING_PACKAGE_INSTANCE *StringPackage;
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = 0;
+  Status        = EFI_SUCCESS;
+
+  for (Link = PackageList->StringPkgHdr.ForwardLink; Link != &PackageList->StringPkgHdr; Link = Link->ForwardLink) {
+    StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    PackageLength += StringPackage->StringPkgHdr->Header.Length;
+    if (PackageLength + *ResultSize + UsedSize <= BufferSize) {
+      //
+      // Invoke registered notification function with EXPORT_PACK notify type
+      //
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+                 (VOID *) StringPackage,
+                 EFI_HII_PACKAGE_STRINGS,
+                 Handle
+                 );
+      ASSERT_EFI_ERROR (Status);
+      //
+      // Copy String package header
+      //
+      CopyMem (Buffer, StringPackage->StringPkgHdr, StringPackage->StringPkgHdr->HdrSize);
+      Buffer = (UINT8 *) Buffer + StringPackage->StringPkgHdr->HdrSize;
+
+      //
+      // Copy String blocks information
+      //
+      CopyMem (
+        Buffer,
+        StringPackage->StringBlock,
+        StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize
+        );
+      Buffer = (UINT8 *) Buffer + StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+    }
+  }
+
+  *ResultSize += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes all String packages from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed String packages.
+  @param  PackageList            Pointer to a package list that contains removing
+                                 packages.
+
+  @retval EFI_SUCCESS            String Package(s) is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveStringPackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  LIST_ENTRY                      *ListHead;
+  HII_STRING_PACKAGE_INSTANCE     *Package;
+  HII_FONT_INFO                   *FontInfo;
+  EFI_STATUS                      Status;
+
+  ListHead = &PackageList->StringPkgHdr;
+
+  while (!IsListEmpty (ListHead)) {
+    Package = CR (
+                ListHead->ForwardLink,
+                HII_STRING_PACKAGE_INSTANCE,
+                StringEntry,
+                HII_STRING_PACKAGE_SIGNATURE
+                );
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_STRINGS,
+               Handle
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    RemoveEntryList (&Package->StringEntry);
+    PackageList->PackageListHdr.PackageLength -= Package->StringPkgHdr->Header.Length;
+    FreePool (Package->StringBlock);
+    FreePool (Package->StringPkgHdr);
+    //
+    // Delete font information
+    //
+    while (!IsListEmpty (&Package->FontInfoList)) {
+      FontInfo = CR (
+                   Package->FontInfoList.ForwardLink,
+                   HII_FONT_INFO,
+                   Entry,
+                   HII_FONT_INFO_SIGNATURE
+                   );
+      RemoveEntryList (&FontInfo->Entry);
+      FreePool (FontInfo);
+    }
+
+    FreePool (Package);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function insert a Font package to a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  PackageHdr             Pointer to a buffer stored with Font package
+                                 information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created Font package
+
+  @retval EFI_SUCCESS            Font Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Font package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+  @retval EFI_UNSUPPORTED        A font package with same EFI_FONT_INFO already
+                                 exists in current hii database.
+
+**/
+EFI_STATUS
+InsertFontPackage (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT    HII_FONT_PACKAGE_INSTANCE          **Package
+  )
+{
+  HII_FONT_PACKAGE_INSTANCE *FontPackage;
+  EFI_HII_FONT_PACKAGE_HDR  *FontPkgHdr;
+  UINT32                    HeaderSize;
+  EFI_STATUS                Status;
+  EFI_HII_PACKAGE_HEADER    PackageHeader;
+  EFI_FONT_INFO             *FontInfo;
+  UINT32                    FontInfoSize;
+  HII_GLOBAL_FONT_INFO      *GlobalFont;
+
+  if (Private == NULL || PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  CopyMem (&PackageHeader, PackageHdr, sizeof (EFI_HII_PACKAGE_HEADER));
+  CopyMem (&HeaderSize, (UINT8 *) PackageHdr + sizeof (EFI_HII_PACKAGE_HEADER), sizeof (UINT32));
+
+  FontInfo    = NULL;
+  FontPackage = NULL;
+  GlobalFont  = NULL;
+
+  //
+  // It is illegal to have two font packages with same EFI_FONT_INFO within hii
+  // database. EFI_FONT_INFO (FontName, FontSize, FontStyle) describes font's
+  // attributes and identify a font uniquely.
+  //
+  FontPkgHdr = (EFI_HII_FONT_PACKAGE_HDR *) AllocateZeroPool (HeaderSize);
+  if (FontPkgHdr == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  CopyMem (FontPkgHdr, PackageHdr, HeaderSize);
+
+  FontInfoSize = sizeof (EFI_FONT_INFO) + HeaderSize - sizeof (EFI_HII_FONT_PACKAGE_HDR);
+  FontInfo = (EFI_FONT_INFO *) AllocateZeroPool (FontInfoSize);
+  if (FontInfo == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  FontInfo->FontStyle = FontPkgHdr->FontStyle;
+  FontInfo->FontSize  = FontPkgHdr->Cell.Height;
+  StrCpy (FontInfo->FontName, FontPkgHdr->FontFamily);
+
+  if (IsFontInfoExisted (Private, FontInfo, NULL, NULL, NULL)) {
+    Status = EFI_UNSUPPORTED;
+    goto Error;
+  }
+
+  //
+  // Create a Font package node
+  //
+  FontPackage = (HII_FONT_PACKAGE_INSTANCE *) AllocateZeroPool (sizeof (HII_FONT_PACKAGE_INSTANCE));
+  if (FontPackage == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  FontPackage->Signature  = HII_FONT_PACKAGE_SIGNATURE;
+  FontPackage->FontPkgHdr = FontPkgHdr;
+  InitializeListHead (&FontPackage->GlyphInfoList);
+
+  FontPackage->GlyphBlock = (UINT8 *) AllocateZeroPool (PackageHeader.Length - HeaderSize);
+  if (FontPackage->GlyphBlock == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  CopyMem (FontPackage->GlyphBlock, (UINT8 *) PackageHdr + HeaderSize, PackageHeader.Length - HeaderSize);
+
+  //
+  // Collect all default character cell information and backup in GlyphInfoList.
+  //
+  Status = FindGlyphBlock (FontPackage, (CHAR16) (-1), NULL, NULL, NULL);
+  if (EFI_ERROR (Status)) {
+    goto Error;
+  }
+
+  //
+  // This font package describes an unique EFI_FONT_INFO. Backup it in global
+  // font info list.
+  //
+  GlobalFont = (HII_GLOBAL_FONT_INFO *) AllocateZeroPool (sizeof (HII_GLOBAL_FONT_INFO));
+  if (GlobalFont == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  GlobalFont->Signature    = HII_GLOBAL_FONT_INFO_SIGNATURE;
+  GlobalFont->FontPackage  = FontPackage;
+  GlobalFont->FontInfoSize = FontInfoSize;
+  GlobalFont->FontInfo     = FontInfo;
+  InsertTailList (&Private->FontInfoList, &GlobalFont->Entry);
+
+  //
+  // Insert this font package to Font package array
+  //
+  InsertTailList (&PackageList->FontPkgHdr, &FontPackage->FontEntry);
+  *Package = FontPackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += FontPackage->FontPkgHdr->Header.Length;
+  }
+
+  return EFI_SUCCESS;
+
+Error:
+
+  if (FontPkgHdr != NULL) {
+    FreePool (FontPkgHdr);
+  }
+  if (FontInfo != NULL) {
+    FreePool (FontInfo);
+  }
+  if (FontPackage != NULL) {
+    if (FontPackage->GlyphBlock != NULL) {
+      FreePool (FontPackage->GlyphBlock);
+    }
+    FreePool (FontPackage);
+  }
+  if (GlobalFont != NULL) {
+    FreePool (GlobalFont);
+  }
+
+  return Status;
+
+}
+
+
+/**
+  This function exports Font packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Font Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportFontPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  LIST_ENTRY                  *Link;
+  UINTN                       PackageLength;
+  EFI_STATUS                  Status;
+  HII_FONT_PACKAGE_INSTANCE   *Package;
+
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = 0;
+  Status        = EFI_SUCCESS;
+
+  for (Link = PackageList->FontPkgHdr.ForwardLink; Link != &PackageList->FontPkgHdr; Link = Link->ForwardLink) {
+    Package = CR (Link, HII_FONT_PACKAGE_INSTANCE, FontEntry, HII_FONT_PACKAGE_SIGNATURE);
+    PackageLength += Package->FontPkgHdr->Header.Length;
+    if (PackageLength + *ResultSize + UsedSize <= BufferSize) {
+      //
+      // Invoke registered notification function with EXPORT_PACK notify type
+      //
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+                 (VOID *) Package,
+                 EFI_HII_PACKAGE_FONTS,
+                 Handle
+                 );
+      ASSERT_EFI_ERROR (Status);
+      //
+      // Copy Font package header
+      //
+      CopyMem (Buffer, Package->FontPkgHdr, Package->FontPkgHdr->HdrSize);
+      Buffer = (UINT8 *) Buffer + Package->FontPkgHdr->HdrSize;
+
+      //
+      // Copy Glyph blocks information
+      //
+      CopyMem (
+        Buffer,
+        Package->GlyphBlock,
+        Package->FontPkgHdr->Header.Length - Package->FontPkgHdr->HdrSize
+        );
+      Buffer = (UINT8 *) Buffer + Package->FontPkgHdr->Header.Length - Package->FontPkgHdr->HdrSize;
+    }
+  }
+
+  *ResultSize += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes all Font packages from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed Font packages.
+  @param  PackageList            Pointer to a package list that contains removing
+                                 packages.
+
+  @retval EFI_SUCCESS            Font Package(s) is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveFontPackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  LIST_ENTRY                      *ListHead;
+  HII_FONT_PACKAGE_INSTANCE       *Package;
+  EFI_STATUS                      Status;
+  HII_GLYPH_INFO                  *GlyphInfo;
+  LIST_ENTRY                      *Link;
+  HII_GLOBAL_FONT_INFO            *GlobalFont;
+
+  ListHead = &PackageList->FontPkgHdr;
+
+  while (!IsListEmpty (ListHead)) {
+    Package = CR (
+                ListHead->ForwardLink,
+                HII_FONT_PACKAGE_INSTANCE,
+                FontEntry,
+                HII_FONT_PACKAGE_SIGNATURE
+                );
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_FONTS,
+               Handle
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    RemoveEntryList (&Package->FontEntry);
+    PackageList->PackageListHdr.PackageLength -= Package->FontPkgHdr->Header.Length;
+
+    if (Package->GlyphBlock != NULL) {
+      FreePool (Package->GlyphBlock);
+    }
+    FreePool (Package->FontPkgHdr);
+    //
+    // Delete default character cell information
+    //
+    while (!IsListEmpty (&Package->GlyphInfoList)) {
+      GlyphInfo = CR (
+                    Package->GlyphInfoList.ForwardLink,
+                    HII_GLYPH_INFO,
+                    Entry,
+                    HII_GLYPH_INFO_SIGNATURE
+                    );
+      RemoveEntryList (&GlyphInfo->Entry);
+      FreePool (GlyphInfo);
+    }
+
+    //
+    // Remove corresponding global font info
+    //
+    for (Link = Private->FontInfoList.ForwardLink; Link != &Private->FontInfoList; Link = Link->ForwardLink) {
+      GlobalFont = CR (Link, HII_GLOBAL_FONT_INFO, Entry, HII_GLOBAL_FONT_INFO_SIGNATURE);
+      if (GlobalFont->FontPackage == Package) {
+        RemoveEntryList (&GlobalFont->Entry);
+        FreePool (GlobalFont->FontInfo);
+        FreePool (GlobalFont);
+        break;
+      }
+    }
+
+    FreePool (Package);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function insert a Image package to a package list node.
+  This is a internal function.
+
+  @param  PackageHdr             Pointer to a buffer stored with Image package
+                                 information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created Image package
+
+  @retval EFI_SUCCESS            Image Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Image package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+InsertImagePackage (
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT    HII_IMAGE_PACKAGE_INSTANCE         **Package
+  )
+{
+  HII_IMAGE_PACKAGE_INSTANCE        *ImagePackage;
+  UINT32                            PaletteSize;
+  UINT32                            ImageSize;
+  UINT16                            Index;
+  EFI_HII_IMAGE_PALETTE_INFO_HEADER *PaletteHdr;
+  EFI_HII_IMAGE_PALETTE_INFO        *PaletteInfo;
+  UINT32                            PaletteInfoOffset;
+  UINT32                            ImageInfoOffset;
+  UINT16                            CurrentSize;
+
+  if (PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Less than one image package is allowed in one package list.
+  //
+  if (PackageList->ImagePkg != NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Create a Image package node
+  //
+  ImagePackage = (HII_IMAGE_PACKAGE_INSTANCE *) AllocateZeroPool (sizeof (HII_IMAGE_PACKAGE_INSTANCE));
+  if (ImagePackage == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // Copy the Image package header.
+  //
+  CopyMem (&ImagePackage->ImagePkgHdr, PackageHdr, sizeof (EFI_HII_IMAGE_PACKAGE_HDR));
+
+  PaletteInfoOffset = ImagePackage->ImagePkgHdr.PaletteInfoOffset;
+  ImageInfoOffset   = ImagePackage->ImagePkgHdr.ImageInfoOffset;
+
+  //
+  // If PaletteInfoOffset is zero, there are no palettes in this image package.
+  //
+  PaletteSize                = 0;
+  ImagePackage->PaletteBlock = NULL;
+  if (PaletteInfoOffset != 0) {
+    PaletteHdr  = (EFI_HII_IMAGE_PALETTE_INFO_HEADER *) ((UINT8 *) PackageHdr + PaletteInfoOffset);
+    PaletteSize = sizeof (EFI_HII_IMAGE_PALETTE_INFO_HEADER);
+    PaletteInfo = (EFI_HII_IMAGE_PALETTE_INFO *) ((UINT8 *) PaletteHdr + PaletteSize);
+
+    for (Index = 0; Index < PaletteHdr->PaletteCount; Index++) {
+      CopyMem (&CurrentSize, PaletteInfo, sizeof (UINT16));
+      CurrentSize += sizeof (UINT16);
+      PaletteSize += (UINT32) CurrentSize;
+      PaletteInfo = (EFI_HII_IMAGE_PALETTE_INFO *) ((UINT8 *) PaletteInfo + CurrentSize);
+    }
+
+    ImagePackage->PaletteBlock = (UINT8 *) AllocateZeroPool (PaletteSize);
+    if (ImagePackage->PaletteBlock == NULL) {
+      FreePool (ImagePackage);
+      return EFI_OUT_OF_RESOURCES;
+    }
+    CopyMem (
+      ImagePackage->PaletteBlock,
+      (UINT8 *) PackageHdr + PaletteInfoOffset,
+      PaletteSize
+      );
+  }
+
+  //
+  // If ImageInfoOffset is zero, there are no images in this package.
+  //
+  ImageSize                = 0;
+  ImagePackage->ImageBlock = NULL;
+  if (ImageInfoOffset != 0) {
+    ImageSize = ImagePackage->ImagePkgHdr.Header.Length -
+                sizeof (EFI_HII_IMAGE_PACKAGE_HDR) - PaletteSize;
+    ImagePackage->ImageBlock = (UINT8 *) AllocateZeroPool (ImageSize);
+    if (ImagePackage->ImageBlock == NULL) {
+      FreePool (ImagePackage->PaletteBlock);
+      FreePool (ImagePackage);
+      return EFI_OUT_OF_RESOURCES;
+    }
+    CopyMem (
+      ImagePackage->ImageBlock,
+      (UINT8 *) PackageHdr + ImageInfoOffset,
+      ImageSize
+      );
+  }
+
+  ImagePackage->ImageBlockSize  = ImageSize;
+  ImagePackage->PaletteInfoSize = PaletteSize;
+  PackageList->ImagePkg         = ImagePackage;
+  *Package                      = ImagePackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += ImagePackage->ImagePkgHdr.Header.Length;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function exports Image packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Image Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportImagePackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  UINTN                       PackageLength;
+  EFI_STATUS                  Status;
+  HII_IMAGE_PACKAGE_INSTANCE  *Package;
+
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Package = PackageList->ImagePkg;
+
+  if (Package == NULL) {
+    return EFI_SUCCESS;
+  }
+
+  PackageLength = Package->ImagePkgHdr.Header.Length;
+
+  if (PackageLength + *ResultSize + UsedSize <= BufferSize) {
+    //
+    // Invoke registered notification function with EXPORT_PACK notify type
+    //
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_IMAGES,
+               Handle
+               );
+    ASSERT_EFI_ERROR (Status);
+    ASSERT (Package->ImagePkgHdr.Header.Length ==
+            sizeof (EFI_HII_IMAGE_PACKAGE_HDR) + Package->ImageBlockSize + Package->PaletteInfoSize);
+    //
+    // Copy Image package header,
+    // then justify the offset for image info and palette info in the header.
+    //
+    CopyMem (Buffer, &Package->ImagePkgHdr, sizeof (EFI_HII_IMAGE_PACKAGE_HDR));
+    Buffer = (UINT8 *) Buffer + sizeof (EFI_HII_IMAGE_PACKAGE_HDR);
+
+    //
+    // Copy Image blocks information
+    //
+    if (Package->ImageBlockSize != 0) {
+      CopyMem (Buffer, Package->ImageBlock, Package->ImageBlockSize);
+      Buffer = (UINT8 *) Buffer + Package->ImageBlockSize;
+    }
+    //
+    // Copy Palette information
+    //
+    if (Package->PaletteInfoSize != 0) {
+      CopyMem (Buffer, Package->PaletteBlock, Package->PaletteInfoSize);
+      Buffer = (UINT8 *) Buffer + Package->PaletteInfoSize;
+    }
+  }
+
+  *ResultSize += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes Image package from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed Image packages.
+  @param  PackageList            Package List which contains the to be  removed
+                                 Image package.
+
+  @retval EFI_SUCCESS            Image Package(s) is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveImagePackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  HII_IMAGE_PACKAGE_INSTANCE      *Package;
+  EFI_STATUS                      Status;
+
+  Package = PackageList->ImagePkg;
+
+  //
+  // Image package does not exist, return directly.
+  //
+  if (Package == NULL) {
+    return EFI_SUCCESS;
+  }
+
+  Status = InvokeRegisteredFunction (
+             Private,
+             EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+             (VOID *) Package,
+             EFI_HII_PACKAGE_IMAGES,
+             Handle
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  PackageList->PackageListHdr.PackageLength -= Package->ImagePkgHdr.Header.Length;
+
+  FreePool (Package->ImageBlock);
+  if (Package->PaletteBlock != NULL) {
+    FreePool (Package->PaletteBlock);
+  }
+  FreePool (Package);
+
+  PackageList->ImagePkg = NULL;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function insert a Simple Font package to a package list node.
+  This is a internal function.
+
+  @param  PackageHdr             Pointer to a buffer stored with Simple Font
+                                 package information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created Simple Font package
+
+  @retval EFI_SUCCESS            Simple Font Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Simple Font package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+InsertSimpleFontPackage (
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT HII_SIMPLE_FONT_PACKAGE_INSTANCE      **Package
+  )
+{
+  HII_SIMPLE_FONT_PACKAGE_INSTANCE *SimpleFontPackage;
+  EFI_STATUS                       Status;
+  EFI_HII_PACKAGE_HEADER           Header;
+
+  if (PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Create a Simple Font package node
+  //
+  SimpleFontPackage = AllocateZeroPool (sizeof (HII_SIMPLE_FONT_PACKAGE_INSTANCE));
+  if (SimpleFontPackage == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  SimpleFontPackage->Signature = HII_S_FONT_PACKAGE_SIGNATURE;
+
+  //
+  // Copy the Simple Font package.
+  //
+  CopyMem (&Header, PackageHdr, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  SimpleFontPackage->SimpleFontPkgHdr = AllocateZeroPool (Header.Length);
+  if (SimpleFontPackage->SimpleFontPkgHdr == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+
+  CopyMem (SimpleFontPackage->SimpleFontPkgHdr, PackageHdr, Header.Length);
+
+  //
+  // Insert to Simple Font package array
+  //
+  InsertTailList (&PackageList->SimpleFontPkgHdr, &SimpleFontPackage->SimpleFontEntry);
+  *Package = SimpleFontPackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += Header.Length;
+  }
+
+  return EFI_SUCCESS;
+
+Error:
+
+  if (SimpleFontPackage != NULL) {
+    if (SimpleFontPackage->SimpleFontPkgHdr != NULL) {
+      FreePool (SimpleFontPackage->SimpleFontPkgHdr);
+    }
+    FreePool (SimpleFontPackage);
+  }
+  return Status;
+}
+
+
+/**
+  This function exports SimpleFont packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            SimpleFont Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportSimpleFontPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  LIST_ENTRY                        *Link;
+  UINTN                             PackageLength;
+  EFI_STATUS                        Status;
+  HII_SIMPLE_FONT_PACKAGE_INSTANCE  *Package;
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = 0;
+  Status        = EFI_SUCCESS;
+
+  for (Link = PackageList->SimpleFontPkgHdr.ForwardLink; Link != &PackageList->SimpleFontPkgHdr; Link = Link->ForwardLink) {
+    Package = CR (Link, HII_SIMPLE_FONT_PACKAGE_INSTANCE, SimpleFontEntry, HII_S_FONT_PACKAGE_SIGNATURE);
+    PackageLength += Package->SimpleFontPkgHdr->Header.Length;
+    if (PackageLength + *ResultSize + UsedSize <= BufferSize) {
+      //
+      // Invoke registered notification function with EXPORT_PACK notify type
+      //
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+                 (VOID *) Package,
+                 EFI_HII_PACKAGE_SIMPLE_FONTS,
+                 Handle
+                 );
+      ASSERT_EFI_ERROR (Status);
+
+      //
+      // Copy SimpleFont package
+      //
+      CopyMem (Buffer, Package->SimpleFontPkgHdr, Package->SimpleFontPkgHdr->Header.Length);
+      Buffer = (UINT8 *) Buffer + Package->SimpleFontPkgHdr->Header.Length;
+    }
+  }
+
+  *ResultSize += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes all Simple Font packages from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed Simple Font packages.
+  @param  PackageList            Pointer to a package list that contains removing
+                                 packages.
+
+  @retval EFI_SUCCESS            Simple Font Package(s) is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveSimpleFontPackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  LIST_ENTRY                       *ListHead;
+  HII_SIMPLE_FONT_PACKAGE_INSTANCE *Package;
+  EFI_STATUS                       Status;
+
+  ListHead = &PackageList->SimpleFontPkgHdr;
+
+  while (!IsListEmpty (ListHead)) {
+    Package = CR (
+                ListHead->ForwardLink,
+                HII_SIMPLE_FONT_PACKAGE_INSTANCE,
+                SimpleFontEntry,
+                HII_S_FONT_PACKAGE_SIGNATURE
+                );
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_SIMPLE_FONTS,
+               Handle
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    RemoveEntryList (&Package->SimpleFontEntry);
+    PackageList->PackageListHdr.PackageLength -= Package->SimpleFontPkgHdr->Header.Length;
+    FreePool (Package->SimpleFontPkgHdr);
+    FreePool (Package);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function insert a Device path package to a package list node.
+  This is a internal function.
+
+  @param  DevicePath             Pointer to a EFI_DEVICE_PATH_PROTOCOL protocol
+                                 instance
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+
+  @retval EFI_SUCCESS            Device path Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Device path package.
+  @retval EFI_INVALID_PARAMETER  DevicePath is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+InsertDevicePathPackage (
+  IN     EFI_DEVICE_PATH_PROTOCOL           *DevicePath,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  UINT32                           PackageLength;
+  EFI_HII_PACKAGE_HEADER           Header;
+
+  if (DevicePath == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  //
+  // Less than one device path package is allowed in one package list.
+  //
+  if (PackageList->DevicePathPkg != NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = (UINT32) GetDevicePathSize (DevicePath) + sizeof (EFI_HII_PACKAGE_HEADER);
+  PackageList->DevicePathPkg = (UINT8 *) AllocateZeroPool (PackageLength);
+  if (PackageList->DevicePathPkg == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  Header.Length = PackageLength;
+  Header.Type   = EFI_HII_PACKAGE_DEVICE_PATH;
+  CopyMem (PackageList->DevicePathPkg, &Header, sizeof (EFI_HII_PACKAGE_HEADER));
+  CopyMem (
+    PackageList->DevicePathPkg + sizeof (EFI_HII_PACKAGE_HEADER),
+    DevicePath,
+    PackageLength - sizeof (EFI_HII_PACKAGE_HEADER)
+    );
+
+  //
+  // Since Device Path package is created by NewPackageList, either NEW_PACK
+  // or ADD_PACK should increase the length of package list.
+  //
+  PackageList->PackageListHdr.PackageLength += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function exports device path package to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Device path Package is exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportDevicePathPackage (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  EFI_STATUS                       Status;
+  UINT8                            *Package;
+  EFI_HII_PACKAGE_HEADER           Header;
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Package = PackageList->DevicePathPkg;
+
+  if (Package == NULL) {
+    return EFI_SUCCESS;
+  }
+
+  CopyMem (&Header, Package, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  if (Header.Length + *ResultSize + UsedSize <= BufferSize) {
+    //
+    // Invoke registered notification function with EXPORT_PACK notify type
+    //
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_DEVICE_PATH,
+               Handle
+               );
+    ASSERT_EFI_ERROR (Status);
+
+    //
+    // Copy Device path package
+    //
+    CopyMem (Buffer, Package, Header.Length);
+  }
+
+  *ResultSize += Header.Length;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes Device Path package from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list.
+  @param  PackageList            Package List which contains the to be  removed
+                                 Device Path package.
+
+  @retval EFI_SUCCESS            Device Path Package is deleted successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveDevicePathPackage (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  EFI_STATUS                       Status;
+  UINT8                            *Package;
+  EFI_HII_PACKAGE_HEADER           Header;
+
+  Package = PackageList->DevicePathPkg;
+
+  //
+  // No device path, return directly.
+  //
+  if (Package == NULL) {
+    return EFI_SUCCESS;
+  }
+
+  Status = InvokeRegisteredFunction (
+             Private,
+             EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+             (VOID *) Package,
+             EFI_HII_PACKAGE_DEVICE_PATH,
+             Handle
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  CopyMem (&Header, Package, sizeof (EFI_HII_PACKAGE_HEADER));
+  PackageList->PackageListHdr.PackageLength -= Header.Length;
+
+  FreePool (Package);
+
+  PackageList->DevicePathPkg = NULL;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function will insert a device path package to package list firstly then
+  invoke notification functions if any.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  NotifyType             The type of change concerning the database.
+  @param  DevicePath             Pointer to a EFI_DEVICE_PATH_PROTOCOL protocol
+                                 instance
+  @param  DatabaseRecord         Pointer to a database record contains  a package
+                                 list which will be inserted to.
+
+  @retval EFI_SUCCESS            Device path Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Device path package.
+  @retval EFI_INVALID_PARAMETER  DevicePath is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+AddDevicePathPackage (
+  IN HII_DATABASE_PRIVATE_DATA        *Private,
+  IN EFI_HII_DATABASE_NOTIFY_TYPE     NotifyType,
+  IN EFI_DEVICE_PATH_PROTOCOL         *DevicePath,
+  IN OUT HII_DATABASE_RECORD          *DatabaseRecord
+  )
+{
+  EFI_STATUS                          Status;
+
+  if (DevicePath == NULL) {
+    return EFI_SUCCESS;
+  }
+
+  ASSERT (Private != NULL);
+  ASSERT (DatabaseRecord != NULL);
+
+  //
+  // Create a device path package and insert to packagelist
+  //
+  Status = InsertDevicePathPackage (
+               DevicePath,
+               NotifyType,
+               DatabaseRecord->PackageList
+               );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  return InvokeRegisteredFunction (
+            Private,
+            NotifyType,
+            (VOID *) DatabaseRecord->PackageList->DevicePathPkg,
+            EFI_HII_PACKAGE_DEVICE_PATH,
+            DatabaseRecord->Handle
+            );
+}
+
+
+/**
+  This function insert a Keyboard Layout package to a package list node.
+  This is a internal function.
+
+  @param  PackageHdr             Pointer to a buffer stored with Keyboard Layout
+                                 package information.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list which will be inserted
+                                 to.
+  @param  Package                Created Keyboard Layout package
+
+  @retval EFI_SUCCESS            Keyboard Layout Package is inserted successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Keyboard Layout package.
+  @retval EFI_INVALID_PARAMETER  PackageHdr is NULL or PackageList is NULL.
+
+**/
+EFI_STATUS
+InsertKeyboardLayoutPackage (
+  IN     VOID                               *PackageHdr,
+  IN     EFI_HII_DATABASE_NOTIFY_TYPE       NotifyType,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  OUT HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE  **Package
+  )
+{
+  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *KeyboardLayoutPackage;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+  EFI_STATUS                           Status;
+
+  if (PackageHdr == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  CopyMem (&PackageHeader, PackageHdr, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  //
+  // Create a Keyboard Layout package node
+  //
+  KeyboardLayoutPackage = AllocateZeroPool (sizeof (HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE));
+  if (KeyboardLayoutPackage == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+  KeyboardLayoutPackage->Signature = HII_KB_LAYOUT_PACKAGE_SIGNATURE;
+
+  KeyboardLayoutPackage->KeyboardPkg = (UINT8 *) AllocateZeroPool (PackageHeader.Length);
+  if (KeyboardLayoutPackage->KeyboardPkg == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Error;
+  }
+
+  CopyMem (KeyboardLayoutPackage->KeyboardPkg, PackageHdr, PackageHeader.Length);
+  InsertTailList (&PackageList->KeyboardLayoutHdr, &KeyboardLayoutPackage->KeyboardEntry);
+
+  *Package = KeyboardLayoutPackage;
+
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    PackageList->PackageListHdr.PackageLength += PackageHeader.Length;
+  }
+
+  return EFI_SUCCESS;
+
+Error:
+
+
+  if (KeyboardLayoutPackage != NULL) {
+    if (KeyboardLayoutPackage->KeyboardPkg != NULL) {
+      FreePool (KeyboardLayoutPackage->KeyboardPkg);
+    }
+    FreePool (KeyboardLayoutPackage);
+  }
+
+  return Status;
+}
+
+
+/**
+  This function exports Keyboard Layout packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Keyboard Layout Packages are exported
+                                 successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportKeyboardLayoutPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  )
+{
+  LIST_ENTRY                           *Link;
+  UINTN                                PackageLength;
+  EFI_STATUS                           Status;
+  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *Package;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+
+  if (Private == NULL || PackageList == NULL || ResultSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PackageLength = 0;
+  Status        = EFI_SUCCESS;
+
+  for (Link = PackageList->KeyboardLayoutHdr.ForwardLink; Link != &PackageList->KeyboardLayoutHdr; Link = Link->ForwardLink) {
+    Package = CR (Link, HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE, KeyboardEntry, HII_KB_LAYOUT_PACKAGE_SIGNATURE);
+    CopyMem (&PackageHeader, Package->KeyboardPkg, sizeof (EFI_HII_PACKAGE_HEADER));
+    PackageLength += PackageHeader.Length;
+    if (PackageLength + *ResultSize + UsedSize <= BufferSize) {
+      //
+      // Invoke registered notification function with EXPORT_PACK notify type
+      //
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 EFI_HII_DATABASE_NOTIFY_EXPORT_PACK,
+                 (EFI_HII_PACKAGE_HEADER *) Package,
+                 EFI_HII_PACKAGE_KEYBOARD_LAYOUT,
+                 Handle
+                 );
+      ASSERT_EFI_ERROR (Status);
+
+      //
+      // Copy Keyboard Layout package
+      //
+      CopyMem (Buffer, Package->KeyboardPkg, PackageHeader.Length);
+      Buffer = (UINT8 *) Buffer + PackageHeader.Length;
+    }
+  }
+
+  *ResultSize += PackageLength;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function deletes all Keyboard Layout packages from a package list node.
+  This is a internal function.
+
+  @param  Private                Hii database private data.
+  @param  Handle                 Handle of the package list which contains the to
+                                 be  removed Keyboard Layout packages.
+  @param  PackageList            Pointer to a package list that contains removing
+                                 packages.
+
+  @retval EFI_SUCCESS            Keyboard Layout Package(s) is deleted
+                                 successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+
+**/
+EFI_STATUS
+RemoveKeyboardLayoutPackages (
+  IN     HII_DATABASE_PRIVATE_DATA          *Private,
+  IN     EFI_HII_HANDLE                     Handle,
+  IN OUT HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList
+  )
+{
+  LIST_ENTRY                           *ListHead;
+  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *Package;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+  EFI_STATUS                           Status;
+
+  ListHead = &PackageList->KeyboardLayoutHdr;
+
+  while (!IsListEmpty (ListHead)) {
+    Package = CR (
+                ListHead->ForwardLink,
+                HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE,
+                KeyboardEntry,
+                HII_KB_LAYOUT_PACKAGE_SIGNATURE
+                );
+    Status = InvokeRegisteredFunction (
+               Private,
+               EFI_HII_DATABASE_NOTIFY_REMOVE_PACK,
+               (VOID *) Package,
+               EFI_HII_PACKAGE_KEYBOARD_LAYOUT,
+               Handle
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    RemoveEntryList (&Package->KeyboardEntry);
+    CopyMem (&PackageHeader, Package->KeyboardPkg, sizeof (EFI_HII_PACKAGE_HEADER));
+    PackageList->PackageListHdr.PackageLength -= PackageHeader.Length;
+    FreePool (Package->KeyboardPkg);
+    FreePool (Package);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function will insert a package list to hii database firstly then
+  invoke notification functions if any. It is the worker function of
+  HiiNewPackageList and HiiUpdatePackageList.
+
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  NotifyType             The type of change concerning the database.
+  @param  PackageList            Pointer to a package list.
+  @param  DatabaseRecord         Pointer to a database record contains  a package
+                                 list instance which will be inserted to.
+
+  @retval EFI_SUCCESS            All incoming packages are inserted to current
+                                 database.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 Device path package.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+AddPackages (
+  IN HII_DATABASE_PRIVATE_DATA         *Private,
+  IN EFI_HII_DATABASE_NOTIFY_TYPE      NotifyType,
+  IN CONST EFI_HII_PACKAGE_LIST_HEADER *PackageList,
+  IN OUT   HII_DATABASE_RECORD         *DatabaseRecord
+  )
+{
+  EFI_STATUS                           Status;
+  HII_GUID_PACKAGE_INSTANCE            *GuidPackage;
+  HII_IFR_PACKAGE_INSTANCE             *FormPackage;
+  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *KeyboardLayoutPackage;
+  HII_STRING_PACKAGE_INSTANCE          *StringPackage;
+  HII_FONT_PACKAGE_INSTANCE            *FontPackage;
+  HII_SIMPLE_FONT_PACKAGE_INSTANCE     *SimpleFontPackage;
+  HII_IMAGE_PACKAGE_INSTANCE           *ImagePackage;
+  EFI_HII_PACKAGE_HEADER               *PackageHdrPtr;
+  EFI_HII_PACKAGE_HEADER               PackageHeader;
+  UINT32                               OldPackageListLen;
+  BOOLEAN                              StringPkgIsAdd;
+
+  //
+  // Initialize Variables
+  //
+  StringPkgIsAdd = FALSE;
+  FontPackage = NULL;
+
+  //
+  // Process the package list header
+  //
+  OldPackageListLen = DatabaseRecord->PackageList->PackageListHdr.PackageLength;
+  CopyMem (
+    &DatabaseRecord->PackageList->PackageListHdr,
+    (VOID *) PackageList,
+    sizeof (EFI_HII_PACKAGE_LIST_HEADER)
+    );
+  if (NotifyType == EFI_HII_DATABASE_NOTIFY_ADD_PACK) {
+    DatabaseRecord->PackageList->PackageListHdr.PackageLength = OldPackageListLen;
+  }
+
+  PackageHdrPtr = (EFI_HII_PACKAGE_HEADER *) ((UINT8 *) PackageList + sizeof (EFI_HII_PACKAGE_LIST_HEADER));
+  CopyMem (&PackageHeader, PackageHdrPtr, sizeof (EFI_HII_PACKAGE_HEADER));
+
+  Status = EFI_SUCCESS;
+
+  while (PackageHeader.Type != EFI_HII_PACKAGE_END) {
+    switch (PackageHeader.Type) {
+    case EFI_HII_PACKAGE_TYPE_GUID:
+      Status = InsertGuidPackage (
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &GuidPackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) GuidPackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      break;
+    case EFI_HII_PACKAGE_FORMS:
+      Status = InsertFormPackage (
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &FormPackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) FormPackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      break;
+    case EFI_HII_PACKAGE_KEYBOARD_LAYOUT:
+      Status = InsertKeyboardLayoutPackage (
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &KeyboardLayoutPackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) KeyboardLayoutPackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      break;
+    case EFI_HII_PACKAGE_STRINGS:
+      Status = InsertStringPackage (
+                 Private,
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &StringPackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) StringPackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      StringPkgIsAdd = TRUE;
+      break;
+    case EFI_HII_PACKAGE_FONTS:
+      Status = InsertFontPackage (
+                 Private,
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &FontPackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) FontPackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      break;
+    case EFI_HII_PACKAGE_IMAGES:
+      Status = InsertImagePackage (
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &ImagePackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) ImagePackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      break;
+    case EFI_HII_PACKAGE_SIMPLE_FONTS:
+      Status = InsertSimpleFontPackage (
+                 PackageHdrPtr,
+                 NotifyType,
+                 DatabaseRecord->PackageList,
+                 &SimpleFontPackage
+                 );
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = InvokeRegisteredFunction (
+                 Private,
+                 NotifyType,
+                 (VOID *) SimpleFontPackage,
+                 (UINT8) (PackageHeader.Type),
+                 DatabaseRecord->Handle
+                 );
+      break;
+    case EFI_HII_PACKAGE_DEVICE_PATH:
+      Status = AddDevicePathPackage (
+                 Private,
+                 NotifyType,
+                 (EFI_DEVICE_PATH_PROTOCOL *) ((UINT8 *) PackageHdrPtr + sizeof (EFI_HII_PACKAGE_HEADER)),
+                 DatabaseRecord
+                 );
+      break;
+    default:
+      break;
+    }
+
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+    //
+    // goto header of next package
+    //
+    PackageHdrPtr = (EFI_HII_PACKAGE_HEADER *) ((UINT8 *) PackageHdrPtr + PackageHeader.Length);
+    CopyMem (&PackageHeader, PackageHdrPtr, sizeof (EFI_HII_PACKAGE_HEADER));
+  }
+  
+  //
+  // Adjust String Package to make sure all string packages have the same max string ID.
+  //
+  if (!EFI_ERROR (Status) && StringPkgIsAdd) {
+    Status = AdjustStringPackage (DatabaseRecord->PackageList);
+  }
+
+  return Status;
+}
+
+
+/**
+  This function exports a package list to a buffer. It is the worker function
+  of HiiExportPackageList.
+
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer has been used by exporting
+                                 package lists when Handle is NULL.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+
+  @retval EFI_SUCCESS            Keyboard Layout Packages are exported
+                                 successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportPackageList (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN OUT UINTN                          *UsedSize,
+  IN UINTN                              BufferSize,
+  OUT EFI_HII_PACKAGE_LIST_HEADER       *Buffer
+  )
+{
+  EFI_STATUS                          Status;
+  UINTN                               ResultSize;
+  EFI_HII_PACKAGE_HEADER              EndofPackageList;
+
+  ASSERT (Private != NULL && PackageList != NULL && UsedSize != NULL);
+  ASSERT (Private->Signature == HII_DATABASE_PRIVATE_DATA_SIGNATURE);
+  ASSERT (IsHiiHandleValid (Handle));
+
+  if (BufferSize > 0 && Buffer == NULL ) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Copy the package list header
+  // ResultSize indicates the length of the exported bytes of this package list
+  //
+  ResultSize = sizeof (EFI_HII_PACKAGE_LIST_HEADER);
+  if (ResultSize + *UsedSize <= BufferSize) {
+    CopyMem ((VOID *) Buffer, PackageList, ResultSize);
+  }
+  //
+  // Copy the packages and invoke EXPORT_PACK notify functions if exists.
+  //
+  Status = ExportGuidPackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportFormPackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportKeyboardLayoutPackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportStringPackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportFontPackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportImagePackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportSimpleFontPackages (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  Status = ExportDevicePathPackage (
+             Private,
+             Handle,
+             PackageList,
+             *UsedSize,
+             BufferSize,
+             (VOID *) ((UINT8 *) Buffer + ResultSize),
+             &ResultSize
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  //
+  // Append the package list end.
+  //
+  EndofPackageList.Length = sizeof (EFI_HII_PACKAGE_HEADER);
+  EndofPackageList.Type   = EFI_HII_PACKAGE_END;
+  if (ResultSize + *UsedSize + sizeof (EFI_HII_PACKAGE_HEADER) <= BufferSize) {
+    CopyMem (
+      (VOID *) ((UINT8 *) Buffer + ResultSize),
+      (VOID *) &EndofPackageList,
+      sizeof (EFI_HII_PACKAGE_HEADER)
+      );
+  }
+
+  *UsedSize += ResultSize + sizeof (EFI_HII_PACKAGE_HEADER);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function adds the packages in the package list to the database and returns a handle. If there is a
+  EFI_DEVICE_PATH_PROTOCOL associated with the DriverHandle, then this function will
+  create a package of type EFI_PACKAGE_TYPE_DEVICE_PATH and add it to the package list.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  PackageList            A pointer to an EFI_HII_PACKAGE_LIST_HEADER
+                                 structure.
+  @param  DriverHandle           Associate the package list with this EFI handle.
+                                 If a NULL is specified, this data will not be associate
+                                 with any drivers and cannot have a callback induced.
+  @param  Handle                 A pointer to the EFI_HII_HANDLE instance.
+
+  @retval EFI_SUCCESS            The package list associated with the Handle was
+                                 added to the HII database.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary resources for the new
+                                 database contents.
+  @retval EFI_INVALID_PARAMETER  PackageList is NULL or Handle is NULL.
+  @retval EFI_INVALID_PARAMETER  PackageListGuid already exists in database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiNewPackageList (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN CONST EFI_HII_PACKAGE_LIST_HEADER  *PackageList,
+  IN CONST EFI_HANDLE                   DriverHandle, OPTIONAL
+  OUT EFI_HII_HANDLE                    *Handle
+  )
+{
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  EFI_DEVICE_PATH_PROTOCOL            *DevicePath;
+  LIST_ENTRY                          *Link;
+  EFI_GUID                            PackageListGuid;
+
+  if (This == NULL || PackageList == NULL || Handle == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  CopyMem (&PackageListGuid, (VOID *) PackageList, sizeof (EFI_GUID));
+
+  //
+  // Check the Package list GUID to guarantee this GUID is unique in database.
+  //
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (CompareGuid (
+          &(DatabaseRecord->PackageList->PackageListHdr.PackageListGuid),
+          &PackageListGuid) && 
+        DatabaseRecord->DriverHandle == DriverHandle) {
+      return EFI_INVALID_PARAMETER;
+    }
+  }
+
+  //
+  // Build a PackageList node
+  //
+  Status = GenerateHiiDatabaseRecord (Private, &DatabaseRecord);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Fill in information of the created Package List node
+  // according to incoming package list.
+  //
+  Status = AddPackages (Private, EFI_HII_DATABASE_NOTIFY_NEW_PACK, PackageList, DatabaseRecord);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  DatabaseRecord->DriverHandle = DriverHandle;
+
+  //
+  // Create a Device path package and add into the package list if exists.
+  //
+  Status = gBS->HandleProtocol (
+                  DriverHandle,
+                  &gEfiDevicePathProtocolGuid,
+                  (VOID **) &DevicePath
+                  );
+  if (!EFI_ERROR (Status)) {
+    Status = AddDevicePathPackage (Private, EFI_HII_DATABASE_NOTIFY_NEW_PACK, DevicePath, DatabaseRecord);
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  *Handle = DatabaseRecord->Handle;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function removes the package list that is associated with a handle Handle
+  from the HII database. Before removing the package, any registered functions
+  with the notification type REMOVE_PACK and the same package type will be called.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  Handle                 The handle that was registered to the data that is
+                                 requested  for removal.
+
+  @retval EFI_SUCCESS            The data associated with the Handle was removed
+                                 from  the HII database.
+  @retval EFI_NOT_FOUND          The specified andle is not in database.
+  @retval EFI_INVALID_PARAMETER  The Handle was not valid.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiRemovePackageList (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                     Handle
+  )
+{
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *Node;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageList;
+  HII_HANDLE                          *HiiHandle;
+
+  if (This == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (Handle)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Get the packagelist to be removed.
+  //
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (Node->Handle == Handle) {
+      PackageList = (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (Node->PackageList);
+      ASSERT (PackageList != NULL);
+
+      //
+      // Call registered functions with REMOVE_PACK before removing packages
+      // then remove them.
+      //
+      Status = RemoveGuidPackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveFormPackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveKeyboardLayoutPackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveStringPackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveFontPackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveImagePackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveSimpleFontPackages (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      Status = RemoveDevicePathPackage (Private, Handle, PackageList);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+
+      //
+      // Free resources of the package list
+      //
+      RemoveEntryList (&Node->DatabaseEntry);
+
+      HiiHandle = (HII_HANDLE *) Handle;
+      RemoveEntryList (&HiiHandle->Handle);
+      Private->HiiHandleCount--;
+      ASSERT (Private->HiiHandleCount >= 0);
+
+      HiiHandle->Signature = 0;
+      FreePool (HiiHandle);
+      FreePool (Node->PackageList);
+      FreePool (Node);
+
+      return EFI_SUCCESS;
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  This function updates the existing package list (which has the specified Handle)
+  in the HII databases, using the new package list specified by PackageList.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  Handle                 The handle that was registered to the data that is
+                                  requested to be updated.
+  @param  PackageList            A pointer to an EFI_HII_PACKAGE_LIST_HEADER
+                                 package.
+
+  @retval EFI_SUCCESS            The HII database was successfully updated.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate enough memory for the updated
+                                 database.
+  @retval EFI_INVALID_PARAMETER  PackageList was NULL.
+  @retval EFI_NOT_FOUND          The specified Handle is not in database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiUpdatePackageList (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                     Handle,
+  IN CONST EFI_HII_PACKAGE_LIST_HEADER  *PackageList
+  )
+{
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *Node;
+  EFI_HII_PACKAGE_HEADER              *PackageHdrPtr;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *OldPackageList;
+  EFI_HII_PACKAGE_HEADER              PackageHeader;
+
+  if (This == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (Handle)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  PackageHdrPtr = (EFI_HII_PACKAGE_HEADER *) ((UINT8 *) PackageList + sizeof (EFI_HII_PACKAGE_LIST_HEADER));
+
+  Status = EFI_SUCCESS;
+
+  //
+  // Get original packagelist to be updated
+  //
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (Node->Handle == Handle) {
+      OldPackageList = Node->PackageList;
+      //
+      // Remove the package if its type matches one of the package types which is
+      // contained in the new package list.
+      //
+      CopyMem (&PackageHeader, PackageHdrPtr, sizeof (EFI_HII_PACKAGE_HEADER));
+      while (PackageHeader.Type != EFI_HII_PACKAGE_END) {
+        switch (PackageHeader.Type) {
+        case EFI_HII_PACKAGE_TYPE_GUID:
+          Status = RemoveGuidPackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_FORMS:
+          Status = RemoveFormPackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_KEYBOARD_LAYOUT:
+          Status = RemoveKeyboardLayoutPackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_STRINGS:
+          Status = RemoveStringPackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_FONTS:
+          Status = RemoveFontPackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_IMAGES:
+          Status = RemoveImagePackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_SIMPLE_FONTS:
+          Status = RemoveSimpleFontPackages (Private, Handle, OldPackageList);
+          break;
+        case EFI_HII_PACKAGE_DEVICE_PATH:
+          Status = RemoveDevicePathPackage (Private, Handle, OldPackageList);
+          break;
+        }
+
+        if (EFI_ERROR (Status)) {
+          return Status;
+        }
+
+        PackageHdrPtr = (EFI_HII_PACKAGE_HEADER *) ((UINT8 *) PackageHdrPtr + PackageHeader.Length);
+        CopyMem (&PackageHeader, PackageHdrPtr, sizeof (EFI_HII_PACKAGE_HEADER));
+      }
+
+      //
+      // Add all of the packages within the new package list
+      //
+      return AddPackages (Private, EFI_HII_DATABASE_NOTIFY_ADD_PACK, PackageList, Node);
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  This function returns a list of the package handles of the specified type
+  that are currently active in the database. The pseudo-type
+  EFI_HII_PACKAGE_TYPE_ALL will cause all package handles to be listed.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  PackageType            Specifies the package type of the packages to list
+                                 or EFI_HII_PACKAGE_TYPE_ALL for all packages to be
+                                 listed.
+  @param  PackageGuid            If PackageType is EFI_HII_PACKAGE_TYPE_GUID, then
+                                 this  is the pointer to the GUID which must match
+                                 the Guid field of EFI_HII_GUID_PACKAGE_GUID_HDR.
+                                 Otherwise,  it must be NULL.
+  @param  HandleBufferLength     On input, a pointer to the length of the handle
+                                 buffer.  On output, the length of the handle
+                                 buffer that is required for the handles found.
+  @param  Handle                 An array of EFI_HII_HANDLE instances returned.
+
+  @retval EFI_SUCCESS            The matching handles are outputed successfully.
+                                               HandleBufferLength is updated with the actual length.
+  @retval EFI_BUFFER_TO_SMALL    The HandleBufferLength parameter indicates that
+                                 Handle is too small to support the number of
+                                 handles. HandleBufferLength is updated with a
+                                 value that will  enable the data to fit.
+  @retval EFI_NOT_FOUND          No matching handle could not be found in database.
+  @retval EFI_INVALID_PARAMETER  Handle or HandleBufferLength was NULL.
+  
+  @retval EFI_INVALID_PARAMETER  PackageType is not a EFI_HII_PACKAGE_TYPE_GUID but
+                                                     PackageGuid is not NULL, PackageType is a EFI_HII_
+                                                     PACKAGE_TYPE_GUID but PackageGuid is NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiListPackageLists (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  UINT8                             PackageType,
+  IN  CONST EFI_GUID                    *PackageGuid,
+  IN  OUT UINTN                         *HandleBufferLength,
+  OUT EFI_HII_HANDLE                    *Handle
+  )
+{
+  HII_GUID_PACKAGE_INSTANCE           *GuidPackage;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *Node;
+  LIST_ENTRY                          *Link;
+  BOOLEAN                             Matched;
+  HII_HANDLE                          **Result;
+  UINTN                               ResultSize;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageList;
+  LIST_ENTRY                          *Link1;
+
+  //
+  // Check input parameters
+  //
+  if (This == NULL || HandleBufferLength == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (*HandleBufferLength > 0 && Handle == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if ((PackageType == EFI_HII_PACKAGE_TYPE_GUID && PackageGuid == NULL) ||
+      (PackageType != EFI_HII_PACKAGE_TYPE_GUID && PackageGuid != NULL)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private    = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  Matched    = FALSE;
+  Result     = (HII_HANDLE **) Handle;
+  ResultSize = 0;
+
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    PackageList = (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (Node->PackageList);
+    switch (PackageType) {
+      case EFI_HII_PACKAGE_TYPE_GUID:
+        for (Link1 = PackageList->GuidPkgHdr.ForwardLink; Link1 != &PackageList->GuidPkgHdr; Link1 = Link1->ForwardLink) {
+          GuidPackage = CR (Link1, HII_GUID_PACKAGE_INSTANCE, GuidEntry, HII_GUID_PACKAGE_SIGNATURE);
+          if (CompareGuid (
+                (EFI_GUID *) PackageGuid,
+                (EFI_GUID *) (GuidPackage->GuidPkg + sizeof (EFI_HII_PACKAGE_HEADER))
+                )) {
+            Matched = TRUE;
+            break;
+          }
+        }
+        break;
+      case EFI_HII_PACKAGE_FORMS:
+        if (!IsListEmpty (&PackageList->FormPkgHdr)) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_HII_PACKAGE_KEYBOARD_LAYOUT:
+        if (!IsListEmpty (&PackageList->KeyboardLayoutHdr)) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_HII_PACKAGE_STRINGS:
+        if (!IsListEmpty (&PackageList->StringPkgHdr)) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_HII_PACKAGE_FONTS:
+        if (!IsListEmpty (&PackageList->FontPkgHdr)) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_HII_PACKAGE_IMAGES:
+        if (PackageList->ImagePkg != NULL) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_HII_PACKAGE_SIMPLE_FONTS:
+        if (!IsListEmpty (&PackageList->SimpleFontPkgHdr)) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_HII_PACKAGE_DEVICE_PATH:
+        if (PackageList->DevicePathPkg != NULL) {
+          Matched = TRUE;
+        }
+        break;
+        //
+        // Pesudo-type EFI_HII_PACKAGE_TYPE_ALL will cause all package handles
+        // to be listed.
+        //
+      case EFI_HII_PACKAGE_TYPE_ALL:
+        Matched = TRUE;
+        break;
+      default:
+        break;
+    }
+
+    //
+    // This active package list has the specified package type, list it.
+    //
+    if (Matched) {
+      ResultSize += sizeof (EFI_HII_HANDLE);
+      if (ResultSize <= *HandleBufferLength) {
+        *Result++ = Node->Handle;
+      }
+    }
+    Matched = FALSE;
+  }
+
+  if (ResultSize == 0) {
+    return EFI_NOT_FOUND;
+  }
+
+  if (*HandleBufferLength < ResultSize) {
+    *HandleBufferLength = ResultSize;
+    return EFI_BUFFER_TOO_SMALL;
+  }
+
+  *HandleBufferLength = ResultSize;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function will export one or all package lists in the database to a buffer.
+  For each package list exported, this function will call functions registered
+  with EXPORT_PACK and then copy the package list to the buffer.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  Handle                 An EFI_HII_HANDLE that corresponds to the desired
+                                 package list in the HII database to export or NULL
+                                 to indicate  all package lists should be exported.
+  @param  BufferSize             On input, a pointer to the length of the buffer.
+                                 On output, the length of the buffer that is
+                                 required for the exported data.
+  @param  Buffer                 A pointer to a buffer that will contain the
+                                 results of  the export function.
+
+  @retval EFI_SUCCESS            Package exported.
+  @retval EFI_BUFFER_TO_SMALL    The HandleBufferLength parameter indicates that
+                                 Handle is too small to support the number of
+                                 handles.      HandleBufferLength is updated with a
+                                 value that will enable the data to fit.
+  @retval EFI_NOT_FOUND          The specifiecd Handle could not be found in the
+                                 current database.
+  @retval EFI_INVALID_PARAMETER  Handle or Buffer or BufferSize was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiExportPackageLists (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                    Handle,
+  IN  OUT UINTN                         *BufferSize,
+  OUT EFI_HII_PACKAGE_LIST_HEADER       *Buffer
+  )
+{
+  LIST_ENTRY                          *Link;
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *Node;
+  UINTN                               UsedSize;
+
+  if (This == NULL || BufferSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (*BufferSize > 0 && Buffer == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if ((Handle != NULL) && (!IsHiiHandleValid (Handle))) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private  = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  UsedSize = 0;
+
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (Handle == NULL) {
+      //
+      // Export all package lists in current hii database.
+      //
+      Status = ExportPackageList (
+                 Private,
+                 Node->Handle,
+                 (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (Node->PackageList),
+                 &UsedSize,
+                 *BufferSize,
+                 (EFI_HII_PACKAGE_LIST_HEADER *)((UINT8 *) Buffer + UsedSize)
+                 );
+      ASSERT_EFI_ERROR (Status);
+    } else if (Handle != NULL && Node->Handle == Handle) {
+      Status = ExportPackageList (
+                 Private,
+                 Handle,
+                 (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (Node->PackageList),
+                 &UsedSize,
+                 *BufferSize,
+                 Buffer
+                 );
+      ASSERT_EFI_ERROR (Status);
+      if (*BufferSize < UsedSize) {
+        *BufferSize = UsedSize;
+        return EFI_BUFFER_TOO_SMALL;
+      }
+      return EFI_SUCCESS;
+    }
+  }
+
+  if (Handle == NULL && UsedSize != 0) {
+    if (*BufferSize < UsedSize) {
+      *BufferSize = UsedSize;
+      return EFI_BUFFER_TOO_SMALL;
+    }
+    return EFI_SUCCESS;
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  This function registers a function which will be called when specified actions related to packages of
+  the specified type occur in the HII database. By registering a function, other HII-related drivers are
+  notified when specific package types are added, removed or updated in the HII database.
+  Each driver or application which registers a notification should use
+  EFI_HII_DATABASE_PROTOCOL.UnregisterPackageNotify() before exiting.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  PackageType            Specifies the package type of the packages to list
+                                 or EFI_HII_PACKAGE_TYPE_ALL for all packages to be
+                                 listed.
+  @param  PackageGuid            If PackageType is EFI_HII_PACKAGE_TYPE_GUID, then
+                                 this is the pointer to the GUID which must match
+                                 the Guid field of
+                                 EFI_HII_GUID_PACKAGE_GUID_HDR. Otherwise, it must
+                                 be NULL.
+  @param  PackageNotifyFn        Points to the function to be called when the event
+                                 specified by
+                                 NotificationType occurs.
+  @param  NotifyType             Describes the types of notification which this
+                                 function will be receiving.
+  @param  NotifyHandle           Points to the unique handle assigned to the
+                                 registered notification. Can be used in
+                                 EFI_HII_DATABASE_PROTOCOL.UnregisterPackageNotify()
+                                 to stop notifications.
+
+  @retval EFI_SUCCESS            Notification registered successfully.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate necessary data structures
+  @retval EFI_INVALID_PARAMETER  NotifyHandle is NULL.
+  @retval EFI_INVALID_PARAMETER  PackageGuid is not NULL when PackageType is not
+                                 EFI_HII_PACKAGE_TYPE_GUID.
+  @retval EFI_INVALID_PARAMETER  PackageGuid is NULL when PackageType is
+                                 EFI_HII_PACKAGE_TYPE_GUID.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiRegisterPackageNotify (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  UINT8                             PackageType,
+  IN  CONST EFI_GUID                    *PackageGuid,
+  IN  CONST EFI_HII_DATABASE_NOTIFY     PackageNotifyFn,
+  IN  EFI_HII_DATABASE_NOTIFY_TYPE      NotifyType,
+  OUT EFI_HANDLE                        *NotifyHandle
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_NOTIFY                 *Notify;
+  EFI_STATUS                          Status;
+
+  if (This == NULL || NotifyHandle == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if ((PackageType == EFI_HII_PACKAGE_TYPE_GUID && PackageGuid == NULL) ||
+      (PackageType != EFI_HII_PACKAGE_TYPE_GUID && PackageGuid != NULL)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Allocate a notification node
+  //
+  Notify = (HII_DATABASE_NOTIFY *) AllocateZeroPool (sizeof (HII_DATABASE_NOTIFY));
+  if (Notify == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // Generate a notify handle
+  //
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &Notify->NotifyHandle,
+                  &gEfiCallerIdGuid,
+                  NULL,
+                  NULL
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Fill in the information to the notification node
+  //
+  Notify->Signature       = HII_DATABASE_NOTIFY_SIGNATURE;
+  Notify->PackageType     = PackageType;
+  Notify->PackageGuid     = (EFI_GUID *) PackageGuid;
+  Notify->PackageNotifyFn = (EFI_HII_DATABASE_NOTIFY) PackageNotifyFn;
+  Notify->NotifyType      = NotifyType;
+
+  InsertTailList (&Private->DatabaseNotifyList, &Notify->DatabaseNotifyEntry);
+  *NotifyHandle = Notify->NotifyHandle;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Removes the specified HII database package-related notification.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  NotificationHandle     The handle of the notification function being
+                                 unregistered.
+
+  @retval EFI_SUCCESS            Notification is unregistered successfully.
+  @retval EFI_INVALID_PARAMETER  The Handle is invalid.
+  @retval EFI_NOT_FOUND          The incoming notification handle does not exist
+                                 in current hii database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiUnregisterPackageNotify (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN EFI_HANDLE                         NotificationHandle
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_NOTIFY                 *Notify;
+  LIST_ENTRY                          *Link;
+  EFI_STATUS                          Status;
+
+  if (This == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (NotificationHandle == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  Status = gBS->OpenProtocol (
+                  NotificationHandle,
+                  &gEfiCallerIdGuid,
+                  NULL,
+                  NULL,
+                  NULL,
+                  EFI_OPEN_PROTOCOL_TEST_PROTOCOL
+                  );
+  if (EFI_ERROR (Status)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  for (Link = Private->DatabaseNotifyList.ForwardLink; Link != &Private->DatabaseNotifyList; Link = Link->ForwardLink) {
+    Notify = CR (Link, HII_DATABASE_NOTIFY, DatabaseNotifyEntry, HII_DATABASE_NOTIFY_SIGNATURE);
+    if (Notify->NotifyHandle == NotificationHandle) {
+      //
+      // Remove the matching notification node
+      //
+      RemoveEntryList (&Notify->DatabaseNotifyEntry);
+      Status = gBS->UninstallMultipleProtocolInterfaces (
+                      Notify->NotifyHandle,
+                      &gEfiCallerIdGuid,
+                      NULL,
+                      NULL
+                      );
+      ASSERT_EFI_ERROR (Status);
+      FreePool (Notify);
+
+      return EFI_SUCCESS;
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  This routine retrieves an array of GUID values for each keyboard layout that
+  was previously registered in the system.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  KeyGuidBufferLength    On input, a pointer to the length of the keyboard
+                                 GUID  buffer. On output, the length of the handle
+                                 buffer  that is required for the handles found.
+  @param  KeyGuidBuffer          An array of keyboard layout GUID instances
+                                 returned.
+
+  @retval EFI_SUCCESS            KeyGuidBuffer was updated successfully.
+  @retval EFI_BUFFER_TOO_SMALL   The KeyGuidBufferLength parameter indicates
+                                 that KeyGuidBuffer is too small to support the
+                                 number of GUIDs. KeyGuidBufferLength is
+                                 updated with a value that will enable the data to
+                                 fit.
+  @retval EFI_INVALID_PARAMETER  The KeyGuidBuffer or KeyGuidBufferLength was NULL.
+  @retval EFI_NOT_FOUND          There was no keyboard layout.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiFindKeyboardLayouts (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  OUT UINT16                        *KeyGuidBufferLength,
+  OUT EFI_GUID                          *KeyGuidBuffer
+  )
+{
+  HII_DATABASE_PRIVATE_DATA            *Private;
+  HII_DATABASE_RECORD                  *Node;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE   *PackageList;
+  LIST_ENTRY                           *Link;
+  LIST_ENTRY                           *Link1;
+  UINT16                               ResultSize;
+  UINTN                                Index;
+  UINT16                               LayoutCount;
+  UINT16                               LayoutLength;
+  UINT8                                *Layout;
+  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *Package;
+
+  if (This == NULL || KeyGuidBufferLength == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (*KeyGuidBufferLength > 0 && KeyGuidBuffer == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private     = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  ResultSize  = 0;
+
+  //
+  // Search all package lists in whole database to retrieve keyboard layout.
+  //
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    PackageList = Node->PackageList;
+    for (Link1 = PackageList->KeyboardLayoutHdr.ForwardLink;
+         Link1 != &PackageList->KeyboardLayoutHdr;
+         Link1 = Link1->ForwardLink
+        ) {
+      //
+      // Find out all Keyboard Layout packages in this package list.
+      //
+      Package = CR (
+                  Link1,
+                  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE,
+                  KeyboardEntry,
+                  HII_KB_LAYOUT_PACKAGE_SIGNATURE
+                  );
+      Layout = (UINT8 *) Package->KeyboardPkg + sizeof (EFI_HII_PACKAGE_HEADER) + sizeof (UINT16);
+      CopyMem (
+        &LayoutCount,
+        (UINT8 *) Package->KeyboardPkg + sizeof (EFI_HII_PACKAGE_HEADER),
+        sizeof (UINT16)
+        );
+      for (Index = 0; Index < LayoutCount; Index++) {
+        ResultSize += sizeof (EFI_GUID);
+        if (ResultSize <= *KeyGuidBufferLength) {
+          CopyMem (KeyGuidBuffer + (ResultSize / sizeof (EFI_GUID) - 1), Layout + sizeof (UINT16), sizeof (EFI_GUID));
+          CopyMem (&LayoutLength, Layout, sizeof (UINT16));
+          Layout = Layout + LayoutLength;
+        }
+      }
+    }
+  }
+
+  if (ResultSize == 0) {
+    return EFI_NOT_FOUND;
+  }
+
+  if (*KeyGuidBufferLength < ResultSize) {
+    *KeyGuidBufferLength = ResultSize;
+    return EFI_BUFFER_TOO_SMALL;
+  }
+
+  *KeyGuidBufferLength = ResultSize;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This routine retrieves the requested keyboard layout. The layout is a physical description of the keys
+  on a keyboard and the character(s) that are associated with a particular set of key strokes.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  KeyGuid                A pointer to the unique ID associated with a given
+                                 keyboard layout. If KeyGuid is NULL then the
+                                 current layout will be retrieved.
+  @param  KeyboardLayoutLength   On input, a pointer to the length of the
+                                 KeyboardLayout buffer.  On output, the length of
+                                 the data placed into KeyboardLayout.
+  @param  KeyboardLayout         A pointer to a buffer containing the retrieved
+                                 keyboard layout.
+
+  @retval EFI_SUCCESS            The keyboard layout was retrieved successfully.
+  @retval EFI_NOT_FOUND          The requested keyboard layout was not found.
+  @retval EFI_INVALID_PARAMETER  The KeyboardLayout or KeyboardLayoutLength was
+                                 NULL.
+  @retval EFI_BUFFER_TOO_SMALL   The KeyboardLayoutLength parameter indicates
+                                 that KeyboardLayout is too small to support the
+                                 requested keyboard layout. KeyboardLayoutLength is
+                                        updated with a value that will enable the
+                                 data to fit.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetKeyboardLayout (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  CONST EFI_GUID                          *KeyGuid,
+  IN OUT UINT16                         *KeyboardLayoutLength,
+  OUT EFI_HII_KEYBOARD_LAYOUT           *KeyboardLayout
+  )
+{
+  HII_DATABASE_PRIVATE_DATA            *Private;
+  HII_DATABASE_RECORD                  *Node;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE   *PackageList;
+  LIST_ENTRY                           *Link;
+  LIST_ENTRY                           *Link1;
+  UINTN                                Index;
+  UINT8                                *Layout;
+  UINT16                               LayoutCount;
+  UINT16                               LayoutLength;
+  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE *Package;
+
+  if (This == NULL || KeyboardLayoutLength == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (*KeyboardLayoutLength > 0 && KeyboardLayout == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  //
+  // Retrieve the current keyboard layout.
+  //
+  if (KeyGuid == NULL) {
+    if (Private->CurrentLayout == NULL) {
+      return EFI_NOT_FOUND;
+    }
+    CopyMem (&LayoutLength, Private->CurrentLayout, sizeof (UINT16));
+    if (*KeyboardLayoutLength < LayoutLength) {
+      *KeyboardLayoutLength = LayoutLength;
+      return EFI_BUFFER_TOO_SMALL;
+    }
+    CopyMem (KeyboardLayout, Private->CurrentLayout, LayoutLength);
+    return EFI_SUCCESS;
+  }
+
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    PackageList = (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (Node->PackageList);
+    for (Link1 = PackageList->KeyboardLayoutHdr.ForwardLink;
+         Link1 != &PackageList->KeyboardLayoutHdr;
+         Link1 = Link1->ForwardLink
+        ) {
+      Package = CR (
+                  Link1,
+                  HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE,
+                  KeyboardEntry,
+                  HII_KB_LAYOUT_PACKAGE_SIGNATURE
+                  );
+
+      Layout = (UINT8 *) Package->KeyboardPkg +
+               sizeof (EFI_HII_PACKAGE_HEADER) + sizeof (UINT16);
+      CopyMem (&LayoutCount, Layout - sizeof (UINT16), sizeof (UINT16));
+      for (Index = 0; Index < LayoutCount; Index++) {
+        CopyMem (&LayoutLength, Layout, sizeof (UINT16));
+        if (CompareMem (Layout + sizeof (UINT16), KeyGuid, sizeof (EFI_GUID)) == 0) {
+          if (LayoutLength <= *KeyboardLayoutLength) {
+            CopyMem (KeyboardLayout, Layout, LayoutLength);
+            return EFI_SUCCESS;
+          } else {
+            *KeyboardLayoutLength = LayoutLength;
+            return EFI_BUFFER_TOO_SMALL;
+          }
+        }
+        Layout = Layout + LayoutLength;
+      }
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  This routine sets the default keyboard layout to the one referenced by KeyGuid. When this routine
+  is called, an event will be signaled of the EFI_HII_SET_KEYBOARD_LAYOUT_EVENT_GUID
+  group type. This is so that agents which are sensitive to the current keyboard layout being changed
+  can be notified of this change.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  KeyGuid                A pointer to the unique ID associated with a given
+                                 keyboard layout.
+
+  @retval EFI_SUCCESS            The current keyboard layout was successfully set.
+  @retval EFI_NOT_FOUND          The referenced keyboard layout was not found, so
+                                 action was taken.
+  @retval EFI_INVALID_PARAMETER  The KeyGuid was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiSetKeyboardLayout (
+  IN CONST EFI_HII_DATABASE_PROTOCOL          *This,
+  IN CONST EFI_GUID                           *KeyGuid
+  )
+{
+  HII_DATABASE_PRIVATE_DATA            *Private;
+  EFI_HII_KEYBOARD_LAYOUT              *KeyboardLayout;
+  UINT16                               KeyboardLayoutLength;
+  EFI_STATUS                           Status;
+
+  if (This == NULL || KeyGuid == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // The specified GUID equals the current keyboard layout GUID,
+  // return directly.
+  //
+  if (CompareGuid (&Private->CurrentLayoutGuid, KeyGuid)) {
+    return EFI_SUCCESS;
+  }
+
+  //
+  // Try to find the incoming keyboard layout data in current database.
+  //
+  KeyboardLayoutLength = 0;
+  KeyboardLayout       = NULL;
+  Status = HiiGetKeyboardLayout (This, KeyGuid, &KeyboardLayoutLength, KeyboardLayout);
+  if (Status != EFI_BUFFER_TOO_SMALL) {
+    return Status;
+  }
+
+  KeyboardLayout = (EFI_HII_KEYBOARD_LAYOUT *) AllocateZeroPool (KeyboardLayoutLength);
+  ASSERT (KeyboardLayout != NULL);
+  Status = HiiGetKeyboardLayout (This, KeyGuid, &KeyboardLayoutLength, KeyboardLayout);
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Backup current keyboard layout.
+  //
+  CopyMem (&Private->CurrentLayoutGuid, KeyGuid, sizeof (EFI_GUID));
+  if (Private->CurrentLayout != NULL) {
+    FreePool(Private->CurrentLayout);
+  }
+  Private->CurrentLayout = KeyboardLayout;
+
+  //
+  // Signal EFI_HII_SET_KEYBOARD_LAYOUT_EVENT_GUID group to notify
+  // current keyboard layout is changed.
+  //
+  Status = gBS->SignalEvent (gHiiKeyboardLayoutChanged);
+  ASSERT_EFI_ERROR (Status);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Return the EFI handle associated with a package list.
+
+  @param  This                   A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                 instance.
+  @param  PackageListHandle      An EFI_HII_HANDLE that corresponds to the desired
+                                 package list in the HIIdatabase.
+  @param  DriverHandle           On return, contains the EFI_HANDLE which was
+                                 registered with the package list in
+                                 NewPackageList().
+
+  @retval EFI_SUCCESS            The DriverHandle was returned successfully.
+  @retval EFI_INVALID_PARAMETER  The PackageListHandle was not valid or
+                                 DriverHandle was NULL.
+  @retval EFI_NOT_FOUND          This PackageList handle can not be found in
+                                 current database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetPackageListHandle (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL         *This,
+  IN  EFI_HII_HANDLE                    PackageListHandle,
+  OUT EFI_HANDLE                        *DriverHandle
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *Node;
+  LIST_ENTRY                          *Link;
+
+  if (This == NULL || DriverHandle == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageListHandle)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (Node->Handle == PackageListHandle) {
+      *DriverHandle = Node->DriverHandle;
+      return EFI_SUCCESS;
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Font.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Font.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Font.c	(working copy)
@@ -0,0 +1,2877 @@
+/** @file
+Implementation for EFI_HII_FONT_PROTOCOL.
+
+
+Copyright (c) 2007 - 2012, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "HiiDatabase.h"
+
+EFI_GRAPHICS_OUTPUT_BLT_PIXEL        mHiiEfiColors[16] = {
+  //
+  // B     G     R
+  //
+  {0x00, 0x00, 0x00, 0x00},  // BLACK
+  {0x98, 0x00, 0x00, 0x00},  // BLUE
+  {0x00, 0x98, 0x00, 0x00},  // GREEN
+  {0x98, 0x98, 0x00, 0x00},  // CYAN
+  {0x00, 0x00, 0x98, 0x00},  // RED
+  {0x98, 0x00, 0x98, 0x00},  // MAGENTA
+  {0x00, 0x98, 0x98, 0x00},  // BROWN
+  {0x98, 0x98, 0x98, 0x00},  // LIGHTGRAY
+  {0x30, 0x30, 0x30, 0x00},  // DARKGRAY - BRIGHT BLACK
+  {0xff, 0x00, 0x00, 0x00},  // LIGHTBLUE
+  {0x00, 0xff, 0x00, 0x00},  // LIGHTGREEN
+  {0xff, 0xff, 0x00, 0x00},  // LIGHTCYAN
+  {0x00, 0x00, 0xff, 0x00},  // LIGHTRED
+  {0xff, 0x00, 0xff, 0x00},  // LIGHTMAGENTA
+  {0x00, 0xff, 0xff, 0x00},  // YELLOW
+  {0xff, 0xff, 0xff, 0x00},  // WHITE
+};
+
+
+/**
+  Insert a character cell information to the list specified by GlyphInfoList.
+
+  This is a internal function.
+
+  @param  CharValue               Unicode character value, which identifies a glyph
+                                  block.
+  @param  GlyphInfoList           HII_GLYPH_INFO list head.
+  @param  Cell                    Incoming character cell information.
+
+  @retval EFI_SUCCESS             Cell information is added to the GlyphInfoList.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+NewCell (
+  IN  CHAR16                         CharValue,
+  IN  LIST_ENTRY                     *GlyphInfoList,
+  IN  EFI_HII_GLYPH_INFO             *Cell
+  )
+{
+  HII_GLYPH_INFO           *GlyphInfo;
+
+  ASSERT (Cell != NULL && GlyphInfoList != NULL);
+
+  GlyphInfo = (HII_GLYPH_INFO *) AllocateZeroPool (sizeof (HII_GLYPH_INFO));
+  if (GlyphInfo == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // GlyphInfoList stores a list of default character cell information, each is
+  // identified by "CharId".
+  //
+  GlyphInfo->Signature = HII_GLYPH_INFO_SIGNATURE;
+  GlyphInfo->CharId    = CharValue;
+  if (Cell->AdvanceX == 0) {
+    Cell->AdvanceX = Cell->Width;
+  }
+  CopyMem (&GlyphInfo->Cell, Cell, sizeof (EFI_HII_GLYPH_INFO));
+  InsertTailList (GlyphInfoList, &GlyphInfo->Entry);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Get a character cell information from the list specified by GlyphInfoList.
+
+  This is a internal function.
+
+  @param  CharValue               Unicode character value, which identifies a glyph
+                                  block.
+  @param  GlyphInfoList           HII_GLYPH_INFO list head.
+  @param  Cell                    Buffer which stores output character cell
+                                  information.
+
+  @retval EFI_SUCCESS             Cell information is added to the GlyphInfoList.
+  @retval EFI_NOT_FOUND           The character info specified by CharValue does
+                                  not exist.
+
+**/
+EFI_STATUS
+GetCell (
+  IN  CHAR16                         CharValue,
+  IN  LIST_ENTRY                     *GlyphInfoList,
+  OUT EFI_HII_GLYPH_INFO             *Cell
+  )
+{
+  HII_GLYPH_INFO           *GlyphInfo;
+  LIST_ENTRY               *Link;
+
+  ASSERT (Cell != NULL && GlyphInfoList != NULL);
+
+  //
+  // Since the EFI_HII_GIBT_DEFAULTS block won't increment CharValueCurrent,
+  // the value of "CharId" of a default character cell which is used for a
+  // EFI_HII_GIBT_GLYPH_DEFAULT or EFI_HII_GIBT_GLYPHS_DEFAULT should be
+  // less or equal to the value of "CharValueCurrent" of this default block.
+  //
+  // For instance, if the CharId of a GlyphInfoList is {1, 3, 7}, a default glyph
+  // with CharValue equals "7" uses the GlyphInfo with CharId = 7;
+  // a default glyph with CharValue equals "6" uses the GlyphInfo with CharId = 3.
+  //
+  for (Link = GlyphInfoList->BackLink; Link != GlyphInfoList; Link = Link->BackLink) {
+    GlyphInfo = CR (Link, HII_GLYPH_INFO, Entry, HII_GLYPH_INFO_SIGNATURE);
+    if (GlyphInfo->CharId <= CharValue) {
+      CopyMem (Cell, &GlyphInfo->Cell, sizeof (EFI_HII_GLYPH_INFO));
+      return EFI_SUCCESS;
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  Convert the glyph for a single character into a bitmap.
+
+  This is a internal function.
+
+  @param  Private                 HII database driver private data.
+  @param  Char                    Character to retrieve.
+  @param  StringInfo              Points to the string font and color information
+                                  or NULL  if the string should use the default
+                                  system font and color.
+  @param  GlyphBuffer             Buffer to store the retrieved bitmap data.
+  @param  Cell                    Points to EFI_HII_GLYPH_INFO structure.
+  @param  Attributes              If not NULL, output the glyph attributes if any.
+
+  @retval EFI_SUCCESS             Glyph bitmap outputted.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate the output buffer GlyphBuffer.
+  @retval EFI_NOT_FOUND           The glyph was unknown can not be found.
+  @retval EFI_INVALID_PARAMETER   Any input parameter is invalid.
+
+**/
+EFI_STATUS
+GetGlyphBuffer (
+  IN  HII_DATABASE_PRIVATE_DATA      *Private,
+  IN  CHAR16                         Char,
+  IN  EFI_FONT_INFO                  *StringInfo,
+  OUT UINT8                          **GlyphBuffer,
+  OUT EFI_HII_GLYPH_INFO             *Cell,
+  OUT UINT8                          *Attributes OPTIONAL
+  )
+{
+  HII_DATABASE_RECORD                *Node;
+  LIST_ENTRY                         *Link;
+  HII_SIMPLE_FONT_PACKAGE_INSTANCE   *SimpleFont;
+  LIST_ENTRY                         *Link1;
+  UINT16                             Index;
+  EFI_NARROW_GLYPH                   Narrow;
+  EFI_WIDE_GLYPH                     Wide;
+  HII_GLOBAL_FONT_INFO               *GlobalFont;
+  UINTN                              HeaderSize;
+  EFI_NARROW_GLYPH                   *NarrowPtr;
+  EFI_WIDE_GLYPH                     *WidePtr;
+
+  if (GlyphBuffer == NULL || Cell == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (Private == NULL || Private->Signature != HII_DATABASE_PRIVATE_DATA_SIGNATURE) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  ZeroMem (Cell, sizeof (EFI_HII_GLYPH_INFO));
+
+  //
+  // If StringInfo is not NULL, it must point to an existing EFI_FONT_INFO rather
+  // than system default font and color.
+  // If NULL, try to find the character in simplified font packages since
+  // default system font is the fixed font (narrow or wide glyph).
+  //
+  if (StringInfo != NULL) {
+    if(!IsFontInfoExisted (Private, StringInfo, NULL, NULL, &GlobalFont)) {
+      return EFI_INVALID_PARAMETER;
+    }
+    if (Attributes != NULL) {
+      *Attributes = PROPORTIONAL_GLYPH;
+    }
+    return FindGlyphBlock (GlobalFont->FontPackage, Char, GlyphBuffer, Cell, NULL);
+  } else {
+    HeaderSize = sizeof (EFI_HII_SIMPLE_FONT_PACKAGE_HDR);
+
+    for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+      Node = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+      for (Link1 = Node->PackageList->SimpleFontPkgHdr.ForwardLink;
+           Link1 != &Node->PackageList->SimpleFontPkgHdr;
+           Link1 = Link1->ForwardLink
+          ) {
+        SimpleFont = CR (Link1, HII_SIMPLE_FONT_PACKAGE_INSTANCE, SimpleFontEntry, HII_S_FONT_PACKAGE_SIGNATURE);
+        //
+        // Search the narrow glyph array
+        //
+        NarrowPtr = (EFI_NARROW_GLYPH *) ((UINT8 *) (SimpleFont->SimpleFontPkgHdr) + HeaderSize);
+        for (Index = 0; Index < SimpleFont->SimpleFontPkgHdr->NumberOfNarrowGlyphs; Index++) {
+          CopyMem (&Narrow, NarrowPtr + Index,sizeof (EFI_NARROW_GLYPH));
+          if (Narrow.UnicodeWeight == Char) {
+            *GlyphBuffer = (UINT8 *) AllocateZeroPool (EFI_GLYPH_HEIGHT);
+            if (*GlyphBuffer == NULL) {
+              return EFI_OUT_OF_RESOURCES;
+            }
+            Cell->Width    = EFI_GLYPH_WIDTH;
+            Cell->Height   = EFI_GLYPH_HEIGHT;
+            Cell->AdvanceX = Cell->Width;
+            CopyMem (*GlyphBuffer, Narrow.GlyphCol1, Cell->Height);
+            if (Attributes != NULL) {
+              *Attributes = (UINT8) (Narrow.Attributes | NARROW_GLYPH);
+            }
+            return EFI_SUCCESS;
+          }
+        }
+        //
+        // Search the wide glyph array
+        //
+        WidePtr = (EFI_WIDE_GLYPH *) (NarrowPtr + SimpleFont->SimpleFontPkgHdr->NumberOfNarrowGlyphs);
+        for (Index = 0; Index < SimpleFont->SimpleFontPkgHdr->NumberOfWideGlyphs; Index++) {
+          CopyMem (&Wide, WidePtr + Index, sizeof (EFI_WIDE_GLYPH));
+          if (Wide.UnicodeWeight == Char) {
+            *GlyphBuffer    = (UINT8 *) AllocateZeroPool (EFI_GLYPH_HEIGHT * 2);
+            if (*GlyphBuffer == NULL) {
+              return EFI_OUT_OF_RESOURCES;
+            }
+            Cell->Width    = EFI_GLYPH_WIDTH * 2;
+            Cell->Height   = EFI_GLYPH_HEIGHT;
+            Cell->AdvanceX = Cell->Width;
+            CopyMem (*GlyphBuffer, Wide.GlyphCol1, EFI_GLYPH_HEIGHT);
+            CopyMem (*GlyphBuffer + EFI_GLYPH_HEIGHT, Wide.GlyphCol2, EFI_GLYPH_HEIGHT);
+            if (Attributes != NULL) {
+              *Attributes = (UINT8) (Wide.Attributes | EFI_GLYPH_WIDE);
+            }
+            return EFI_SUCCESS;
+          }
+        }
+      }
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+/**
+  Convert bitmap data of the glyph to blt structure.
+
+  This is a internal function.
+
+  @param GlyphBuffer     Buffer points to bitmap data of glyph.
+  @param  Foreground     The color of the "on" pixels in the glyph in the
+                         bitmap.
+  @param  Background     The color of the "off" pixels in the glyph in the
+                         bitmap.
+  @param  ImageWidth     Width of the whole image in pixels.
+  @param  RowWidth       The width of the text on the line, in pixels.
+  @param  RowHeight      The height of the line, in pixels.
+  @param  Transparent    If TRUE, the Background color is ignored and all
+                         "off" pixels in the character's drawn wil use the
+                         pixel value from BltBuffer.
+  @param  Origin         On input, points to the origin of the to be
+                         displayed character, on output, points to the
+                         next glyph's origin.
+
+**/
+VOID
+NarrowGlyphToBlt (
+  IN     UINT8                         *GlyphBuffer,
+  IN     EFI_GRAPHICS_OUTPUT_BLT_PIXEL Foreground,
+  IN     EFI_GRAPHICS_OUTPUT_BLT_PIXEL Background,
+  IN     UINT16                        ImageWidth,
+  IN     UINTN                         RowWidth,
+  IN     UINTN                         RowHeight,
+  IN     BOOLEAN                       Transparent,
+  IN OUT EFI_GRAPHICS_OUTPUT_BLT_PIXEL **Origin
+  )
+{
+  UINT8                                Xpos;
+  UINT8                                Ypos;
+  UINT8                                Height;
+  UINT8                                Width;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL        *Buffer;
+
+  ASSERT (GlyphBuffer != NULL && Origin != NULL && *Origin != NULL);
+
+  Height = EFI_GLYPH_HEIGHT;
+  Width  = EFI_GLYPH_WIDTH;
+  
+  //
+  // Move position to the left-top corner of char.
+  //
+  Buffer = *Origin - EFI_GLYPH_HEIGHT * ImageWidth;
+
+  //
+  // Char may be partially displayed when CLIP_X or CLIP_Y is not set. 
+  //
+  if (RowHeight < Height) {
+    Height = (UINT8) RowHeight;
+  }
+  if (RowWidth < Width) {
+    Width = (UINT8) RowWidth;
+  }
+
+  for (Ypos = 0; Ypos < Height; Ypos++) {
+    for (Xpos = 0; Xpos < Width; Xpos++) {
+      if ((GlyphBuffer[Ypos] & (1 << (EFI_GLYPH_WIDTH - Xpos - 1))) != 0) {
+        Buffer[Ypos * ImageWidth + Xpos] = Foreground;
+      } else {
+        if (!Transparent) {
+          Buffer[Ypos * ImageWidth + Xpos] = Background;
+        }
+      }
+    }
+  }
+
+  *Origin = *Origin + EFI_GLYPH_WIDTH;
+}
+
+
+/**
+  Convert bitmap data of the glyph to blt structure.
+
+  This is a internal function.
+
+  @param  GlyphBuffer             Buffer points to bitmap data of glyph.
+  @param  Foreground              The color of the "on" pixels in the glyph in the
+                                  bitmap.
+  @param  Background              The color of the "off" pixels in the glyph in the
+                                  bitmap.
+  @param  ImageWidth              Width of the whole image in pixels.
+  @param  BaseLine                BaseLine in the line.
+  @param  RowWidth                The width of the text on the line, in pixels.
+  @param  RowHeight               The height of the line, in pixels.
+  @param  Transparent             If TRUE, the Background color is ignored and all
+                                  "off" pixels in the character's drawn wil use the
+                                  pixel value from BltBuffer.
+  @param  Cell                    Points to EFI_HII_GLYPH_INFO structure.
+  @param  Attributes              The attribute of incoming glyph in GlyphBuffer.
+  @param  Origin                  On input, points to the origin of the to be
+                                  displayed character, on output, points to the
+                                  next glyph's origin.
+
+
+**/
+VOID
+GlyphToBlt (
+  IN     UINT8                         *GlyphBuffer,
+  IN     EFI_GRAPHICS_OUTPUT_BLT_PIXEL Foreground,
+  IN     EFI_GRAPHICS_OUTPUT_BLT_PIXEL Background,
+  IN     UINT16                        ImageWidth,
+  IN     UINT16                        BaseLine,
+  IN     UINTN                         RowWidth,
+  IN     UINTN                         RowHeight,
+  IN     BOOLEAN                       Transparent,
+  IN     CONST EFI_HII_GLYPH_INFO      *Cell,
+  IN     UINT8                         Attributes,
+  IN OUT EFI_GRAPHICS_OUTPUT_BLT_PIXEL **Origin
+  )
+{
+  UINT16                                Xpos;
+  UINT16                                Ypos;
+  UINT8                                 Data;
+  UINT16                                Index;
+  UINT16                                YposOffset;
+  UINTN                                 OffsetY;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL         *BltBuffer;
+
+  ASSERT (Origin != NULL && *Origin != NULL && Cell != NULL);
+
+  //
+  // Only adjust origin position if char has no bitmap.
+  //
+  if (GlyphBuffer == NULL) {
+    *Origin = *Origin + Cell->AdvanceX;
+    return;
+  }
+  //
+  // Move position to the left-top corner of char.
+  //
+  BltBuffer  = *Origin + Cell->OffsetX - (Cell->OffsetY + Cell->Height) * ImageWidth;
+  YposOffset = (UINT16) (BaseLine - (Cell->OffsetY + Cell->Height));
+
+  //
+  // Since non-spacing key will be printed OR'd with the previous glyph, don't
+  // write 0.
+  //
+  if ((Attributes & EFI_GLYPH_NON_SPACING) == EFI_GLYPH_NON_SPACING) {
+    Transparent = TRUE;
+  }
+
+  //
+  // The glyph's upper left hand corner pixel is the most significant bit of the
+  // first bitmap byte.
+  //
+  for (Ypos = 0; Ypos < Cell->Height && ((UINTN) (Ypos + YposOffset) < RowHeight); Ypos++) {
+    OffsetY = BITMAP_LEN_1_BIT (Cell->Width, Ypos);
+
+    //
+    // All bits in these bytes are meaningful.
+    //
+    for (Xpos = 0; Xpos < Cell->Width / 8; Xpos++) {
+      Data  = *(GlyphBuffer + OffsetY + Xpos);
+      for (Index = 0; Index < 8 && ((UINTN) (Xpos * 8 + Index + Cell->OffsetX) < RowWidth); Index++) {
+        if ((Data & (1 << (8 - Index - 1))) != 0) {
+          BltBuffer[Ypos * ImageWidth + Xpos * 8 + Index] = Foreground;
+        } else {
+          if (!Transparent) {
+            BltBuffer[Ypos * ImageWidth + Xpos * 8 + Index] = Background;
+          }
+        }
+      }
+    }
+
+    if (Cell->Width % 8 != 0) {
+      //
+      // There are some padding bits in this byte. Ignore them.
+      //
+      Data  = *(GlyphBuffer + OffsetY + Xpos);
+      for (Index = 0; Index < Cell->Width % 8 && ((UINTN) (Xpos * 8 + Index + Cell->OffsetX) < RowWidth); Index++) {
+        if ((Data & (1 << (8 - Index - 1))) != 0) {
+          BltBuffer[Ypos * ImageWidth + Xpos * 8 + Index] = Foreground;
+        } else {
+          if (!Transparent) {
+            BltBuffer[Ypos * ImageWidth + Xpos * 8 + Index] = Background;
+          }
+        }
+      }
+    } // end of if (Width % 8...)
+
+  } // end of for (Ypos=0...)
+
+  *Origin = *Origin + Cell->AdvanceX;
+}
+
+
+/**
+  Convert bitmap data of the glyph to blt structure.
+
+  This is a internal function.
+
+  @param  GlyphBuffer             Buffer points to bitmap data of glyph.
+  @param  Foreground              The color of the "on" pixels in the glyph in the
+                                  bitmap.
+  @param  Background              The color of the "off" pixels in the glyph in the
+                                  bitmap.
+  @param  ImageWidth              Width of the whole image in pixels.
+  @param  BaseLine                BaseLine in the line.
+  @param  RowWidth                The width of the text on the line, in pixels.
+  @param  RowHeight               The height of the line, in pixels.
+  @param  Transparent             If TRUE, the Background color is ignored and all
+                                  "off" pixels in the character's drawn wil use the
+                                  pixel value from BltBuffer.
+  @param  Cell                    Points to EFI_HII_GLYPH_INFO structure.
+  @param  Attributes              The attribute of incoming glyph in GlyphBuffer.
+  @param  Origin                  On input, points to the origin of the to be
+                                  displayed character, on output, points to the
+                                  next glyph's origin.
+
+  @return Points to the address of next origin node in BltBuffer.
+
+**/
+VOID
+GlyphToImage (
+  IN     UINT8                         *GlyphBuffer,
+  IN     EFI_GRAPHICS_OUTPUT_BLT_PIXEL Foreground,
+  IN     EFI_GRAPHICS_OUTPUT_BLT_PIXEL Background,
+  IN     UINT16                        ImageWidth,
+  IN     UINT16                        BaseLine,
+  IN     UINTN                         RowWidth,
+  IN     UINTN                         RowHeight,
+  IN     BOOLEAN                       Transparent,
+  IN     CONST EFI_HII_GLYPH_INFO      *Cell,
+  IN     UINT8                         Attributes,
+  IN OUT EFI_GRAPHICS_OUTPUT_BLT_PIXEL **Origin
+  )
+{
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL        *Buffer;
+
+  ASSERT (Origin != NULL && *Origin != NULL && Cell != NULL);
+
+  Buffer = *Origin;
+
+  if ((Attributes & EFI_GLYPH_NON_SPACING) == EFI_GLYPH_NON_SPACING) {
+    //
+    // This character is a non-spacing key, print it OR'd with the previous glyph.
+    // without advancing cursor.
+    //
+    Buffer -= Cell->AdvanceX;
+    GlyphToBlt (
+      GlyphBuffer,
+      Foreground,
+      Background,
+      ImageWidth,
+      BaseLine,
+      RowWidth,
+      RowHeight,
+      Transparent,
+      Cell,
+      Attributes,
+      &Buffer
+      );
+
+  } else if ((Attributes & EFI_GLYPH_WIDE) == EFI_GLYPH_WIDE) {
+    //
+    // This character is wide glyph, i.e. 16 pixels * 19 pixels.
+    // Draw it as two narrow glyphs.
+    //
+    NarrowGlyphToBlt (
+      GlyphBuffer,
+      Foreground,
+      Background,
+      ImageWidth,
+      RowWidth,
+      RowHeight,
+      Transparent,
+      Origin
+      );
+
+    NarrowGlyphToBlt (
+      GlyphBuffer + EFI_GLYPH_HEIGHT,
+      Foreground,
+      Background,
+      ImageWidth,
+      RowWidth,
+      RowHeight,
+      Transparent,
+      Origin
+      );
+
+  } else if ((Attributes & NARROW_GLYPH) == NARROW_GLYPH) {
+    //
+    // This character is narrow glyph, i.e. 8 pixels * 19 pixels.
+    //
+    NarrowGlyphToBlt (
+      GlyphBuffer,
+      Foreground,
+      Background,
+      ImageWidth,
+      RowWidth,
+      RowHeight,
+      Transparent,
+      Origin
+      );
+
+  } else if ((Attributes & PROPORTIONAL_GLYPH) == PROPORTIONAL_GLYPH) {
+    //
+    // This character is proportional glyph, i.e. Cell->Width * Cell->Height pixels.
+    //
+    GlyphToBlt (
+      GlyphBuffer,
+      Foreground,
+      Background,
+      ImageWidth,
+      BaseLine,
+      RowWidth,
+      RowHeight,
+      Transparent,
+      Cell,
+      Attributes,
+      Origin
+      );
+  }
+}
+
+
+/**
+  Write the output parameters of FindGlyphBlock().
+
+  This is a internal function.
+
+  @param  BufferIn                Buffer which stores the bitmap data of the found
+                                  block.
+  @param  BufferLen               Length of BufferIn.
+  @param  InputCell               Buffer which stores cell information of the
+                                  encoded bitmap.
+  @param  GlyphBuffer             Output the corresponding bitmap data of the found
+                                  block. It is the caller's responsiblity to free
+                                  this buffer.
+  @param  Cell                    Output cell information of the encoded bitmap.
+  @param  GlyphBufferLen          If not NULL, output the length of GlyphBuffer.
+
+  @retval EFI_SUCCESS             The operation is performed successfully.
+  @retval EFI_INVALID_PARAMETER   Any input parameter is invalid.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+WriteOutputParam (
+  IN  UINT8                          *BufferIn,
+  IN  UINTN                          BufferLen,
+  IN  EFI_HII_GLYPH_INFO             *InputCell,
+  OUT UINT8                          **GlyphBuffer, OPTIONAL
+  OUT EFI_HII_GLYPH_INFO             *Cell, OPTIONAL
+  OUT UINTN                          *GlyphBufferLen OPTIONAL
+  )
+{
+  if (BufferIn == NULL || InputCell == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (Cell != NULL) {
+    CopyMem (Cell, InputCell, sizeof (EFI_HII_GLYPH_INFO));
+  }
+
+  if (GlyphBuffer != NULL && BufferLen > 0) {
+    *GlyphBuffer = (UINT8 *) AllocateZeroPool (BufferLen);
+    if (*GlyphBuffer == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    CopyMem (*GlyphBuffer, BufferIn, BufferLen);
+  }
+
+  if (GlyphBufferLen != NULL) {
+    *GlyphBufferLen = BufferLen;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Parse all glyph blocks to find a glyph block specified by CharValue.
+  If CharValue = (CHAR16) (-1), collect all default character cell information
+  within this font package and backup its information.
+
+  @param  FontPackage             Hii string package instance.
+  @param  CharValue               Unicode character value, which identifies a glyph
+                                  block.
+  @param  GlyphBuffer             Output the corresponding bitmap data of the found
+                                  block. It is the caller's responsiblity to free
+                                  this buffer.
+  @param  Cell                    Output cell information of the encoded bitmap.
+  @param  GlyphBufferLen          If not NULL, output the length of GlyphBuffer.
+
+  @retval EFI_SUCCESS             The bitmap data is retrieved successfully.
+  @retval EFI_NOT_FOUND           The specified CharValue does not exist in current
+                                  database.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+FindGlyphBlock (
+  IN  HII_FONT_PACKAGE_INSTANCE      *FontPackage,
+  IN  CHAR16                         CharValue,
+  OUT UINT8                          **GlyphBuffer, OPTIONAL
+  OUT EFI_HII_GLYPH_INFO             *Cell, OPTIONAL
+  OUT UINTN                          *GlyphBufferLen OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  UINT8                               *BlockPtr;
+  UINT16                              CharCurrent;
+  UINT16                              Length16;
+  UINT32                              Length32;
+  EFI_HII_GIBT_GLYPHS_BLOCK           Glyphs;
+  UINTN                               BufferLen;
+  UINT16                              Index;
+  EFI_HII_GLYPH_INFO                  DefaultCell;
+  EFI_HII_GLYPH_INFO                  LocalCell;
+  INT16                               MinOffsetY;
+  UINT16                              BaseLine;
+
+  ASSERT (FontPackage != NULL);
+  ASSERT (FontPackage->Signature == HII_FONT_PACKAGE_SIGNATURE);
+  BaseLine  = 0;
+  MinOffsetY = 0;
+  
+  if (CharValue == (CHAR16) (-1)) {
+    //
+    // Collect the cell information specified in font package fixed header.
+    // Use CharValue =0 to represent this particular cell.
+    //
+    Status = NewCell (
+               0,
+               &FontPackage->GlyphInfoList,
+               (EFI_HII_GLYPH_INFO *) ((UINT8 *) FontPackage->FontPkgHdr + 3 * sizeof (UINT32))
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+    CopyMem (
+      &LocalCell,
+      (UINT8 *) FontPackage->FontPkgHdr + 3 * sizeof (UINT32),
+      sizeof (EFI_HII_GLYPH_INFO)
+      );
+    BaseLine = (UINT16) (LocalCell.Height + LocalCell.OffsetY);
+    if (MinOffsetY > LocalCell.OffsetY) {
+      MinOffsetY = LocalCell.OffsetY;
+    }
+  }
+
+  BlockPtr    = FontPackage->GlyphBlock;
+  CharCurrent = 1;
+  BufferLen   = 0;
+
+  while (*BlockPtr != EFI_HII_GIBT_END) {
+    switch (*BlockPtr) {
+    case EFI_HII_GIBT_DEFAULTS:
+      //
+      // Collect all default character cell information specified by
+      // EFI_HII_GIBT_DEFAULTS.
+      //
+      if (CharValue == (CHAR16) (-1)) {
+        Status = NewCell (
+                   CharCurrent,
+                   &FontPackage->GlyphInfoList,
+                   (EFI_HII_GLYPH_INFO *) (BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK))
+                   );
+        if (EFI_ERROR (Status)) {
+          return Status;
+        }
+        CopyMem (
+          &LocalCell,
+          BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK),
+          sizeof (EFI_HII_GLYPH_INFO)
+          );
+        if (BaseLine < LocalCell.Height + LocalCell.OffsetY) {
+          BaseLine = (UINT16) (LocalCell.Height + LocalCell.OffsetY);
+        }
+        if (MinOffsetY > LocalCell.OffsetY) {
+          MinOffsetY = LocalCell.OffsetY;
+        }
+      }
+      BlockPtr += sizeof (EFI_HII_GIBT_DEFAULTS_BLOCK);
+      break;
+
+    case EFI_HII_GIBT_DUPLICATE:
+      if (CharCurrent == CharValue) {
+        CopyMem (&CharValue, BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK), sizeof (CHAR16));
+        CharCurrent = 1;
+        BlockPtr    = FontPackage->GlyphBlock;
+        continue;
+      }
+      CharCurrent++;
+      BlockPtr += sizeof (EFI_HII_GIBT_DUPLICATE_BLOCK);
+      break;
+
+    case EFI_HII_GIBT_EXT1:
+      BlockPtr += *(BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK) + sizeof (UINT8));
+      break;
+    case EFI_HII_GIBT_EXT2:
+      CopyMem (
+        &Length16,
+        BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK) + sizeof (UINT8),
+        sizeof (UINT16)
+        );
+      BlockPtr += Length16;
+      break;
+    case EFI_HII_GIBT_EXT4:
+      CopyMem (
+        &Length32,
+        BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK) + sizeof (UINT8),
+        sizeof (UINT32)
+        );
+      BlockPtr += Length32;
+      break;
+
+    case EFI_HII_GIBT_GLYPH:
+      CopyMem (
+        &LocalCell,
+        BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK),
+        sizeof (EFI_HII_GLYPH_INFO)
+        );
+      if (CharValue == (CHAR16) (-1)) {
+        if (BaseLine < LocalCell.Height + LocalCell.OffsetY) {
+          BaseLine = (UINT16) (LocalCell.Height + LocalCell.OffsetY);
+        }
+        if (MinOffsetY > LocalCell.OffsetY) {
+          MinOffsetY = LocalCell.OffsetY;
+        }
+      }
+      BufferLen = BITMAP_LEN_1_BIT (LocalCell.Width, LocalCell.Height);
+      if (CharCurrent == CharValue) {
+        return WriteOutputParam (
+                 BlockPtr + sizeof (EFI_HII_GIBT_GLYPH_BLOCK) - sizeof (UINT8),
+                 BufferLen,
+                 &LocalCell,
+                 GlyphBuffer,
+                 Cell,
+                 GlyphBufferLen
+                 );
+      }
+      CharCurrent++;
+      BlockPtr += sizeof (EFI_HII_GIBT_GLYPH_BLOCK) - sizeof (UINT8) + BufferLen;
+      break;
+
+    case EFI_HII_GIBT_GLYPHS:
+      BlockPtr += sizeof (EFI_HII_GLYPH_BLOCK);
+      CopyMem (&Glyphs.Cell, BlockPtr, sizeof (EFI_HII_GLYPH_INFO));
+      BlockPtr += sizeof (EFI_HII_GLYPH_INFO);
+      CopyMem (&Glyphs.Count, BlockPtr, sizeof (UINT16));
+      BlockPtr += sizeof (UINT16);
+
+      if (CharValue == (CHAR16) (-1)) {
+        if (BaseLine < Glyphs.Cell.Height + Glyphs.Cell.OffsetY) {
+          BaseLine = (UINT16) (Glyphs.Cell.Height + Glyphs.Cell.OffsetY);
+        }
+        if (MinOffsetY > Glyphs.Cell.OffsetY) {
+          MinOffsetY = Glyphs.Cell.OffsetY;
+        }
+      }
+
+      BufferLen = BITMAP_LEN_1_BIT (Glyphs.Cell.Width, Glyphs.Cell.Height);
+      for (Index = 0; Index < Glyphs.Count; Index++) {
+        if (CharCurrent + Index == CharValue) {
+          return WriteOutputParam (
+                   BlockPtr,
+                   BufferLen,
+                   &Glyphs.Cell,
+                   GlyphBuffer,
+                   Cell,
+                   GlyphBufferLen
+                   );
+        }
+        BlockPtr += BufferLen;
+      }
+      CharCurrent = (UINT16) (CharCurrent + Glyphs.Count);
+      break;
+
+    case EFI_HII_GIBT_GLYPH_DEFAULT:
+      Status = GetCell (CharCurrent, &FontPackage->GlyphInfoList, &DefaultCell);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      BufferLen = BITMAP_LEN_1_BIT (DefaultCell.Width, DefaultCell.Height);
+
+      if (CharCurrent == CharValue) {
+        return WriteOutputParam (
+                 BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK),
+                 BufferLen,
+                 &DefaultCell,
+                 GlyphBuffer,
+                 Cell,
+                 GlyphBufferLen
+                 );
+      }
+      CharCurrent++;
+      BlockPtr += sizeof (EFI_HII_GLYPH_BLOCK) + BufferLen;
+      break;
+
+    case EFI_HII_GIBT_GLYPHS_DEFAULT:
+      CopyMem (&Length16, BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK), sizeof (UINT16));
+      Status = GetCell (CharCurrent, &FontPackage->GlyphInfoList, &DefaultCell);
+      if (EFI_ERROR (Status)) {
+        return Status;
+      }
+      BufferLen = BITMAP_LEN_1_BIT (DefaultCell.Width, DefaultCell.Height);
+      BlockPtr += sizeof (EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK) - sizeof (UINT8);
+      for (Index = 0; Index < Length16; Index++) {
+        if (CharCurrent + Index == CharValue) {
+          return WriteOutputParam (
+                   BlockPtr,
+                   BufferLen,
+                   &DefaultCell,
+                   GlyphBuffer,
+                   Cell,
+                   GlyphBufferLen
+                   );
+        }
+        BlockPtr += BufferLen;
+      }
+      CharCurrent = (UINT16) (CharCurrent + Length16);
+      break;
+
+    case EFI_HII_GIBT_SKIP1:
+      CharCurrent = (UINT16) (CharCurrent + (UINT16) (*(BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK))));
+      BlockPtr    += sizeof (EFI_HII_GIBT_SKIP1_BLOCK);
+      break;
+    case EFI_HII_GIBT_SKIP2:
+      CopyMem (&Length16, BlockPtr + sizeof (EFI_HII_GLYPH_BLOCK), sizeof (UINT16));
+      CharCurrent = (UINT16) (CharCurrent + Length16);
+      BlockPtr    += sizeof (EFI_HII_GIBT_SKIP2_BLOCK);
+      break;
+    default:
+      ASSERT (FALSE);
+      break;
+    }
+
+    if (CharValue < CharCurrent) {
+      return EFI_NOT_FOUND;
+    }
+  }
+
+  if (CharValue == (CHAR16) (-1)) {
+    FontPackage->BaseLine = BaseLine;
+    FontPackage->Height   = (UINT16) (BaseLine - MinOffsetY);
+    return EFI_SUCCESS;
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  Copy a Font Name to a new created EFI_FONT_INFO structure.
+
+  This is a internal function.
+
+  @param  FontName                NULL-terminated string.
+  @param  FontInfo                a new EFI_FONT_INFO which stores the FontName.
+                                  It's caller's responsibility to free this buffer.
+
+  @retval EFI_SUCCESS             FontInfo is allocated and copied with FontName.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+SaveFontName (
+  IN  EFI_STRING                       FontName,
+  OUT EFI_FONT_INFO                    **FontInfo
+  )
+{
+  UINTN         FontInfoLen;
+
+  ASSERT (FontName != NULL && FontInfo != NULL);
+
+  FontInfoLen = sizeof (EFI_FONT_INFO) - sizeof (CHAR16) + StrSize (FontName);
+  *FontInfo = (EFI_FONT_INFO *) AllocateZeroPool (FontInfoLen);
+  if (*FontInfo == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  StrCpy ((*FontInfo)->FontName, FontName);
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Retrieve system default font and color.
+
+  @param  Private                 HII database driver private data.
+  @param  FontInfo                Points to system default font output-related
+                                  information. It's caller's responsibility to free
+                                  this buffer.
+  @param  FontInfoSize            If not NULL, output the size of buffer FontInfo.
+
+  @retval EFI_SUCCESS             Cell information is added to the GlyphInfoList.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+  @retval EFI_INVALID_PARAMETER   Any input parameter is invalid.
+
+**/
+EFI_STATUS
+GetSystemFont (
+  IN  HII_DATABASE_PRIVATE_DATA      *Private,
+  OUT EFI_FONT_DISPLAY_INFO          **FontInfo,
+  OUT UINTN                          *FontInfoSize OPTIONAL
+  )
+{
+  EFI_FONT_DISPLAY_INFO              *Info;
+  UINTN                              InfoSize;
+
+  if (Private == NULL || Private->Signature != HII_DATABASE_PRIVATE_DATA_SIGNATURE) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (FontInfo == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // The standard font always has the name "sysdefault".
+  //
+  InfoSize = sizeof (EFI_FONT_DISPLAY_INFO) - sizeof (CHAR16) + StrSize (L"sysdefault");
+  Info = (EFI_FONT_DISPLAY_INFO *) AllocateZeroPool (InfoSize);
+  if (Info == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  Info->ForegroundColor    = mHiiEfiColors[Private->Attribute & 0x0f];
+  Info->BackgroundColor    = mHiiEfiColors[Private->Attribute >> 4];
+  Info->FontInfoMask       = EFI_FONT_INFO_SYS_FONT | EFI_FONT_INFO_SYS_SIZE | EFI_FONT_INFO_SYS_STYLE;
+  Info->FontInfo.FontStyle = 0;
+  Info->FontInfo.FontSize  = EFI_GLYPH_HEIGHT;
+  StrCpy (Info->FontInfo.FontName, L"sysdefault");
+
+  *FontInfo = Info;
+  if (FontInfoSize != NULL) {
+    *FontInfoSize = InfoSize;
+  }
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Check whether EFI_FONT_DISPLAY_INFO points to system default font and color or
+  returns the system default according to the optional inputs.
+
+  This is a internal function.
+
+  @param  Private                 HII database driver private data.
+  @param  StringInfo              Points to the string output information,
+                                  including the color and font.
+  @param  SystemInfo              If not NULL, points to system default font and color.
+
+  @param  SystemInfoLen           If not NULL, output the length of default system
+                                  info.
+
+  @retval TRUE                    Yes, it points to system default.
+  @retval FALSE                   No.
+
+**/
+BOOLEAN
+IsSystemFontInfo (
+  IN  HII_DATABASE_PRIVATE_DATA      *Private,
+  IN  EFI_FONT_DISPLAY_INFO          *StringInfo,
+  OUT EFI_FONT_DISPLAY_INFO          **SystemInfo, OPTIONAL
+  OUT UINTN                          *SystemInfoLen OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  EFI_FONT_DISPLAY_INFO               *SystemDefault;
+  UINTN                               DefaultLen;
+  BOOLEAN                             Flag;
+
+  ASSERT (Private != NULL && Private->Signature == HII_DATABASE_PRIVATE_DATA_SIGNATURE);
+
+  if (StringInfo == NULL && SystemInfo == NULL) {
+    return TRUE;
+  }
+
+  Status = GetSystemFont (Private, &SystemDefault, &DefaultLen);
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Record the system default info.
+  //
+  if (SystemInfo != NULL) {
+    *SystemInfo = SystemDefault;
+  }
+
+  if (SystemInfoLen != NULL) {
+    *SystemInfoLen = DefaultLen;
+  }
+
+  if (StringInfo == NULL) {
+    return TRUE;
+  }
+
+  Flag = FALSE;
+  //
+  // Check the FontInfoMask to see whether it is retrieving system info.
+  //
+  if ((StringInfo->FontInfoMask & (EFI_FONT_INFO_SYS_FONT | EFI_FONT_INFO_ANY_FONT)) == 0) {
+    if (StrCmp (StringInfo->FontInfo.FontName, SystemDefault->FontInfo.FontName) != 0) {
+      goto Exit;
+    }
+  }
+  if ((StringInfo->FontInfoMask & (EFI_FONT_INFO_SYS_SIZE | EFI_FONT_INFO_ANY_SIZE)) == 0) {
+    if (StringInfo->FontInfo.FontSize != SystemDefault->FontInfo.FontSize) {
+      goto Exit;
+    }
+  }
+  if ((StringInfo->FontInfoMask & (EFI_FONT_INFO_SYS_STYLE | EFI_FONT_INFO_ANY_STYLE)) == 0) {
+    if (StringInfo->FontInfo.FontStyle != SystemDefault->FontInfo.FontStyle) {
+      goto Exit;
+    }
+  }
+  if ((StringInfo->FontInfoMask & EFI_FONT_INFO_SYS_FORE_COLOR) == 0) {
+    if (CompareMem (
+          &StringInfo->ForegroundColor, 
+          &SystemDefault->ForegroundColor, 
+          sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
+          ) != 0) {
+      goto Exit;
+    }
+  }
+  if ((StringInfo->FontInfoMask & EFI_FONT_INFO_SYS_BACK_COLOR) == 0) {
+    if (CompareMem (
+          &StringInfo->BackgroundColor, 
+          &SystemDefault->BackgroundColor, 
+          sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL)
+          ) != 0) {
+      goto Exit;
+    }
+  }
+
+  Flag = TRUE;
+
+Exit:
+  if (SystemInfo == NULL) {
+    if (SystemDefault != NULL) {
+      FreePool (SystemDefault);
+    }
+  }
+  return Flag;
+}
+
+
+/**
+  This function checks whether EFI_FONT_INFO exists in current database. If
+  FontInfoMask is specified, check what options can be used to make a match.
+  Note that the masks relate to where the system default should be supplied
+  are ignored by this function.
+
+  @param  Private                 Hii database private structure.
+  @param  FontInfo                Points to EFI_FONT_INFO structure.
+  @param  FontInfoMask            If not NULL, describes what options can be used
+                                  to make a match between the font requested and
+                                  the font available. The caller must guarantee
+                                  this mask is valid.
+  @param  FontHandle              On entry, Points to the font handle returned by a
+                                  previous  call to GetFontInfo() or NULL to start
+                                  with the first font.
+  @param  GlobalFontInfo          If not NULL, output the corresponding globa font
+                                  info.
+
+  @retval TRUE                    Existed
+  @retval FALSE                   Not existed
+
+**/
+BOOLEAN
+IsFontInfoExisted (
+  IN  HII_DATABASE_PRIVATE_DATA *Private,
+  IN  EFI_FONT_INFO             *FontInfo,
+  IN  EFI_FONT_INFO_MASK        *FontInfoMask,   OPTIONAL
+  IN  EFI_FONT_HANDLE           FontHandle,      OPTIONAL
+  OUT HII_GLOBAL_FONT_INFO      **GlobalFontInfo OPTIONAL
+  )
+{
+  HII_GLOBAL_FONT_INFO          *GlobalFont;
+  HII_GLOBAL_FONT_INFO          *GlobalFontBackup1;
+  HII_GLOBAL_FONT_INFO          *GlobalFontBackup2;
+  LIST_ENTRY                    *Link;
+  EFI_FONT_INFO_MASK            Mask;
+  BOOLEAN                       Matched;
+  BOOLEAN                       VagueMatched1;
+  BOOLEAN                       VagueMatched2;
+
+  ASSERT (Private != NULL && Private->Signature == HII_DATABASE_PRIVATE_DATA_SIGNATURE);
+  ASSERT (FontInfo != NULL);
+
+  //
+  // Matched flag represents an exactly match; VagueMatched1 repensents a RESIZE
+  // or RESTYLE match; VagueMatched2 represents a RESIZE | RESTYLE match.
+  //
+  Matched           = FALSE;
+  VagueMatched1     = FALSE;
+  VagueMatched2     = FALSE;
+
+  Mask              = 0;
+  GlobalFontBackup1 = NULL;
+  GlobalFontBackup2 = NULL;
+
+  // The process of where the system default should be supplied instead of
+  // the specified font info beyonds this function's scope.
+  //
+  if (FontInfoMask != NULL) {
+    Mask = *FontInfoMask & (~SYS_FONT_INFO_MASK);
+  }
+
+  //
+  // If not NULL, FontHandle points to the next node of the last searched font
+  // node by previous call.
+  //
+  if (FontHandle == NULL) {
+    Link = Private->FontInfoList.ForwardLink;
+  } else {
+    Link = (LIST_ENTRY     *) FontHandle;
+  }
+
+  for (; Link != &Private->FontInfoList; Link = Link->ForwardLink) {
+    GlobalFont = CR (Link, HII_GLOBAL_FONT_INFO, Entry, HII_GLOBAL_FONT_INFO_SIGNATURE);
+    if (FontInfoMask == NULL) {
+      if (CompareMem (GlobalFont->FontInfo, FontInfo, GlobalFont->FontInfoSize) == 0) {
+        if (GlobalFontInfo != NULL) {
+          *GlobalFontInfo = GlobalFont;
+        }
+        return TRUE;
+      }
+    } else {
+      //
+      // Check which options could be used to make a match.
+      //
+      switch (Mask) {
+      case EFI_FONT_INFO_ANY_FONT:
+        if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle &&
+            GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_ANY_STYLE:
+        if (GlobalFont->FontInfo->FontSize == FontInfo->FontSize) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_ANY_SIZE:
+        if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_ANY_SIZE | EFI_FONT_INFO_ANY_STYLE:
+        Matched   = TRUE;
+        break;
+      //
+      // If EFI_FONT_INFO_RESTYLE is specified, then the system may attempt to
+      // remove some of the specified styles to meet the style requested.
+      //
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_RESTYLE:
+        if (GlobalFont->FontInfo->FontSize == FontInfo->FontSize) {
+          if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+            Matched           = TRUE;
+          } else if ((GlobalFont->FontInfo->FontStyle & FontInfo->FontStyle) == FontInfo->FontStyle) {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        }
+        break;
+      //
+      // If EFI_FONT_INFO_RESIZE is specified, then the sytem may attempt to
+      // stretch or shrink a font to meet the size requested.
+      //
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_RESIZE:
+        if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+          if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+            Matched           = TRUE;
+          } else {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        }
+        break;
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_RESTYLE | EFI_FONT_INFO_RESIZE:
+        if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+          if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+            Matched           = TRUE;
+          } else {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        } else if ((GlobalFont->FontInfo->FontStyle & FontInfo->FontStyle) == FontInfo->FontStyle) {
+          if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          } else {
+            VagueMatched2     = TRUE;
+            GlobalFontBackup2 = GlobalFont;
+          }
+        }
+        break;
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_ANY_STYLE | EFI_FONT_INFO_RESIZE:
+        if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+          Matched           = TRUE;
+        } else {
+          VagueMatched1     = TRUE;
+          GlobalFontBackup1 = GlobalFont;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_FONT | EFI_FONT_INFO_ANY_SIZE | EFI_FONT_INFO_RESTYLE:
+        if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+          Matched           = TRUE;
+        } else if ((GlobalFont->FontInfo->FontStyle & FontInfo->FontStyle) == FontInfo->FontStyle) {
+          VagueMatched1     = TRUE;
+          GlobalFontBackup1 = GlobalFont;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_STYLE:
+        if ((CompareMem (
+               GlobalFont->FontInfo->FontName,
+               FontInfo->FontName,
+               StrSize (FontInfo->FontName)
+               ) == 0) &&
+            GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_STYLE | EFI_FONT_INFO_ANY_SIZE:
+        if (CompareMem (
+              GlobalFont->FontInfo->FontName,
+              FontInfo->FontName,
+              StrSize (FontInfo->FontName)
+              ) == 0) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_STYLE | EFI_FONT_INFO_RESIZE:
+        if (CompareMem (
+              GlobalFont->FontInfo->FontName,
+              FontInfo->FontName,
+              StrSize (FontInfo->FontName)
+              ) == 0) {
+          if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+            Matched           = TRUE;
+          } else {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        }
+        break;
+      case EFI_FONT_INFO_ANY_SIZE:
+        if ((CompareMem (
+               GlobalFont->FontInfo->FontName,
+               FontInfo->FontName,
+               StrSize (FontInfo->FontName)
+               ) == 0) &&
+            GlobalFont->FontInfo->FontStyle  == FontInfo->FontStyle) {
+          Matched = TRUE;
+        }
+        break;
+      case EFI_FONT_INFO_ANY_SIZE | EFI_FONT_INFO_RESTYLE:
+        if (CompareMem (
+              GlobalFont->FontInfo->FontName,
+              FontInfo->FontName,
+              StrSize (FontInfo->FontName)
+              ) == 0) {
+          if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+            Matched           = TRUE;
+          } else if ((GlobalFont->FontInfo->FontStyle & FontInfo->FontStyle) == FontInfo->FontStyle) {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        }
+        break;
+      case EFI_FONT_INFO_RESTYLE:
+        if ((CompareMem (
+               GlobalFont->FontInfo->FontName,
+               FontInfo->FontName,
+               StrSize (FontInfo->FontName)
+               ) == 0) &&
+            GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+
+          if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+            Matched           = TRUE;
+          } else if ((GlobalFont->FontInfo->FontStyle & FontInfo->FontStyle) == FontInfo->FontStyle) {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        }
+        break;
+      case EFI_FONT_INFO_RESIZE:
+        if ((CompareMem (
+               GlobalFont->FontInfo->FontName,
+               FontInfo->FontName,
+               StrSize (FontInfo->FontName)
+               ) == 0) &&
+            GlobalFont->FontInfo->FontStyle  == FontInfo->FontStyle) {
+
+          if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+            Matched           = TRUE;
+          } else {
+            VagueMatched1     = TRUE;
+            GlobalFontBackup1 = GlobalFont;
+          }
+        }
+        break;
+      case EFI_FONT_INFO_RESIZE | EFI_FONT_INFO_RESTYLE:
+        if (CompareMem (
+              GlobalFont->FontInfo->FontName,
+              FontInfo->FontName,
+              StrSize (FontInfo->FontName)
+              ) == 0) {
+          if (GlobalFont->FontInfo->FontStyle == FontInfo->FontStyle) {
+            if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+              Matched           = TRUE;
+            } else {
+              VagueMatched1     = TRUE;
+              GlobalFontBackup1 = GlobalFont;
+            }
+          } else if ((GlobalFont->FontInfo->FontStyle & FontInfo->FontStyle) == FontInfo->FontStyle) {
+            if (GlobalFont->FontInfo->FontSize  == FontInfo->FontSize) {
+              VagueMatched1     = TRUE;
+              GlobalFontBackup1 = GlobalFont;
+            } else {
+              VagueMatched2     = TRUE;
+              GlobalFontBackup2 = GlobalFont;
+            }
+          }
+        }
+        break;
+      default:
+        break;
+      }
+
+      if (Matched) {
+        if (GlobalFontInfo != NULL) {
+          *GlobalFontInfo = GlobalFont;
+        }
+        return TRUE;
+      }
+    }
+  }
+
+  if (VagueMatched1) {
+    if (GlobalFontInfo != NULL) {
+      *GlobalFontInfo = GlobalFontBackup1;
+    }
+    return TRUE;
+  } else if (VagueMatched2) {
+    if (GlobalFontInfo != NULL) {
+      *GlobalFontInfo = GlobalFontBackup2;
+    }
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+
+/**
+  Check whether the unicode represents a line break or not.
+
+  This is a internal function. Please see Section 27.2.6 of the UEFI Specification
+  for a description of the supported string format.
+
+  @param  Char                    Unicode character
+
+  @retval 0                       Yes, it forces a line break.
+  @retval 1                       Yes, it presents a line break opportunity
+  @retval 2                       Yes, it requires a line break happen before and after it.
+  @retval -1                      No, it is not a link break.
+
+**/
+INT8
+IsLineBreak (
+  IN  CHAR16    Char
+  )
+{
+  switch (Char) {
+    //
+    // Mandatory line break characters, which force a line-break
+    //
+    case 0x000C:
+    case 0x000D:
+    case 0x2028:
+    case 0x2029:
+      return 0;
+    //
+    // Space characters, which is taken as a line-break opportunity
+    //
+    case 0x0020:
+    case 0x1680:
+    case 0x2000:
+    case 0x2001:
+    case 0x2002:
+    case 0x2003:
+    case 0x2004:
+    case 0x2005:
+    case 0x2006:
+    case 0x2008:
+    case 0x2009:
+    case 0x200A:
+    case 0x205F:
+    //
+    // In-Word Break Opportunities
+    //
+    case 0x200B:
+      return 1;
+    //
+    // A space which is not a line-break opportunity
+    //
+    case 0x00A0:
+    case 0x202F:
+    //
+    // A hyphen which is not a line-break opportunity
+    //
+    case 0x2011:
+      return -1;
+    //
+    // Hyphen characters which describe line break opportunities after the character
+    //
+    case 0x058A:
+    case 0x2010:
+    case 0x2012:
+    case 0x2013:
+    case 0x0F0B:
+    case 0x1361:
+    case 0x17D5:
+      return 1;
+    //
+    // A hyphen which describes line break opportunities before and after them, but not between a pair of them
+    //
+    case 0x2014:
+      return 2;
+  }
+  return -1;
+}
+
+
+/**
+  Renders a string to a bitmap or to the display.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  Flags                   Describes how the string is to be drawn.
+  @param  String                  Points to the null-terminated string to be
+                                  displayed.
+  @param  StringInfo              Points to the string output information,
+                                  including the color and font.  If NULL, then the
+                                  string will be output in the default system font
+                                  and color.
+  @param  Blt                     If this points to a non-NULL on entry, this
+                                  points to the image, which is Width pixels   wide
+                                  and Height pixels high. The string will be drawn
+                                  onto this image and
+                                  EFI_HII_OUT_FLAG_CLIP is implied. If this points
+                                  to a NULL on entry, then a              buffer
+                                  will be allocated to hold the generated image and
+                                  the pointer updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  BltX                    Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  BltY                    Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  RowInfoArray            If this is non-NULL on entry, then on exit, this
+                                  will point to an allocated buffer    containing
+                                  row information and RowInfoArraySize will be
+                                  updated to contain the        number of elements.
+                                  This array describes the characters which were at
+                                  least partially drawn and the heights of the
+                                  rows. It is the caller's responsibility to free
+                                  this buffer.
+  @param  RowInfoArraySize        If this is non-NULL on entry, then on exit it
+                                  contains the number of elements in RowInfoArray.
+  @param  ColumnInfoArray         If this is non-NULL, then on return it will be
+                                  filled with the horizontal offset for each
+                                  character in the string on the row where it is
+                                  displayed. Non-printing characters will     have
+                                  the offset ~0. The caller is responsible to
+                                  allocate a buffer large enough so that    there
+                                  is one entry for each character in the string,
+                                  not including the null-terminator. It is possible
+                                  when character display is normalized that some
+                                  character cells overlap.
+
+  @retval EFI_SUCCESS             The string was successfully rendered.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate an output buffer for
+                                  RowInfoArray or Blt.
+  @retval EFI_INVALID_PARAMETER   The String or Blt was NULL.
+  @retval EFI_INVALID_PARAMETER Flags were invalid combination..
+
+**/
+EFI_STATUS
+EFIAPI
+HiiStringToImage (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  EFI_HII_OUT_FLAGS              Flags,
+  IN  CONST EFI_STRING               String,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfo       OPTIONAL,
+  IN  OUT EFI_IMAGE_OUTPUT           **Blt,
+  IN  UINTN                          BltX,
+  IN  UINTN                          BltY,
+  OUT EFI_HII_ROW_INFO               **RowInfoArray    OPTIONAL,
+  OUT UINTN                          *RowInfoArraySize OPTIONAL,
+  OUT UINTN                          *ColumnInfoArray  OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  UINT8                               **GlyphBuf;
+  EFI_HII_GLYPH_INFO                  *Cell;
+  UINT8                               *Attributes;
+  EFI_IMAGE_OUTPUT                    *Image;
+  EFI_STRING                          StringPtr;
+  EFI_STRING                          StringTmp;
+  EFI_HII_ROW_INFO                    *RowInfo;
+  UINTN                               LineWidth;
+  UINTN                               LineHeight;
+  UINTN                               LineOffset;
+  UINTN                               LastLineHeight;
+  UINTN                               BaseLineOffset;
+  UINT16                              MaxRowNum;
+  UINT16                              RowIndex;
+  UINTN                               Index;
+  UINTN                               NextIndex;
+  UINTN                               Index1;
+  EFI_FONT_DISPLAY_INFO               *StringInfoOut;
+  EFI_FONT_DISPLAY_INFO               *SystemDefault;
+  EFI_FONT_HANDLE                     FontHandle;
+  EFI_STRING                          StringIn;
+  EFI_STRING                          StringIn2;
+  UINT16                              Height;
+  UINT16                              BaseLine;
+  EFI_FONT_INFO                       *FontInfo;
+  BOOLEAN                             SysFontFlag;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL       Foreground;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL       Background;
+  BOOLEAN                             Transparent;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL       *BltBuffer;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL       *BufferPtr;
+  UINTN                               RowInfoSize;
+  BOOLEAN                             LineBreak;
+  UINTN                               StrLength;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL       *RowBufferPtr;
+  HII_GLOBAL_FONT_INFO                *GlobalFont;
+
+  //
+  // Check incoming parameters.
+  //
+
+  if (This == NULL || String == NULL || Blt == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (*Blt == NULL) {
+    //
+    // These two flag cannot be used if Blt is NULL upon entry.
+    //
+    if ((Flags & EFI_HII_OUT_FLAG_TRANSPARENT) == EFI_HII_OUT_FLAG_TRANSPARENT) {
+      return EFI_INVALID_PARAMETER;
+    }
+    if ((Flags & EFI_HII_OUT_FLAG_CLIP) == EFI_HII_OUT_FLAG_CLIP) {
+      return EFI_INVALID_PARAMETER;
+    }
+  }
+  //
+  // These two flags require that EFI_HII_OUT_FLAG_CLIP be also set.
+  //
+  if ((Flags & (EFI_HII_OUT_FLAG_CLIP | EFI_HII_OUT_FLAG_CLIP_CLEAN_X)) ==  EFI_HII_OUT_FLAG_CLIP_CLEAN_X) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if ((Flags & (EFI_HII_OUT_FLAG_CLIP | EFI_HII_OUT_FLAG_CLIP_CLEAN_Y)) ==  EFI_HII_OUT_FLAG_CLIP_CLEAN_Y) {
+    return EFI_INVALID_PARAMETER;
+  }
+  //
+  // This flag cannot be used with EFI_HII_OUT_FLAG_CLEAN_X.
+  //
+  if ((Flags & (EFI_HII_OUT_FLAG_WRAP | EFI_HII_OUT_FLAG_CLIP_CLEAN_X)) ==  (EFI_HII_OUT_FLAG_WRAP | EFI_HII_OUT_FLAG_CLIP_CLEAN_X)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (*Blt == NULL) {
+    //
+    // Create a new bitmap and draw the string onto this image.
+    //
+    Image = AllocateZeroPool (sizeof (EFI_IMAGE_OUTPUT));
+    if (Image == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    Image->Width  = 800;
+    Image->Height = 600;
+    Image->Image.Bitmap = AllocateZeroPool (Image->Width * Image->Height *sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+    if (Image->Image.Bitmap == NULL) {
+      FreePool (Image);
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    //
+    // Other flags are not permitted when Blt is NULL.
+    //
+    Flags &= EFI_HII_OUT_FLAG_WRAP | EFI_HII_IGNORE_IF_NO_GLYPH | EFI_HII_IGNORE_LINE_BREAK;
+    *Blt = Image;
+  }
+
+  StrLength = StrLen(String);
+  GlyphBuf = (UINT8 **) AllocateZeroPool (StrLength * sizeof (UINT8 *));
+  ASSERT (GlyphBuf != NULL);
+  Cell = (EFI_HII_GLYPH_INFO *) AllocateZeroPool (StrLength * sizeof (EFI_HII_GLYPH_INFO));
+  ASSERT (Cell != NULL);
+  Attributes = (UINT8 *) AllocateZeroPool (StrLength * sizeof (UINT8));
+  ASSERT (Attributes != NULL);
+
+  RowInfo       = NULL;
+  Status        = EFI_SUCCESS;
+  StringIn2     = NULL;
+  SystemDefault = NULL;
+  StringIn      = NULL;
+
+  //
+  // Calculate the string output information, including specified color and font .
+  // If StringInfo does not points to system font info, it must indicate an existing
+  // EFI_FONT_INFO.
+  //
+  StringInfoOut = NULL;
+  FontHandle    = NULL;
+  Private       = HII_FONT_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  SysFontFlag   = IsSystemFontInfo (Private, (EFI_FONT_DISPLAY_INFO *) StringInfo, &SystemDefault, NULL);
+
+  if (SysFontFlag) {
+    FontInfo   = NULL;
+    Height     = SystemDefault->FontInfo.FontSize;
+    BaseLine   = SystemDefault->FontInfo.FontSize;
+    Foreground = SystemDefault->ForegroundColor;
+    Background = SystemDefault->BackgroundColor;
+
+  } else {
+    //
+    //  StringInfo must not be NULL if it is not system info.
+    //
+    ASSERT (StringInfo != NULL);
+    Status = HiiGetFontInfo (This, &FontHandle, (EFI_FONT_DISPLAY_INFO *) StringInfo, &StringInfoOut, NULL);
+    if (Status == EFI_NOT_FOUND) {
+      //
+      // The specified EFI_FONT_DISPLAY_INFO does not exist in current database.
+      // Use the system font instead. Still use the color specified by StringInfo.
+      //
+      SysFontFlag = TRUE;
+      FontInfo    = NULL;
+      Height      = SystemDefault->FontInfo.FontSize;
+      BaseLine    = SystemDefault->FontInfo.FontSize;
+      Foreground  = ((EFI_FONT_DISPLAY_INFO *) StringInfo)->ForegroundColor;
+      Background  = ((EFI_FONT_DISPLAY_INFO *) StringInfo)->BackgroundColor;
+
+    } else if (Status == EFI_SUCCESS) {
+      FontInfo   = &StringInfoOut->FontInfo;
+      IsFontInfoExisted (Private, FontInfo, NULL, NULL, &GlobalFont);
+      Height     = GlobalFont->FontPackage->Height;
+      BaseLine   = GlobalFont->FontPackage->BaseLine;
+      Foreground = StringInfoOut->ForegroundColor;
+      Background = StringInfoOut->BackgroundColor;
+    } else {
+      goto Exit;
+    }
+  }
+  
+  //
+  // Use the maxinum height of font as the base line.
+  // And, use the maxinum height as line height.
+  //
+  LineHeight     = Height;
+  LastLineHeight = Height;
+  BaseLineOffset = Height - BaseLine;
+  
+  //
+  // Parse the string to be displayed to drop some ignored characters.
+  //
+
+  StringPtr = String;
+
+  //
+  // Ignore line-break characters only. Hyphens or dash character will be displayed
+  // without line-break opportunity.
+  //
+  if ((Flags & EFI_HII_IGNORE_LINE_BREAK) == EFI_HII_IGNORE_LINE_BREAK) {
+    StringIn = AllocateZeroPool (StrSize (StringPtr));
+    if (StringIn == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+    StringTmp = StringIn;
+    while (*StringPtr != 0) {
+      if (IsLineBreak (*StringPtr) == 0) {
+        StringPtr++;
+      } else {
+        *StringTmp++ = *StringPtr++;
+      }
+    }
+    *StringTmp = 0;
+    StringPtr  = StringIn;
+  }
+  //
+  // If EFI_HII_IGNORE_IF_NO_GLYPH is set, then characters which have no glyphs
+  // are not drawn. Otherwise they are replaced wth Unicode character 0xFFFD.
+  //
+  StringIn2  = AllocateZeroPool (StrSize (StringPtr));
+  if (StringIn2 == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+  Index     = 0;
+  StringTmp = StringIn2;
+  StrLength = StrLen(StringPtr);
+  while (*StringPtr != 0 && Index < StrLength) {
+    if (IsLineBreak (*StringPtr) == 0) {
+      *StringTmp++ = *StringPtr++;
+      Index++;
+      continue;
+    }
+    
+    Status = GetGlyphBuffer (Private, *StringPtr, FontInfo, &GlyphBuf[Index], &Cell[Index], &Attributes[Index]);
+    if (Status == EFI_NOT_FOUND) {
+      if ((Flags & EFI_HII_IGNORE_IF_NO_GLYPH) == EFI_HII_IGNORE_IF_NO_GLYPH) {
+        GlyphBuf[Index] = NULL;
+        ZeroMem (&Cell[Index], sizeof (Cell[Index]));
+        Status = EFI_SUCCESS;
+      } else {
+        //
+        // Unicode 0xFFFD must exist in current hii database if this flag is not set.
+        //
+        Status = GetGlyphBuffer (
+                   Private,
+                   REPLACE_UNKNOWN_GLYPH,
+                   FontInfo,
+                   &GlyphBuf[Index],
+                   &Cell[Index],
+                   &Attributes[Index]
+                   );
+        if (EFI_ERROR (Status)) {
+          Status = EFI_INVALID_PARAMETER;
+        }
+      }
+    }
+
+    if (EFI_ERROR (Status)) {
+      goto Exit;
+    }
+
+    *StringTmp++ = *StringPtr++;
+    Index++;
+  }
+  *StringTmp = 0;
+  StringPtr  = StringIn2;
+
+  //
+  // Draw the string according to the specified EFI_HII_OUT_FLAGS and Blt.
+  // If Blt is not NULL, then EFI_HII_OUT_FLAG_CLIP is implied, render this string
+  // to an existing image (bitmap or screen depending on flags) pointed by "*Blt".
+  // Otherwise render this string to a new allocated image and output it.
+  //
+  Image     = *Blt;
+  BufferPtr = Image->Image.Bitmap + Image->Width * BltY + BltX;
+  if (Image->Height < BltY) {
+    //
+    // the top edge of the image should be in Image resolution scope.
+    //
+    Status = EFI_INVALID_PARAMETER;
+    goto Exit;
+  }
+  MaxRowNum = (UINT16) ((Image->Height - BltY) / Height);
+  if ((Image->Height - BltY) % Height != 0) {
+    LastLineHeight = (Image->Height - BltY) % Height;
+    MaxRowNum++;
+  }
+
+  RowInfo = (EFI_HII_ROW_INFO *) AllocateZeroPool (MaxRowNum * sizeof (EFI_HII_ROW_INFO));
+  if (RowInfo == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+
+  //
+  // Format the glyph buffer according to flags.
+  //
+  Transparent = (BOOLEAN) ((Flags & EFI_HII_OUT_FLAG_TRANSPARENT) == EFI_HII_OUT_FLAG_TRANSPARENT ? TRUE : FALSE);
+
+  for (RowIndex = 0, Index = 0; RowIndex < MaxRowNum && StringPtr[Index] != 0; ) {
+    LineWidth      = 0;
+    LineBreak      = FALSE;
+
+    //
+    // Clip the final row if the row's bottom-most on pixel cannot fit when
+    // EFI_HII_OUT_FLAG_CLEAN_Y is set.
+    //
+    if (RowIndex == MaxRowNum - 1) {
+      if ((Flags & EFI_HII_OUT_FLAG_CLIP_CLEAN_Y) == EFI_HII_OUT_FLAG_CLIP_CLEAN_Y && LastLineHeight < LineHeight ) {
+        //
+        // Don't draw at all if the row's bottom-most on pixel cannot fit.
+        //
+        break;
+      }
+      LineHeight = LastLineHeight;
+    }
+
+    //
+    // Calculate how many characters there are in a row.
+    //
+    RowInfo[RowIndex].StartIndex = Index;
+
+    while (LineWidth + BltX < Image->Width && StringPtr[Index] != 0) {
+      if ((Flags & EFI_HII_IGNORE_LINE_BREAK) == 0 &&
+           IsLineBreak (StringPtr[Index]) == 0) {
+        //
+        // It forces a line break that ends this row.
+        //
+        Index++;
+        LineBreak = TRUE;
+        break;
+      }
+
+      //
+      // If the glyph of the character is existing, then accumulate the actual printed width
+      //
+      LineWidth += (UINTN) Cell[Index].AdvanceX;
+
+      Index++;
+    }
+
+    //
+    // Record index of next char.
+    //
+    NextIndex = Index;
+    //
+    // Return to the previous char.
+    //
+    Index--;
+    if (LineBreak && Index > 0 ) {
+      //
+      // Return the previous non line break char.
+      //
+      Index --;
+    }
+
+    //
+    // If this character is the last character of a row, we need not
+    // draw its (AdvanceX - Width - OffsetX) for next character.
+    //
+    LineWidth -= (UINTN) (Cell[Index].AdvanceX - Cell[Index].Width - Cell[Index].OffsetX);
+
+    //
+    // Clip the right-most character if cannot fit when EFI_HII_OUT_FLAG_CLEAN_X is set.
+    //
+    if (LineWidth + BltX <= Image->Width ||
+      (LineWidth + BltX > Image->Width && (Flags & EFI_HII_OUT_FLAG_CLIP_CLEAN_X) == 0)) {
+      //
+      // Record right-most character in RowInfo even if it is partially displayed.
+      //
+      RowInfo[RowIndex].EndIndex       = Index;
+      RowInfo[RowIndex].LineWidth      = LineWidth;
+      RowInfo[RowIndex].LineHeight     = LineHeight;
+      RowInfo[RowIndex].BaselineOffset = BaseLineOffset;
+    } else {
+      //
+      // When EFI_HII_OUT_FLAG_CLEAN_X is set, it will not draw a character
+      // if its right-most on pixel cannot fit.
+      //
+      if (Index > RowInfo[RowIndex].StartIndex) {
+        //
+        // Don't draw the last char on this row. And, don't draw the second last char (AdvanceX - Width - OffsetX).
+        //
+        LineWidth -= (UINTN) (Cell[Index].Width + Cell[Index].OffsetX);
+        LineWidth -= (UINTN) (Cell[Index - 1].AdvanceX - Cell[Index - 1].Width - Cell[Index - 1].OffsetX);
+        RowInfo[RowIndex].EndIndex       = Index - 1;
+        RowInfo[RowIndex].LineWidth      = LineWidth;
+        RowInfo[RowIndex].LineHeight     = LineHeight;
+        RowInfo[RowIndex].BaselineOffset = BaseLineOffset;
+      } else {
+        //
+        // There is no enough column to draw any character, so set current line width to zero.
+        // And go to draw Next line if LineBreak is set.
+        //
+        RowInfo[RowIndex].LineWidth      = 0;
+        goto NextLine;
+      }
+    }
+
+    //
+    // EFI_HII_OUT_FLAG_WRAP will wrap the text at the right-most line-break
+    // opportunity prior to a character whose right-most extent would exceed Width.
+    // Search the right-most line-break opportunity here.
+    //
+    if ((Flags & EFI_HII_OUT_FLAG_WRAP) == EFI_HII_OUT_FLAG_WRAP && 
+        (RowInfo[RowIndex].LineWidth + BltX > Image->Width || StringPtr[NextIndex] != 0) && 
+        !LineBreak) {
+      if ((Flags & EFI_HII_IGNORE_LINE_BREAK) == 0) {
+        LineWidth = RowInfo[RowIndex].LineWidth;
+        for (Index1 = RowInfo[RowIndex].EndIndex; Index1 >= RowInfo[RowIndex].StartIndex; Index1--) {
+          if (Index1 == RowInfo[RowIndex].EndIndex) {
+            LineWidth -= (Cell[Index1].Width + Cell[Index1].OffsetX);
+          } else {
+            LineWidth -= Cell[Index1].AdvanceX;
+          }
+          if (IsLineBreak (StringPtr[Index1]) > 0) {
+            LineBreak = TRUE;
+            if (Index1 > RowInfo[RowIndex].StartIndex) {
+              RowInfo[RowIndex].EndIndex = Index1 - 1;
+            }
+            //
+            // relocate to the character after the right-most line break opportunity of this line
+            //
+            NextIndex = Index1 + 1;
+            break;
+          }
+          //
+          // If don't find a line break opportunity from EndIndex to StartIndex,
+          // then jump out.
+          //
+          if (Index1 == RowInfo[RowIndex].StartIndex)
+            break;
+        }
+
+        //
+        // Update LineWidth to the real width
+        //
+        if (IsLineBreak (StringPtr[Index1]) > 0) {
+          if (Index1 == RowInfo[RowIndex].StartIndex) {
+            LineWidth = 0;
+          } else {
+            LineWidth -= (UINTN) (Cell[Index1 - 1].AdvanceX - Cell[Index1 - 1].Width - Cell[Index1 - 1].OffsetX);
+          }
+          RowInfo[RowIndex].LineWidth = LineWidth;
+        }
+      }
+      //
+      // If no line-break opportunity can be found, then the text will
+      // behave as if EFI_HII_OUT_FLAG_CLEAN_X is set.
+      //
+      if (!LineBreak) {
+        LineWidth = RowInfo[RowIndex].LineWidth;
+        Index1    = RowInfo[RowIndex].EndIndex;
+        if (LineWidth + BltX > Image->Width) {
+          if (Index1 > RowInfo[RowIndex].StartIndex) {
+            //
+            // Don't draw the last char on this row. And, don't draw the second last char (AdvanceX - Width - OffsetX).
+            //
+            LineWidth -= (UINTN) (Cell[Index1].Width + Cell[Index1].OffsetX);
+            LineWidth -= (UINTN) (Cell[Index1 - 1].AdvanceX - Cell[Index1 - 1].Width - Cell[Index1 - 1].OffsetX);
+            RowInfo[RowIndex].EndIndex       = Index1 - 1;
+            RowInfo[RowIndex].LineWidth      = LineWidth;
+          } else {
+            //
+            // There is no enough column to draw any character, so set current line width to zero.
+            // And go to draw Next line if LineBreak is set.
+            //
+            RowInfo[RowIndex].LineWidth = 0;
+            goto NextLine;
+          }
+        }
+      }
+    }
+    
+    //
+    // LineWidth can't exceed Image width.
+    //
+    if (RowInfo[RowIndex].LineWidth + BltX > Image->Width) {
+      RowInfo[RowIndex].LineWidth = Image->Width - BltX;
+    }
+
+    //
+    // Draw it to screen or existing bitmap depending on whether
+    // EFI_HII_DIRECT_TO_SCREEN is set.
+    //
+    LineOffset = 0;
+    if ((Flags & EFI_HII_DIRECT_TO_SCREEN) == EFI_HII_DIRECT_TO_SCREEN) {
+      BltBuffer = NULL;
+      if (RowInfo[RowIndex].LineWidth != 0) {
+        BltBuffer = AllocateZeroPool (RowInfo[RowIndex].LineWidth * RowInfo[RowIndex].LineHeight * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+        if (BltBuffer == NULL) {
+          Status = EFI_OUT_OF_RESOURCES;
+          goto Exit;
+        }
+        //
+        // Set BufferPtr to Origin by adding baseline to the starting position.
+        //
+        BufferPtr = BltBuffer + BaseLine * RowInfo[RowIndex].LineWidth;
+      }
+      for (Index1 = RowInfo[RowIndex].StartIndex; Index1 <= RowInfo[RowIndex].EndIndex; Index1++) {
+        if (RowInfo[RowIndex].LineWidth > 0 && RowInfo[RowIndex].LineWidth > LineOffset) {
+          //
+          // Only BLT these character which have corrsponding glyph in font basebase.
+          //
+          GlyphToImage (
+            GlyphBuf[Index1],
+            Foreground,
+            Background,
+            (UINT16) RowInfo[RowIndex].LineWidth,
+            BaseLine,
+            RowInfo[RowIndex].LineWidth - LineOffset,
+            RowInfo[RowIndex].LineHeight,
+            Transparent,
+            &Cell[Index1],
+            Attributes[Index1],
+            &BufferPtr
+          );
+        }
+        if (ColumnInfoArray != NULL) {
+          if ((GlyphBuf[Index1] == NULL && Cell[Index1].AdvanceX == 0) 
+              || RowInfo[RowIndex].LineWidth == 0) {
+            *ColumnInfoArray = (UINTN) ~0;
+          } else {
+            *ColumnInfoArray = LineOffset + Cell[Index1].OffsetX + BltX;
+          }
+          ColumnInfoArray++;
+        }
+        LineOffset += Cell[Index1].AdvanceX;
+      }
+
+      if (BltBuffer != NULL) {
+        Status = Image->Image.Screen->Blt (
+                                        Image->Image.Screen,
+                                        BltBuffer,
+                                        EfiBltBufferToVideo,
+                                        0,
+                                        0,
+                                        BltX,
+                                        BltY,
+                                        RowInfo[RowIndex].LineWidth,
+                                        RowInfo[RowIndex].LineHeight,
+                                        0
+                                        );
+        if (EFI_ERROR (Status)) {
+          FreePool (BltBuffer);
+          goto Exit;
+        }
+  
+        FreePool (BltBuffer);
+      }
+    } else {
+      //
+      // Save the starting position for calculate the starting postition of next row. 
+      //
+      RowBufferPtr = BufferPtr;
+      //
+      // Set BufferPtr to Origin by adding baseline to the starting position.
+      //
+      BufferPtr = BufferPtr + BaseLine * Image->Width;
+      for (Index1 = RowInfo[RowIndex].StartIndex; Index1 <= RowInfo[RowIndex].EndIndex; Index1++) {
+        if (RowInfo[RowIndex].LineWidth > 0 && RowInfo[RowIndex].LineWidth > LineOffset) {
+          //
+          // Only BLT these character which have corrsponding glyph in font basebase.
+          //
+          GlyphToImage (
+            GlyphBuf[Index1],
+            Foreground,
+            Background,
+            Image->Width,
+            BaseLine,
+            RowInfo[RowIndex].LineWidth - LineOffset,
+            RowInfo[RowIndex].LineHeight,
+            Transparent,
+            &Cell[Index1],
+            Attributes[Index1],
+            &BufferPtr
+          );
+        }
+        if (ColumnInfoArray != NULL) {
+          if ((GlyphBuf[Index1] == NULL && Cell[Index1].AdvanceX == 0) 
+              || RowInfo[RowIndex].LineWidth == 0) {
+            *ColumnInfoArray = (UINTN) ~0;
+          } else {
+            *ColumnInfoArray = LineOffset + Cell[Index1].OffsetX + BltX;
+          }
+          ColumnInfoArray++;
+        }
+        LineOffset += Cell[Index1].AdvanceX;
+      }
+
+      //
+      // Jump to starting position of next row.
+      //
+      if (RowIndex == 0) {
+        BufferPtr = RowBufferPtr - BltX + LineHeight * Image->Width;
+      } else {
+        BufferPtr = RowBufferPtr + LineHeight * Image->Width;
+      }
+    }
+
+NextLine:
+    //
+    // Recalculate the start point of X/Y axis to draw multi-lines with the order of top-to-down
+    //
+    BltX = 0;
+    BltY += RowInfo[RowIndex].LineHeight;
+
+    RowIndex++;
+    Index = NextIndex;
+
+    if (!LineBreak) {
+      //
+      // If there is not a mandatory line break or line break opportunity, only render one line to image
+      //
+      break;
+    }
+  }
+
+  //
+  // Write output parameters.
+  //
+  RowInfoSize = RowIndex * sizeof (EFI_HII_ROW_INFO);
+  if (RowInfoArray != NULL) {
+    if (RowInfoSize > 0) {
+      *RowInfoArray = AllocateZeroPool (RowInfoSize);
+      if (*RowInfoArray == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Exit;
+      }
+      CopyMem (*RowInfoArray, RowInfo, RowInfoSize);
+    } else {
+      *RowInfoArray = NULL;
+    }
+  }
+  if (RowInfoArraySize != NULL) {
+    *RowInfoArraySize = RowIndex;
+  }
+
+  Status = EFI_SUCCESS;
+
+Exit:
+
+  for (Index = 0; Index < StrLength; Index++) {
+    if (GlyphBuf[Index] != NULL) {
+      FreePool (GlyphBuf[Index]);
+    }
+  }
+  if (StringIn != NULL) {
+    FreePool (StringIn);
+  }
+  if (StringIn2 != NULL) {
+    FreePool (StringIn2);
+  }
+  if (StringInfoOut != NULL) {
+    FreePool (StringInfoOut);
+  }
+  if (RowInfo != NULL) {
+    FreePool (RowInfo);
+  }
+  if (SystemDefault != NULL) {
+    FreePool (SystemDefault);
+  }
+  if (GlyphBuf != NULL) {
+    FreePool (GlyphBuf);
+  }
+  if (Cell != NULL) {
+    FreePool (Cell);
+  }
+  if (Attributes != NULL) {
+    FreePool (Attributes);
+  }
+
+  return Status;
+}
+
+
+/**
+  Render a string to a bitmap or the screen containing the contents of the specified string.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  Flags                   Describes how the string is to be drawn.
+  @param  PackageList             The package list in the HII database to search
+                                  for the specified string.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.
+  @param  Language                Points to the language for the retrieved string.
+                                  If NULL, then the current system language is
+                                  used.
+  @param  StringInfo              Points to the string output information,
+                                  including the color and font.  If NULL, then the
+                                  string will be output in the default system font
+                                  and color.
+  @param  Blt                     If this points to a non-NULL on entry, this
+                                  points to the image, which is Width pixels   wide
+                                  and Height pixels high. The string will be drawn
+                                  onto this image and
+                                  EFI_HII_OUT_FLAG_CLIP is implied. If this points
+                                  to a NULL on entry, then a              buffer
+                                  will be allocated to hold the generated image and
+                                  the pointer updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  BltX                    Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  BltY                    Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  RowInfoArray            If this is non-NULL on entry, then on exit, this
+                                  will point to an allocated buffer    containing
+                                  row information and RowInfoArraySize will be
+                                  updated to contain the        number of elements.
+                                  This array describes the characters which were at
+                                  least partially drawn and the heights of the
+                                  rows. It is the caller's responsibility to free
+                                  this buffer.
+  @param  RowInfoArraySize        If this is non-NULL on entry, then on exit it
+                                  contains the number of elements in RowInfoArray.
+  @param  ColumnInfoArray         If this is non-NULL, then on return it will be
+                                  filled with the horizontal offset for each
+                                  character in the string on the row where it is
+                                  displayed. Non-printing characters will     have
+                                  the offset ~0. The caller is responsible to
+                                  allocate a buffer large enough so that    there
+                                  is one entry for each character in the string,
+                                  not including the null-terminator. It is possible
+                                  when character display is normalized that some
+                                  character cells overlap.
+
+  @retval EFI_SUCCESS             The string was successfully rendered.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate an output buffer for
+                                  RowInfoArray or Blt.
+  @retval EFI_INVALID_PARAMETER  The Blt or PackageList was NULL.
+  @retval EFI_INVALID_PARAMETER  Flags were invalid combination.
+  @retval EFI_NOT_FOUND         The specified PackageList is not in the Database or the stringid is not 
+                          in the specified PackageList. 
+
+**/
+EFI_STATUS
+EFIAPI
+HiiStringIdToImage (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  EFI_HII_OUT_FLAGS              Flags,
+  IN  EFI_HII_HANDLE                 PackageList,
+  IN  EFI_STRING_ID                  StringId,
+  IN  CONST CHAR8*                   Language,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfo       OPTIONAL,
+  IN  OUT EFI_IMAGE_OUTPUT           **Blt,
+  IN  UINTN                          BltX,
+  IN  UINTN                          BltY,
+  OUT EFI_HII_ROW_INFO               **RowInfoArray    OPTIONAL,
+  OUT UINTN                          *RowInfoArraySize OPTIONAL,
+  OUT UINTN                          *ColumnInfoArray  OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  EFI_HII_STRING_PROTOCOL             *HiiString;
+  EFI_STRING                          String;
+  UINTN                               StringSize;
+  UINTN                               FontLen;
+  EFI_FONT_INFO                       *StringFontInfo;
+  EFI_FONT_DISPLAY_INFO               *NewStringInfo;
+  CHAR8                               TempSupportedLanguages;
+  CHAR8                               *SupportedLanguages;
+  UINTN                               SupportedLanguagesSize;
+  CHAR8                               *CurrentLanguage;
+  CHAR8                               *BestLanguage;
+
+  if (This == NULL || PackageList == NULL || Blt == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Initialize string pointers to be NULL
+  //
+  SupportedLanguages = NULL;
+  CurrentLanguage    = NULL;
+  BestLanguage       = NULL;
+  String             = NULL;
+  StringFontInfo     = NULL;
+  NewStringInfo      = NULL;
+
+  //
+  // Get the string to be displayed.
+  //
+  Private   = HII_FONT_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  HiiString = &Private->HiiString;
+
+  //
+  // Get the size of supported language.
+  //
+  SupportedLanguagesSize = 0;
+  Status = HiiString->GetLanguages (
+                        HiiString,
+                        PackageList,
+                        &TempSupportedLanguages,
+                        &SupportedLanguagesSize
+                        );
+  if (Status != EFI_BUFFER_TOO_SMALL) {
+    return Status;
+  }
+
+  SupportedLanguages = AllocatePool (SupportedLanguagesSize);
+  if (SupportedLanguages == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  Status = HiiString->GetLanguages (
+                        HiiString,
+                        PackageList,
+                        SupportedLanguages,
+                        &SupportedLanguagesSize
+                        );
+  if (EFI_ERROR (Status)) {
+    goto Exit;
+  }
+ 
+  if (Language == NULL) {
+    Language = "";
+  }
+  CurrentLanguage = GetEfiGlobalVariable (L"PlatformLang");
+  BestLanguage = GetBestLanguage (
+                   SupportedLanguages,
+                   FALSE,
+                   Language,
+                   (CurrentLanguage == NULL) ? CurrentLanguage : "",
+                   (CHAR8 *) PcdGetPtr (PcdUefiVariableDefaultPlatformLang),
+                   NULL
+                   );
+  if (BestLanguage == NULL) {
+    Status = EFI_NOT_FOUND;
+    goto Exit;
+  }
+    
+  StringSize = MAX_STRING_LENGTH;
+  String = (EFI_STRING) AllocateZeroPool (StringSize);
+  if (String == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+
+  Status = HiiString->GetString (
+                        HiiString,
+                        BestLanguage,
+                        PackageList,
+                        StringId,
+                        String,
+                        &StringSize,
+                        &StringFontInfo
+                        );
+  if (Status == EFI_BUFFER_TOO_SMALL) {
+    FreePool (String);
+    String = (EFI_STRING) AllocateZeroPool (StringSize);
+    if (String == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+    Status = HiiString->GetString (
+                          HiiString,
+                          BestLanguage,
+                          PackageList,
+                          StringId,
+                          String,
+                          &StringSize,
+                          NULL
+                          );
+  }
+
+  if (EFI_ERROR (Status)) {
+    goto Exit;
+  }
+    
+  //
+  // When StringInfo specifies that string will be output in the system default font and color,
+  // use particular stringfontinfo described in string package instead if exists. 
+  // StringFontInfo equals NULL means system default font attaches with the string block.
+  //
+  if (StringFontInfo != NULL && IsSystemFontInfo (Private, (EFI_FONT_DISPLAY_INFO *) StringInfo, NULL, NULL)) {
+    FontLen = sizeof (EFI_FONT_DISPLAY_INFO) - sizeof (CHAR16) + StrSize (StringFontInfo->FontName);
+    NewStringInfo = AllocateZeroPool (FontLen);
+    if (NewStringInfo == NULL) {      
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+    NewStringInfo->FontInfoMask       = EFI_FONT_INFO_SYS_FORE_COLOR | EFI_FONT_INFO_SYS_BACK_COLOR;
+    NewStringInfo->FontInfo.FontStyle = StringFontInfo->FontStyle;
+    NewStringInfo->FontInfo.FontSize  = StringFontInfo->FontSize;    
+    StrCpy (NewStringInfo->FontInfo.FontName, StringFontInfo->FontName);
+  
+    Status = HiiStringToImage (
+               This, 
+               Flags, 
+               String, 
+               NewStringInfo, 
+               Blt, 
+               BltX, 
+               BltY, 
+               RowInfoArray,
+               RowInfoArraySize,
+               ColumnInfoArray
+               );
+    goto Exit;
+  }
+
+  Status = HiiStringToImage (
+           This,
+           Flags,
+           String,
+           StringInfo,
+           Blt,
+           BltX,
+           BltY,
+           RowInfoArray,
+           RowInfoArraySize,
+           ColumnInfoArray
+           );
+
+Exit:
+  if (SupportedLanguages != NULL) {
+    FreePool (SupportedLanguages);
+  }
+  if (CurrentLanguage != NULL) {
+    FreePool (CurrentLanguage);
+  }
+  if (BestLanguage != NULL) {
+    FreePool (BestLanguage);
+  }
+  if (String != NULL) {
+    FreePool (String);
+  }
+  if (StringFontInfo != NULL) {
+    FreePool (StringFontInfo);
+  }
+  if (NewStringInfo != NULL) {
+    FreePool (NewStringInfo);
+  }
+
+  return Status;
+}
+
+
+/**
+  Convert the glyph for a single character into a bitmap.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  Char                    Character to retrieve.
+  @param  StringInfo              Points to the string font and color information
+                                  or NULL if the string should use the default
+                                  system font and color.
+  @param  Blt                     Thus must point to a NULL on entry. A buffer will
+                                  be allocated to hold the output and the pointer
+                                  updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  Baseline                Number of pixels from the bottom of the bitmap to
+                                  the baseline.
+
+  @retval EFI_SUCCESS             Glyph bitmap created.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate the output buffer Blt.
+  @retval EFI_WARN_UNKNOWN_GLYPH  The glyph was unknown and was replaced with the
+                                  glyph for Unicode character 0xFFFD.
+  @retval EFI_INVALID_PARAMETER   Blt is NULL or *Blt is not NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetGlyph (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  CHAR16                         Char,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfo,
+  OUT EFI_IMAGE_OUTPUT               **Blt,
+  OUT UINTN                          *Baseline OPTIONAL
+  )
+{
+  EFI_STATUS                         Status;
+  HII_DATABASE_PRIVATE_DATA          *Private;
+  EFI_IMAGE_OUTPUT                   *Image;
+  UINT8                              *GlyphBuffer;
+  EFI_FONT_DISPLAY_INFO              *SystemDefault;
+  EFI_FONT_DISPLAY_INFO              *StringInfoOut;
+  BOOLEAN                            Default;
+  EFI_FONT_HANDLE                    FontHandle;
+  EFI_STRING                         String;
+  EFI_HII_GLYPH_INFO                 Cell;
+  EFI_FONT_INFO                      *FontInfo;
+  UINT8                              Attributes;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      Foreground;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      Background;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      *BltBuffer;
+  UINT16                             BaseLine;
+
+  if (This == NULL || Blt == NULL || *Blt != NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Private = HII_FONT_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  Default       = FALSE;
+  Image         = NULL;
+  SystemDefault = NULL;
+  FontHandle    = NULL;
+  String        = NULL;
+  GlyphBuffer   = NULL;
+  StringInfoOut = NULL;
+  FontInfo      = NULL;
+
+  ZeroMem (&Foreground, sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+  ZeroMem (&Background, sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+
+  Default = IsSystemFontInfo (Private, (EFI_FONT_DISPLAY_INFO *) StringInfo, &SystemDefault, NULL);
+
+  if (!Default) {
+    //
+    // Find out a EFI_FONT_DISPLAY_INFO which could display the character in
+    // the specified color and font.
+    //
+    String = (EFI_STRING) AllocateZeroPool (sizeof (CHAR16) * 2);
+    if (String == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+    *String = Char;
+    *(String + 1) = 0;
+
+    Status = HiiGetFontInfo (This, &FontHandle, StringInfo, &StringInfoOut, String);
+    if (EFI_ERROR (Status)) {
+      goto Exit;
+    }
+    ASSERT (StringInfoOut != NULL);
+    FontInfo   = &StringInfoOut->FontInfo;
+    Foreground = StringInfoOut->ForegroundColor;
+    Background = StringInfoOut->BackgroundColor;
+  } else {
+    Foreground = SystemDefault->ForegroundColor;
+    Background = SystemDefault->BackgroundColor;
+  }
+
+  Status = GetGlyphBuffer (Private, Char, FontInfo, &GlyphBuffer, &Cell, &Attributes);
+  if (EFI_ERROR (Status)) {
+    goto Exit;
+  }
+
+  Image = (EFI_IMAGE_OUTPUT *) AllocateZeroPool (sizeof (EFI_IMAGE_OUTPUT));
+  if (Image == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+  Image->Width   = Cell.Width;
+  Image->Height  = Cell.Height;
+
+  if (Image->Width * Image->Height > 0) {
+    Image->Image.Bitmap = AllocateZeroPool (Image->Width * Image->Height * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+    if (Image->Image.Bitmap == NULL) {
+      FreePool (Image);
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Exit;
+    }
+
+    //
+    // Set BaseLine to the char height.
+    //
+    BaseLine  = (UINT16) (Cell.Height + Cell.OffsetY);
+    //
+    // Set BltBuffer to the position of Origin. 
+    //
+    BltBuffer = Image->Image.Bitmap + (Cell.Height + Cell.OffsetY) * Image->Width - Cell.OffsetX;
+    GlyphToImage (
+      GlyphBuffer,
+      Foreground,
+      Background,
+      Image->Width,
+      BaseLine,
+      Cell.Width + Cell.OffsetX,
+      BaseLine - Cell.OffsetY,
+      FALSE,
+      &Cell,
+      Attributes,
+      &BltBuffer
+      );
+  }
+
+  *Blt = Image;
+  if (Baseline != NULL) {
+    *Baseline = Cell.OffsetY;
+  }
+
+  Status = EFI_SUCCESS;
+
+Exit:
+
+  if (Status == EFI_NOT_FOUND) {
+    //
+    // Glyph is unknown and replaced with the glyph for unicode character 0xFFFD
+    //
+    if (Char != REPLACE_UNKNOWN_GLYPH) {
+      Status = HiiGetGlyph (This, REPLACE_UNKNOWN_GLYPH, StringInfo, Blt, Baseline);
+      if (!EFI_ERROR (Status)) {
+        Status = EFI_WARN_UNKNOWN_GLYPH;
+      }
+    } else {
+      Status = EFI_WARN_UNKNOWN_GLYPH;
+    }
+  }
+
+  if (SystemDefault != NULL) {
+   FreePool (SystemDefault);
+  }
+  if (StringInfoOut != NULL) {
+    FreePool (StringInfoOut);
+  }
+  if (String != NULL) {
+    FreePool (String);
+  }
+  if (GlyphBuffer != NULL) {
+    FreePool (GlyphBuffer);
+  }
+
+  return Status;
+}
+
+
+/**
+  This function iterates through fonts which match the specified font, using
+  the specified criteria. If String is non-NULL, then all of the characters in
+  the string must exist in order for a candidate font to be returned.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  FontHandle              On entry, points to the font handle returned by a
+                                   previous call to GetFontInfo() or NULL to start
+                                  with the  first font. On return, points to the
+                                  returned font handle or points to NULL if there
+                                  are no more matching fonts.
+  @param  StringInfoIn            Upon entry, points to the font to return
+                                  information about. 
+                                  If NULL, then the information about the system default 
+                                  font will be returned.
+  @param  StringInfoOut           Upon return, contains the matching font's
+                                  information.  If NULL, then no information is
+                                  returned. It's caller's responsibility to free
+                                  this buffer.
+  @param  String                  Points to the string which will be tested to
+                                  determine  if all characters are available. If
+                                  NULL, then any font  is acceptable.
+
+  @retval EFI_SUCCESS             Matching font returned successfully.
+  @retval EFI_NOT_FOUND           No matching font was found.
+  @retval EFI_INVALID_PARAMETER  StringInfoIn->FontInfoMask is an invalid combination.
+  @retval EFI_OUT_OF_RESOURCES    There were insufficient resources to complete the
+                                  request.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetFontInfo (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  OUT   EFI_FONT_HANDLE          *FontHandle,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfoIn, OPTIONAL
+  OUT       EFI_FONT_DISPLAY_INFO    **StringInfoOut,
+  IN  CONST EFI_STRING               String OPTIONAL
+  )
+{
+  HII_DATABASE_PRIVATE_DATA          *Private;
+  EFI_STATUS                         Status;
+  EFI_FONT_DISPLAY_INFO              *SystemDefault;
+  EFI_FONT_DISPLAY_INFO              InfoOut;
+  UINTN                              StringInfoOutLen;
+  EFI_FONT_INFO                      *FontInfo;
+  HII_GLOBAL_FONT_INFO               *GlobalFont;
+  EFI_STRING                         StringIn;
+  EFI_FONT_HANDLE                    LocalFontHandle;
+
+  if (This == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  FontInfo        = NULL;
+  SystemDefault   = NULL;
+  LocalFontHandle = NULL;
+  if (FontHandle != NULL) {
+    LocalFontHandle = *FontHandle;
+  }
+
+  Private = HII_FONT_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Already searched to the end of the whole list, return directly.
+  //
+  if (LocalFontHandle == &Private->FontInfoList) {
+    LocalFontHandle = NULL;
+    Status = EFI_NOT_FOUND;
+    goto Exit;
+  }
+
+  //
+  // Get default system display info, if StringInfoIn points to
+  // system display info, return it directly.
+  //
+  if (IsSystemFontInfo (Private, (EFI_FONT_DISPLAY_INFO *) StringInfoIn, &SystemDefault, &StringInfoOutLen)) {
+    //
+    // System font is the first node. When handle is not NULL, system font can not
+    // be found any more.
+    //
+    if (LocalFontHandle == NULL) {
+      if (StringInfoOut != NULL) {
+        *StringInfoOut = AllocateCopyPool (StringInfoOutLen, SystemDefault);
+        if (*StringInfoOut == NULL) {
+          Status = EFI_OUT_OF_RESOURCES;
+          LocalFontHandle = NULL;
+          goto Exit;
+        }
+      }
+
+      LocalFontHandle = Private->FontInfoList.ForwardLink;
+      Status = EFI_SUCCESS;
+      goto Exit;
+    } else {
+      LocalFontHandle = NULL;
+      Status = EFI_NOT_FOUND;
+      goto Exit;
+    }
+  }
+  
+  //
+  // StringInfoIn must not be NULL if it is not system default font info.
+  //
+  ASSERT (StringInfoIn != NULL);
+  //
+  // Check the font information mask to make sure it is valid.
+  //
+  if (((StringInfoIn->FontInfoMask & (EFI_FONT_INFO_SYS_FONT  | EFI_FONT_INFO_ANY_FONT))  == 
+       (EFI_FONT_INFO_SYS_FONT | EFI_FONT_INFO_ANY_FONT))   ||
+      ((StringInfoIn->FontInfoMask & (EFI_FONT_INFO_SYS_SIZE  | EFI_FONT_INFO_ANY_SIZE))  == 
+       (EFI_FONT_INFO_SYS_SIZE | EFI_FONT_INFO_ANY_SIZE))   ||
+      ((StringInfoIn->FontInfoMask & (EFI_FONT_INFO_SYS_STYLE | EFI_FONT_INFO_ANY_STYLE)) == 
+       (EFI_FONT_INFO_SYS_STYLE | EFI_FONT_INFO_ANY_STYLE)) ||
+      ((StringInfoIn->FontInfoMask & (EFI_FONT_INFO_RESIZE    | EFI_FONT_INFO_ANY_SIZE))  == 
+       (EFI_FONT_INFO_RESIZE | EFI_FONT_INFO_ANY_SIZE))     ||           
+      ((StringInfoIn->FontInfoMask & (EFI_FONT_INFO_RESTYLE   | EFI_FONT_INFO_ANY_STYLE)) == 
+       (EFI_FONT_INFO_RESTYLE | EFI_FONT_INFO_ANY_STYLE))) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Parse the font information mask to find a matching font.
+  //
+
+  CopyMem (&InfoOut, (EFI_FONT_DISPLAY_INFO *) StringInfoIn, sizeof (EFI_FONT_DISPLAY_INFO));
+
+  if ((StringInfoIn->FontInfoMask & EFI_FONT_INFO_SYS_FONT) == EFI_FONT_INFO_SYS_FONT) {
+    Status = SaveFontName (SystemDefault->FontInfo.FontName, &FontInfo);
+  } else {
+    Status = SaveFontName (((EFI_FONT_DISPLAY_INFO *) StringInfoIn)->FontInfo.FontName, &FontInfo);
+  }
+  if (EFI_ERROR (Status)) {
+    goto Exit;
+  }
+
+  if ((StringInfoIn->FontInfoMask & EFI_FONT_INFO_SYS_SIZE) == EFI_FONT_INFO_SYS_SIZE) {
+    InfoOut.FontInfo.FontSize = SystemDefault->FontInfo.FontSize;
+  } 
+  if ((StringInfoIn->FontInfoMask & EFI_FONT_INFO_SYS_STYLE) == EFI_FONT_INFO_SYS_STYLE) {
+    InfoOut.FontInfo.FontStyle = SystemDefault->FontInfo.FontStyle;
+  }
+  if ((StringInfoIn->FontInfoMask & EFI_FONT_INFO_SYS_FORE_COLOR) == EFI_FONT_INFO_SYS_FORE_COLOR) {
+    InfoOut.ForegroundColor = SystemDefault->ForegroundColor;
+  }
+  if ((StringInfoIn->FontInfoMask & EFI_FONT_INFO_SYS_BACK_COLOR) == EFI_FONT_INFO_SYS_BACK_COLOR) {
+    InfoOut.BackgroundColor = SystemDefault->BackgroundColor;
+  }
+  
+  ASSERT (FontInfo != NULL);
+  FontInfo->FontSize  = InfoOut.FontInfo.FontSize;
+  FontInfo->FontStyle = InfoOut.FontInfo.FontStyle;
+
+  if (IsFontInfoExisted (Private, FontInfo, &InfoOut.FontInfoMask, LocalFontHandle, &GlobalFont)) {
+    //
+    // Test to guarantee all characters are available in the found font.
+    //    
+    if (String != NULL) {
+      StringIn = String;
+      while (*StringIn != 0) {
+        Status = FindGlyphBlock (GlobalFont->FontPackage, *StringIn, NULL, NULL, NULL);
+        if (EFI_ERROR (Status)) {
+          LocalFontHandle = NULL;
+          goto Exit;
+        }
+        StringIn++;
+      }
+    }
+    //
+    // Write to output parameter
+    //
+    if (StringInfoOut != NULL) {
+      StringInfoOutLen = sizeof (EFI_FONT_DISPLAY_INFO) - sizeof (EFI_FONT_INFO) + GlobalFont->FontInfoSize;
+      *StringInfoOut   = (EFI_FONT_DISPLAY_INFO *) AllocateZeroPool (StringInfoOutLen);      
+      if (*StringInfoOut == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        LocalFontHandle = NULL;
+        goto Exit;
+      }
+      
+      CopyMem (*StringInfoOut, &InfoOut, sizeof (EFI_FONT_DISPLAY_INFO));
+      CopyMem (&(*StringInfoOut)->FontInfo, GlobalFont->FontInfo, GlobalFont->FontInfoSize);
+    }
+    
+    LocalFontHandle = GlobalFont->Entry.ForwardLink;    
+    Status = EFI_SUCCESS;
+    goto Exit;
+  }  
+
+  Status = EFI_NOT_FOUND;
+
+Exit:
+
+  if (FontHandle != NULL) {
+    *FontHandle = LocalFontHandle;
+  }
+
+  if (SystemDefault != NULL) {
+   FreePool (SystemDefault);
+  }
+  if (FontInfo != NULL) {
+   FreePool (FontInfo);
+  }
+  return Status;
+}
+
+
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabase.h
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabase.h	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabase.h	(working copy)
@@ -0,0 +1,1787 @@
+/** @file
+Private structures definitions in HiiDatabase.
+
+Copyright (c) 2007 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef __HII_DATABASE_PRIVATE_H__
+#define __HII_DATABASE_PRIVATE_H__
+
+#include <Uefi.h>
+
+#include <Protocol/DevicePath.h>
+#include <Protocol/HiiFont.h>
+#include <Protocol/HiiImage.h>
+#include <Protocol/HiiString.h>
+#include <Protocol/HiiDatabase.h>
+#include <Protocol/HiiConfigRouting.h>
+#include <Protocol/HiiConfigAccess.h>
+#include <Protocol/SimpleTextOut.h>
+
+#include <Guid/HiiKeyBoardLayout.h>
+#include <Guid/GlobalVariable.h>
+
+
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/BaseLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiLib.h>
+#include <Library/PcdLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Library/PrintLib.h>
+
+#define MAX_STRING_LENGTH                  1024
+#define MAX_FONT_NAME_LEN                  256
+#define NARROW_BASELINE                    15
+#define WIDE_BASELINE                      14
+#define SYS_FONT_INFO_MASK                 0x37
+#define REPLACE_UNKNOWN_GLYPH              0xFFFD
+#define PROPORTIONAL_GLYPH                 0x80
+#define NARROW_GLYPH                       0x40
+
+#define BITMAP_LEN_1_BIT(Width, Height)  (((Width) + 7) / 8 * (Height))
+#define BITMAP_LEN_4_BIT(Width, Height)  (((Width) + 1) / 2 * (Height))
+#define BITMAP_LEN_8_BIT(Width, Height)  ((Width) * (Height))
+#define BITMAP_LEN_24_BIT(Width, Height) ((Width) * (Height) * 3)
+
+//
+// IFR data structure
+//
+// BASE_CR (a, IFR_DEFAULT_VALUE_DATA, Entry) to get the whole structure.
+
+typedef struct {
+  LIST_ENTRY          Entry;             // Link to VarStorage
+  EFI_GUID            Guid;
+  CHAR16              *Name;
+  EFI_VARSTORE_ID     VarStoreId;
+  UINT16              Size;
+  LIST_ENTRY          BlockEntry;        // Link to its Block array
+} IFR_VARSTORAGE_DATA;
+
+typedef struct {
+  LIST_ENTRY          Entry;             // Link to Block array
+  UINT16              Offset;
+  UINT16              Width;
+  EFI_QUESTION_ID     QuestionId;
+  UINT8               OpCode;
+  UINT8               Scope;
+  LIST_ENTRY          DefaultValueEntry; // Link to its default value array
+} IFR_BLOCK_DATA;
+
+//
+// Get default value from IFR data.
+//
+typedef enum {
+  DefaultValueFromDefault = 0,     // Get from the minimum or first one when not set default value.
+  DefaultValueFromFlag,            // Get default value from the defalut flag.
+  DefaultValueFromOpcode           // Get default value from default opcode, highest priority.
+} DEFAULT_VALUE_TYPE;
+
+typedef struct {
+  LIST_ENTRY          Entry;
+  DEFAULT_VALUE_TYPE  Type;
+  BOOLEAN             Cleaned;       // Whether this value is cleaned
+                                     // TRUE  Cleaned, the value can't be used
+                                     // FALSE Not cleaned, the value can  be used.
+  UINT16              DefaultId;
+  EFI_IFR_TYPE_VALUE  Value;
+} IFR_DEFAULT_DATA;
+
+//
+// Storage types
+//
+#define EFI_HII_VARSTORE_BUFFER            0
+#define EFI_HII_VARSTORE_NAME_VALUE        1
+#define EFI_HII_VARSTORE_EFI_VARIABLE      2
+
+#define HII_FORMSET_STORAGE_SIGNATURE           SIGNATURE_32 ('H', 'S', 'T', 'G')
+typedef struct {
+  UINTN               Signature;
+  LIST_ENTRY          Entry;
+
+  EFI_HII_HANDLE      HiiHandle;
+  EFI_HANDLE          DriverHandle;
+
+  UINT8               Type;   // EFI_HII_VARSTORE_BUFFER, EFI_HII_VARSTORE_NAME_VALUE, EFI_HII_VARSTORE_EFI_VARIABLE
+  EFI_GUID            Guid;
+  CHAR16              *Name;
+  UINT16              Size;
+} HII_FORMSET_STORAGE;
+
+
+//
+// String Package definitions
+//
+#define HII_STRING_PACKAGE_SIGNATURE    SIGNATURE_32 ('h','i','s','p')
+typedef struct _HII_STRING_PACKAGE_INSTANCE {
+  UINTN                                 Signature;
+  EFI_HII_STRING_PACKAGE_HDR            *StringPkgHdr;
+  UINT8                                 *StringBlock;
+  LIST_ENTRY                            StringEntry;
+  LIST_ENTRY                            FontInfoList;  // local font info list
+  UINT8                                 FontId;
+  EFI_STRING_ID                         MaxStringId;   // record StringId
+} HII_STRING_PACKAGE_INSTANCE;
+
+//
+// Form Package definitions
+//
+#define HII_IFR_PACKAGE_SIGNATURE       SIGNATURE_32 ('h','f','r','p')
+typedef struct _HII_IFR_PACKAGE_INSTANCE {
+  UINTN                                 Signature;
+  EFI_HII_PACKAGE_HEADER                FormPkgHdr;
+  UINT8                                 *IfrData;
+  LIST_ENTRY                            IfrEntry;
+} HII_IFR_PACKAGE_INSTANCE;
+
+//
+// Simple Font Package definitions
+//
+#define HII_S_FONT_PACKAGE_SIGNATURE    SIGNATURE_32 ('h','s','f','p')
+typedef struct _HII_SIMPLE_FONT_PACKAGE_INSTANCE {
+  UINTN                                 Signature;
+  EFI_HII_SIMPLE_FONT_PACKAGE_HDR       *SimpleFontPkgHdr;
+  LIST_ENTRY                            SimpleFontEntry;
+} HII_SIMPLE_FONT_PACKAGE_INSTANCE;
+
+//
+// Font Package definitions
+//
+#define HII_FONT_PACKAGE_SIGNATURE      SIGNATURE_32 ('h','i','f','p')
+typedef struct _HII_FONT_PACKAGE_INSTANCE {
+  UINTN                                 Signature;
+  EFI_HII_FONT_PACKAGE_HDR              *FontPkgHdr;
+  UINT16                                Height;
+  UINT16                                BaseLine;
+  UINT8                                 *GlyphBlock;
+  LIST_ENTRY                            FontEntry;
+  LIST_ENTRY                            GlyphInfoList;
+} HII_FONT_PACKAGE_INSTANCE;
+
+#define HII_GLYPH_INFO_SIGNATURE        SIGNATURE_32 ('h','g','i','s')
+typedef struct _HII_GLYPH_INFO {
+  UINTN                                 Signature;
+  LIST_ENTRY                            Entry;
+  CHAR16                                CharId;
+  EFI_HII_GLYPH_INFO                    Cell;
+} HII_GLYPH_INFO;
+
+#define HII_FONT_INFO_SIGNATURE         SIGNATURE_32 ('h','l','f','i')
+typedef struct _HII_FONT_INFO {
+  UINTN                                 Signature;
+  LIST_ENTRY                            Entry;
+  LIST_ENTRY                            *GlobalEntry;
+  UINT8                                 FontId;
+} HII_FONT_INFO;
+
+#define HII_GLOBAL_FONT_INFO_SIGNATURE  SIGNATURE_32 ('h','g','f','i')
+typedef struct _HII_GLOBAL_FONT_INFO {
+  UINTN                                 Signature;
+  LIST_ENTRY                            Entry;
+  HII_FONT_PACKAGE_INSTANCE             *FontPackage;
+  UINTN                                 FontInfoSize;
+  EFI_FONT_INFO                         *FontInfo;
+} HII_GLOBAL_FONT_INFO;
+
+//
+// Image Package definitions
+//
+
+#define HII_PIXEL_MASK                  0x80
+
+typedef struct _HII_IMAGE_PACKAGE_INSTANCE {
+  EFI_HII_IMAGE_PACKAGE_HDR             ImagePkgHdr;
+  UINT32                                ImageBlockSize;
+  UINT32                                PaletteInfoSize;
+  UINT8                                 *ImageBlock;
+  UINT8                                 *PaletteBlock;
+} HII_IMAGE_PACKAGE_INSTANCE;
+
+//
+// Keyboard Layout Pacakge definitions
+//
+#define HII_KB_LAYOUT_PACKAGE_SIGNATURE SIGNATURE_32 ('h','k','l','p')
+typedef struct _HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE {
+  UINTN                                 Signature;
+  UINT8                                 *KeyboardPkg;
+  LIST_ENTRY                            KeyboardEntry;
+} HII_KEYBOARD_LAYOUT_PACKAGE_INSTANCE;
+
+//
+// Guid Package definitions
+//
+#define HII_GUID_PACKAGE_SIGNATURE      SIGNATURE_32 ('h','i','g','p')
+typedef struct _HII_GUID_PACKAGE_INSTANCE {
+  UINTN                                 Signature;
+  UINT8                                 *GuidPkg;
+  LIST_ENTRY                            GuidEntry;
+} HII_GUID_PACKAGE_INSTANCE;
+
+//
+// A package list can contain only one or less than one device path package.
+// This rule also applies to image package since ImageId can not be duplicate.
+//
+typedef struct _HII_DATABASE_PACKAGE_LIST_INSTANCE {
+  EFI_HII_PACKAGE_LIST_HEADER           PackageListHdr;
+  LIST_ENTRY                            GuidPkgHdr;
+  LIST_ENTRY                            FormPkgHdr;
+  LIST_ENTRY                            KeyboardLayoutHdr;
+  LIST_ENTRY                            StringPkgHdr;
+  LIST_ENTRY                            FontPkgHdr;
+  HII_IMAGE_PACKAGE_INSTANCE            *ImagePkg;
+  LIST_ENTRY                            SimpleFontPkgHdr;
+  UINT8                                 *DevicePathPkg;
+} HII_DATABASE_PACKAGE_LIST_INSTANCE;
+
+#define HII_HANDLE_SIGNATURE            SIGNATURE_32 ('h','i','h','l')
+
+typedef struct {
+  UINTN               Signature;
+  LIST_ENTRY          Handle;
+  UINTN               Key;
+} HII_HANDLE;
+
+#define HII_DATABASE_RECORD_SIGNATURE   SIGNATURE_32 ('h','i','d','r')
+
+typedef struct _HII_DATABASE_RECORD {
+  UINTN                                 Signature;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE    *PackageList;
+  EFI_HANDLE                            DriverHandle;
+  EFI_HII_HANDLE                        Handle;
+  LIST_ENTRY                            DatabaseEntry;
+} HII_DATABASE_RECORD;
+
+#define HII_DATABASE_NOTIFY_SIGNATURE   SIGNATURE_32 ('h','i','d','n')
+
+typedef struct _HII_DATABASE_NOTIFY {
+  UINTN                                 Signature;
+  EFI_HANDLE                            NotifyHandle;
+  UINT8                                 PackageType;
+  EFI_GUID                              *PackageGuid;
+  EFI_HII_DATABASE_NOTIFY               PackageNotifyFn;
+  EFI_HII_DATABASE_NOTIFY_TYPE          NotifyType;
+  LIST_ENTRY                            DatabaseNotifyEntry;
+} HII_DATABASE_NOTIFY;
+
+#define HII_DATABASE_PRIVATE_DATA_SIGNATURE SIGNATURE_32 ('H', 'i', 'D', 'p')
+
+typedef struct _HII_DATABASE_PRIVATE_DATA {
+  UINTN                                 Signature;
+  LIST_ENTRY                            DatabaseList;
+  LIST_ENTRY                            DatabaseNotifyList;
+  EFI_HII_FONT_PROTOCOL                 HiiFont;
+  EFI_HII_IMAGE_PROTOCOL                HiiImage;
+  EFI_HII_STRING_PROTOCOL               HiiString;
+  EFI_HII_DATABASE_PROTOCOL             HiiDatabase;
+  EFI_HII_CONFIG_ROUTING_PROTOCOL       ConfigRouting;
+  LIST_ENTRY                            HiiHandleList;
+  INTN                                  HiiHandleCount;
+  LIST_ENTRY                            FontInfoList;  // global font info list
+  UINTN                                 Attribute;     // default system color
+  EFI_GUID                              CurrentLayoutGuid;
+  EFI_HII_KEYBOARD_LAYOUT               *CurrentLayout;
+} HII_DATABASE_PRIVATE_DATA;
+
+#define HII_FONT_DATABASE_PRIVATE_DATA_FROM_THIS(a) \
+  CR (a, \
+      HII_DATABASE_PRIVATE_DATA, \
+      HiiFont, \
+      HII_DATABASE_PRIVATE_DATA_SIGNATURE \
+      )
+
+#define HII_IMAGE_DATABASE_PRIVATE_DATA_FROM_THIS(a) \
+  CR (a, \
+      HII_DATABASE_PRIVATE_DATA, \
+      HiiImage, \
+      HII_DATABASE_PRIVATE_DATA_SIGNATURE \
+      )
+
+#define HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS(a) \
+  CR (a, \
+      HII_DATABASE_PRIVATE_DATA, \
+      HiiString, \
+      HII_DATABASE_PRIVATE_DATA_SIGNATURE \
+      )
+
+#define HII_DATABASE_DATABASE_PRIVATE_DATA_FROM_THIS(a) \
+  CR (a, \
+      HII_DATABASE_PRIVATE_DATA, \
+      HiiDatabase, \
+      HII_DATABASE_PRIVATE_DATA_SIGNATURE \
+      )
+
+#define CONFIG_ROUTING_DATABASE_PRIVATE_DATA_FROM_THIS(a) \
+  CR (a, \
+      HII_DATABASE_PRIVATE_DATA, \
+      ConfigRouting, \
+      HII_DATABASE_PRIVATE_DATA_SIGNATURE \
+      )
+
+//
+// Internal function prototypes.
+//
+
+/**
+  This function checks whether a handle is a valid EFI_HII_HANDLE.
+
+  @param  Handle                  Pointer to a EFI_HII_HANDLE
+
+  @retval TRUE                    Valid
+  @retval FALSE                   Invalid
+
+**/
+BOOLEAN
+IsHiiHandleValid (
+  EFI_HII_HANDLE Handle
+  );
+
+
+/**
+  This function checks whether EFI_FONT_INFO exists in current database. If
+  FontInfoMask is specified, check what options can be used to make a match.
+  Note that the masks relate to where the system default should be supplied
+  are ignored by this function.
+
+  @param  Private                 Hii database private structure.
+  @param  FontInfo                Points to EFI_FONT_INFO structure.
+  @param  FontInfoMask            If not NULL, describes what options can be used
+                                  to make a match between the font requested and
+                                  the font available. The caller must guarantee
+                                  this mask is valid.
+  @param  FontHandle              On entry, Points to the font handle returned by a
+                                  previous  call to GetFontInfo() or NULL to start
+                                  with the first font.
+  @param  GlobalFontInfo          If not NULL, output the corresponding globa font
+                                  info.
+
+  @retval TRUE                    Existed
+  @retval FALSE                   Not existed
+
+**/
+BOOLEAN
+IsFontInfoExisted (
+  IN  HII_DATABASE_PRIVATE_DATA *Private,
+  IN  EFI_FONT_INFO             *FontInfo,
+  IN  EFI_FONT_INFO_MASK        *FontInfoMask,   OPTIONAL
+  IN  EFI_FONT_HANDLE           FontHandle,      OPTIONAL
+  OUT HII_GLOBAL_FONT_INFO      **GlobalFontInfo OPTIONAL
+  );
+
+/**
+
+   This function invokes the matching registered function.
+    
+   @param  Private           HII Database driver private structure.
+   @param  NotifyType        The type of change concerning the database.
+   @param  PackageInstance   Points to the package referred to by the notification.
+   @param  PackageType       Package type
+   @param  Handle            The handle of the package list which contains the specified package.
+    
+   @retval EFI_SUCCESS            Already checked all registered function and invoked 
+                                  if matched.
+   @retval EFI_INVALID_PARAMETER  Any input parameter is not valid.
+     
+**/
+EFI_STATUS
+InvokeRegisteredFunction (
+  IN HII_DATABASE_PRIVATE_DATA    *Private, 
+  IN EFI_HII_DATABASE_NOTIFY_TYPE NotifyType,
+  IN VOID                         *PackageInstance,
+  IN UINT8                        PackageType,
+  IN EFI_HII_HANDLE               Handle
+  )
+;
+
+/**
+  Retrieve system default font and color.
+
+  @param  Private                 HII database driver private data.
+  @param  FontInfo                Points to system default font output-related
+                                  information. It's caller's responsibility to free
+                                  this buffer.
+  @param  FontInfoSize            If not NULL, output the size of buffer FontInfo.
+
+  @retval EFI_SUCCESS             Cell information is added to the GlyphInfoList.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+  @retval EFI_INVALID_PARAMETER   Any input parameter is invalid.
+
+**/
+EFI_STATUS
+GetSystemFont (
+  IN  HII_DATABASE_PRIVATE_DATA      *Private,
+  OUT EFI_FONT_DISPLAY_INFO          **FontInfo,
+  OUT UINTN                          *FontInfoSize OPTIONAL
+  );
+
+
+/**
+  Parse all string blocks to find a String block specified by StringId.
+  If StringId = (EFI_STRING_ID) (-1), find out all EFI_HII_SIBT_FONT blocks
+  within this string package and backup its information. If LastStringId is 
+  specified, the string id of last string block will also be output.
+  If StringId = 0, output the string id of last string block (EFI_HII_SIBT_STRING).
+
+  @param  Private                 Hii database private structure.
+  @param  StringPackage           Hii string package instance.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.
+  @param  BlockType               Output the block type of found string block.
+  @param  StringBlockAddr         Output the block address of found string block.
+  @param  StringTextOffset        Offset, relative to the found block address, of
+                                  the  string text information.
+  @param  LastStringId            Output the last string id when StringId = 0 or StringId = -1.
+  @param  StartStringId           The first id in the skip block which StringId in the block.
+
+  @retval EFI_SUCCESS             The string text and font is retrieved
+                                  successfully.
+  @retval EFI_NOT_FOUND           The specified text or font info can not be found
+                                  out.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+FindStringBlock (
+  IN HII_DATABASE_PRIVATE_DATA        *Private,
+  IN  HII_STRING_PACKAGE_INSTANCE     *StringPackage,
+  IN  EFI_STRING_ID                   StringId,
+  OUT UINT8                           *BlockType, OPTIONAL
+  OUT UINT8                           **StringBlockAddr, OPTIONAL
+  OUT UINTN                           *StringTextOffset, OPTIONAL
+  OUT EFI_STRING_ID                   *LastStringId, OPTIONAL
+  OUT EFI_STRING_ID                   *StartStringId OPTIONAL
+  );
+
+
+/**
+  Parse all glyph blocks to find a glyph block specified by CharValue.
+  If CharValue = (CHAR16) (-1), collect all default character cell information
+  within this font package and backup its information.
+
+  @param  FontPackage             Hii string package instance.
+  @param  CharValue               Unicode character value, which identifies a glyph
+                                  block.
+  @param  GlyphBuffer             Output the corresponding bitmap data of the found
+                                  block. It is the caller's responsiblity to free
+                                  this buffer.
+  @param  Cell                    Output cell information of the encoded bitmap.
+  @param  GlyphBufferLen          If not NULL, output the length of GlyphBuffer.
+
+  @retval EFI_SUCCESS             The bitmap data is retrieved successfully.
+  @retval EFI_NOT_FOUND           The specified CharValue does not exist in current
+                                  database.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+FindGlyphBlock (
+  IN  HII_FONT_PACKAGE_INSTANCE      *FontPackage,
+  IN  CHAR16                         CharValue,
+  OUT UINT8                          **GlyphBuffer, OPTIONAL
+  OUT EFI_HII_GLYPH_INFO             *Cell, OPTIONAL
+  OUT UINTN                          *GlyphBufferLen OPTIONAL
+  );
+
+/**
+  This function exports Form packages to a buffer.
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  Handle                 Identification of a package list.
+  @param  PackageList            Pointer to a package list which will be exported.
+  @param  UsedSize               The length of buffer be used.
+  @param  BufferSize             Length of the Buffer.
+  @param  Buffer                 Allocated space for storing exported data.
+  @param  ResultSize             The size of the already exported content of  this
+                                 package list.
+
+  @retval EFI_SUCCESS            Form Packages are exported successfully.
+  @retval EFI_INVALID_PARAMETER  Any input parameter is invalid.
+
+**/
+EFI_STATUS
+ExportFormPackages (
+  IN HII_DATABASE_PRIVATE_DATA          *Private,
+  IN EFI_HII_HANDLE                     Handle,
+  IN HII_DATABASE_PACKAGE_LIST_INSTANCE *PackageList,
+  IN UINTN                              UsedSize,
+  IN UINTN                              BufferSize,
+  IN OUT VOID                           *Buffer,
+  IN OUT UINTN                          *ResultSize
+  );
+
+//
+// EFI_HII_FONT_PROTOCOL protocol interfaces
+//
+
+
+/**
+  Renders a string to a bitmap or to the display.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  Flags                   Describes how the string is to be drawn.
+  @param  String                  Points to the null-terminated string to be
+                                  displayed.
+  @param  StringInfo              Points to the string output information,
+                                  including the color and font.  If NULL, then the
+                                  string will be output in the default system font
+                                  and color.
+  @param  Blt                     If this points to a non-NULL on entry, this
+                                  points to the image, which is Width pixels   wide
+                                  and Height pixels high. The string will be drawn
+                                  onto this image and
+                                  EFI_HII_OUT_FLAG_CLIP is implied. If this points
+                                  to a NULL on entry, then a              buffer
+                                  will be allocated to hold the generated image and
+                                  the pointer updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  BltX                    Together with BltX, Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  BltY                    Together with BltY, Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  RowInfoArray            If this is non-NULL on entry, then on exit, this
+                                  will point to an allocated buffer    containing
+                                  row information and RowInfoArraySize will be
+                                  updated to contain the        number of elements.
+                                  This array describes the characters which were at
+                                  least partially drawn and the heights of the
+                                  rows. It is the caller's responsibility to free
+                                  this buffer.
+  @param  RowInfoArraySize        If this is non-NULL on entry, then on exit it
+                                  contains the number of elements in RowInfoArray.
+  @param  ColumnInfoArray         If this is non-NULL, then on return it will be
+                                  filled with the horizontal offset for each
+                                  character in the string on the row where it is
+                                  displayed. Non-printing characters will     have
+                                  the offset ~0. The caller is responsible to
+                                  allocate a buffer large enough so that    there
+                                  is one entry for each character in the string,
+                                  not including the null-terminator. It is possible
+                                  when character display is normalized that some
+                                  character cells overlap.
+
+  @retval EFI_SUCCESS             The string was successfully rendered.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate an output buffer for
+                                  RowInfoArray or Blt.
+  @retval EFI_INVALID_PARAMETER The String or Blt.
+  @retval EFI_INVALID_PARAMETER Flags were invalid combination..
+
+**/
+EFI_STATUS
+EFIAPI
+HiiStringToImage (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  EFI_HII_OUT_FLAGS              Flags,
+  IN  CONST EFI_STRING               String,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfo       OPTIONAL,
+  IN  OUT EFI_IMAGE_OUTPUT           **Blt,
+  IN  UINTN                          BltX,
+  IN  UINTN                          BltY,
+  OUT EFI_HII_ROW_INFO               **RowInfoArray    OPTIONAL,
+  OUT UINTN                          *RowInfoArraySize OPTIONAL,
+  OUT UINTN                          *ColumnInfoArray  OPTIONAL
+  );
+
+
+/**
+  Render a string to a bitmap or the screen containing the contents of the specified string.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  Flags                   Describes how the string is to be drawn.
+  @param  PackageList             The package list in the HII database to search
+                                  for the specified string.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.
+  @param  Language                Points to the language for the retrieved string.
+                                  If NULL, then the current system language is
+                                  used.
+  @param  StringInfo              Points to the string output information,
+                                  including the color and font.  If NULL, then the
+                                  string will be output in the default system font
+                                  and color.
+  @param  Blt                     If this points to a non-NULL on entry, this
+                                  points to the image, which is Width pixels   wide
+                                  and Height pixels high. The string will be drawn
+                                  onto this image and
+                                  EFI_HII_OUT_FLAG_CLIP is implied. If this points
+                                  to a NULL on entry, then a              buffer
+                                  will be allocated to hold the generated image and
+                                  the pointer updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  BltX                    Together with BltX, Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  BltY                    Together with BltY, Specifies the offset from the left and top edge
+                                  of the image of the first character cell in the
+                                  image.
+  @param  RowInfoArray            If this is non-NULL on entry, then on exit, this
+                                  will point to an allocated buffer    containing
+                                  row information and RowInfoArraySize will be
+                                  updated to contain the        number of elements.
+                                  This array describes the characters which were at
+                                  least partially drawn and the heights of the
+                                  rows. It is the caller's responsibility to free
+                                  this buffer.
+  @param  RowInfoArraySize        If this is non-NULL on entry, then on exit it
+                                  contains the number of elements in RowInfoArray.
+  @param  ColumnInfoArray         If this is non-NULL, then on return it will be
+                                  filled with the horizontal offset for each
+                                  character in the string on the row where it is
+                                  displayed. Non-printing characters will     have
+                                  the offset ~0. The caller is responsible to
+                                  allocate a buffer large enough so that    there
+                                  is one entry for each character in the string,
+                                  not including the null-terminator. It is possible
+                                  when character display is normalized that some
+                                  character cells overlap.
+
+  @retval EFI_SUCCESS             The string was successfully rendered.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate an output buffer for
+                                  RowInfoArray or Blt.
+  @retval EFI_INVALID_PARAMETER The Blt or PackageList was NULL.
+  @retval EFI_INVALID_PARAMETER Flags were invalid combination.
+  @retval EFI_NOT_FOUND         The specified PackageList is not in the Database or the stringid is not 
+                          in the specified PackageList. 
+
+**/
+EFI_STATUS
+EFIAPI
+HiiStringIdToImage (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  EFI_HII_OUT_FLAGS              Flags,
+  IN  EFI_HII_HANDLE                 PackageList,
+  IN  EFI_STRING_ID                  StringId,
+  IN  CONST CHAR8*                   Language,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfo       OPTIONAL,
+  IN  OUT EFI_IMAGE_OUTPUT           **Blt,
+  IN  UINTN                          BltX,
+  IN  UINTN                          BltY,
+  OUT EFI_HII_ROW_INFO               **RowInfoArray    OPTIONAL,
+  OUT UINTN                          *RowInfoArraySize OPTIONAL,
+  OUT UINTN                          *ColumnInfoArray  OPTIONAL
+  );
+
+
+/**
+  Convert the glyph for a single character into a bitmap.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  Char                    Character to retrieve.
+  @param  StringInfo              Points to the string font and color information
+                                  or NULL if the string should use the default
+                                  system font and color.
+  @param  Blt                     Thus must point to a NULL on entry. A buffer will
+                                  be allocated to hold the output and the pointer
+                                  updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  Baseline                Number of pixels from the bottom of the bitmap to
+                                  the baseline.
+
+  @retval EFI_SUCCESS             Glyph bitmap created.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate the output buffer Blt.
+  @retval EFI_WARN_UNKNOWN_GLYPH  The glyph was unknown and was replaced with the
+                                  glyph for Unicode character 0xFFFD.
+  @retval EFI_INVALID_PARAMETER   Blt is NULL or *Blt is not NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetGlyph (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  CHAR16                         Char,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfo,
+  OUT EFI_IMAGE_OUTPUT               **Blt,
+  OUT UINTN                          *Baseline OPTIONAL
+  );
+
+
+/**
+  This function iterates through fonts which match the specified font, using
+  the specified criteria. If String is non-NULL, then all of the characters in
+  the string must exist in order for a candidate font to be returned.
+
+  @param  This                    A pointer to the EFI_HII_FONT_PROTOCOL instance.
+  @param  FontHandle              On entry, points to the font handle returned by a
+                                   previous call to GetFontInfo() or NULL to start
+                                  with the  first font. On return, points to the
+                                  returned font handle or points to NULL if there
+                                  are no more matching fonts.
+  @param  StringInfoIn            Upon entry, points to the font to return
+                                  information about. If NULL, then the information about the system default 
+                                  font will be returned.
+  @param  StringInfoOut           Upon return, contains the matching font's
+                                  information.  If NULL, then no information is
+                                  returned. It's caller's responsibility to free
+                                  this buffer.
+  @param  String                  Points to the string which will be tested to
+                                  determine  if all characters are available. If
+                                  NULL, then any font  is acceptable.
+
+  @retval EFI_SUCCESS             Matching font returned successfully.
+  @retval EFI_NOT_FOUND           No matching font was found.
+  @retval EFI_INVALID_PARAMETER   StringInfoIn is NULL.
+  @retval EFI_INVALID_PARAMETER  StringInfoIn->FontInfoMask is an invalid combination.
+  @retval EFI_OUT_OF_RESOURCES    There were insufficient resources to complete the
+                                  request.
+**/
+EFI_STATUS
+EFIAPI
+HiiGetFontInfo (
+  IN  CONST EFI_HII_FONT_PROTOCOL    *This,
+  IN  OUT   EFI_FONT_HANDLE          *FontHandle,
+  IN  CONST EFI_FONT_DISPLAY_INFO    *StringInfoIn, OPTIONAL
+  OUT       EFI_FONT_DISPLAY_INFO    **StringInfoOut,
+  IN  CONST EFI_STRING               String OPTIONAL
+  );
+
+//
+// EFI_HII_IMAGE_PROTOCOL interfaces
+//
+
+
+/**
+  This function adds the image Image to the group of images owned by PackageList, and returns
+  a new image identifier (ImageId).
+
+  @param  This                    A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  PackageList             Handle of the package list where this image will
+                                  be added.
+  @param  ImageId                 On return, contains the new image id, which is
+                                  unique within PackageList.
+  @param  Image                   Points to the image.
+
+  @retval EFI_SUCCESS             The new image was added successfully.
+  @retval EFI_NOT_FOUND           The specified PackageList could not be found in
+                                  database.
+  @retval EFI_OUT_OF_RESOURCES    Could not add the image due to lack of resources.
+  @retval EFI_INVALID_PARAMETER   Image is NULL or ImageId is NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiNewImage (
+  IN  CONST EFI_HII_IMAGE_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                 PackageList,
+  OUT EFI_IMAGE_ID                   *ImageId,
+  IN  CONST EFI_IMAGE_INPUT          *Image
+  );
+
+
+/**
+  This function retrieves the image specified by ImageId which is associated with
+  the specified PackageList and copies it into the buffer specified by Image.
+
+  @param  This                    A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  PackageList             Handle of the package list where this image will
+                                  be searched.
+  @param  ImageId                 The image's id,, which is unique within
+                                  PackageList.
+  @param  Image                   Points to the image.
+
+  @retval EFI_SUCCESS             The new image was returned successfully.
+  @retval EFI_NOT_FOUND           The image specified by ImageId is not available.
+                                                 The specified PackageList is not in the database.
+  @retval EFI_BUFFER_TOO_SMALL    The buffer specified by ImageSize is too small to
+                                  hold the image.
+  @retval EFI_INVALID_PARAMETER   The Image or ImageSize was NULL.
+  @retval EFI_OUT_OF_RESOURCES   The bitmap could not be retrieved because there was not
+                                                       enough memory.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetImage (
+  IN  CONST EFI_HII_IMAGE_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                 PackageList,
+  IN  EFI_IMAGE_ID                   ImageId,
+  OUT EFI_IMAGE_INPUT                *Image
+  );
+
+
+/**
+  This function updates the image specified by ImageId in the specified PackageListHandle to
+  the image specified by Image.
+
+  @param  This                    A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  PackageList             The package list containing the images.
+  @param  ImageId                 The image's id,, which is unique within
+                                  PackageList.
+  @param  Image                   Points to the image.
+
+  @retval EFI_SUCCESS             The new image was updated successfully.
+  @retval EFI_NOT_FOUND           The image specified by ImageId is not in the
+                                                database. The specified PackageList is not in the database.
+  @retval EFI_INVALID_PARAMETER   The Image was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiSetImage (
+  IN CONST EFI_HII_IMAGE_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                  PackageList,
+  IN EFI_IMAGE_ID                    ImageId,
+  IN CONST EFI_IMAGE_INPUT           *Image
+  );
+
+
+/**
+  This function renders an image to a bitmap or the screen using the specified
+  color and options. It draws the image on an existing bitmap, allocates a new
+  bitmap or uses the screen. The images can be clipped.
+
+  @param  This                    A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  Flags                   Describes how the image is to be drawn.
+  @param  Image                   Points to the image to be displayed.
+  @param  Blt                     If this points to a non-NULL on entry, this
+                                  points to the image, which is Width pixels wide
+                                  and Height pixels high.  The image will be drawn
+                                  onto this image and  EFI_HII_DRAW_FLAG_CLIP is
+                                  implied. If this points to a  NULL on entry, then
+                                  a buffer will be allocated to hold  the generated
+                                  image and the pointer updated on exit. It is the
+                                  caller's responsibility to free this buffer.
+  @param  BltX                    Specifies the offset from the left and top edge
+                                  of the  output image of the first pixel in the
+                                  image.
+  @param  BltY                    Specifies the offset from the left and top edge
+                                  of the  output image of the first pixel in the
+                                  image.
+
+  @retval EFI_SUCCESS             The image was successfully drawn.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate an output buffer for Blt.
+  @retval EFI_INVALID_PARAMETER   The Image or Blt was NULL.
+  @retval EFI_INVALID_PARAMETER   Any combination of Flags is invalid.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiDrawImage (
+  IN CONST EFI_HII_IMAGE_PROTOCOL    *This,
+  IN EFI_HII_DRAW_FLAGS              Flags,
+  IN CONST EFI_IMAGE_INPUT           *Image,
+  IN OUT EFI_IMAGE_OUTPUT            **Blt,
+  IN UINTN                           BltX,
+  IN UINTN                           BltY
+  );
+
+
+/**
+  This function renders an image to a bitmap or the screen using the specified
+  color and options. It draws the image on an existing bitmap, allocates a new
+  bitmap or uses the screen. The images can be clipped.
+
+  @param  This                    A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  Flags                   Describes how the image is to be drawn.
+  @param  PackageList             The package list in the HII database to search
+                                  for the  specified image.
+  @param  ImageId                 The image's id, which is unique within
+                                  PackageList.
+  @param  Blt                     If this points to a non-NULL on entry, this
+                                  points to the image, which is Width pixels wide
+                                  and Height pixels high. The image will be drawn
+                                  onto this image and
+                                  EFI_HII_DRAW_FLAG_CLIP is implied. If this points
+                                  to a  NULL on entry, then a buffer will be
+                                  allocated to hold  the generated image and the
+                                  pointer updated on exit. It is the caller's
+                                  responsibility to free this buffer.
+  @param  BltX                    Specifies the offset from the left and top edge
+                                  of the  output image of the first pixel in the
+                                  image.
+  @param  BltY                    Specifies the offset from the left and top edge
+                                  of the  output image of the first pixel in the
+                                  image.
+
+  @retval EFI_SUCCESS             The image was successfully drawn.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate an output buffer for Blt.
+  @retval EFI_INVALID_PARAMETER  The Blt was NULL.
+  @retval EFI_NOT_FOUND          The image specified by ImageId is not in the database. 
+                           The specified PackageList is not in the database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiDrawImageId (
+  IN CONST EFI_HII_IMAGE_PROTOCOL    *This,
+  IN EFI_HII_DRAW_FLAGS              Flags,
+  IN EFI_HII_HANDLE                  PackageList,
+  IN EFI_IMAGE_ID                    ImageId,
+  IN OUT EFI_IMAGE_OUTPUT            **Blt,
+  IN UINTN                           BltX,
+  IN UINTN                           BltY
+  )
+
+;
+
+//
+// EFI_HII_STRING_PROTOCOL
+//
+
+
+/**
+  This function adds the string String to the group of strings owned by PackageList, with the
+  specified font information StringFontInfo and returns a new string id.
+
+  @param  This                    A pointer to the EFI_HII_STRING_PROTOCOL
+                                  instance.
+  @param  PackageList             Handle of the package list where this string will
+                                  be added.
+  @param  StringId                On return, contains the new strings id, which is
+                                  unique within PackageList.
+  @param  Language                Points to the language for the new string.
+  @param  LanguageName            Points to the printable language name to
+                                  associate with the passed in  Language field.If
+                                  LanguageName is not NULL and the string package
+                                  header's LanguageName  associated with a given
+                                  Language is not zero, the LanguageName being
+                                  passed  in will be ignored.
+  @param  String                  Points to the new null-terminated string.
+  @param  StringFontInfo          Points to the new string's font information or
+                                  NULL if the string should have the default system
+                                  font, size and style.
+
+  @retval EFI_SUCCESS             The new string was added successfully.
+  @retval EFI_NOT_FOUND           The specified PackageList could not be found in
+                                  database.
+  @retval EFI_OUT_OF_RESOURCES    Could not add the string due to lack of
+                                  resources.
+  @retval EFI_INVALID_PARAMETER   String is NULL or StringId is NULL or Language is
+                                  NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiNewString (
+  IN  CONST EFI_HII_STRING_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                  PackageList,
+  OUT EFI_STRING_ID                   *StringId,
+  IN  CONST CHAR8                     *Language,
+  IN  CONST CHAR16                    *LanguageName, OPTIONAL
+  IN  CONST EFI_STRING                String,
+  IN  CONST EFI_FONT_INFO             *StringFontInfo OPTIONAL
+  );
+
+
+/**
+  This function retrieves the string specified by StringId which is associated
+  with the specified PackageList in the language Language and copies it into
+  the buffer specified by String.
+
+  @param  This                    A pointer to the EFI_HII_STRING_PROTOCOL
+                                  instance.
+  @param  Language                Points to the language for the retrieved string.
+  @param  PackageList             The package list in the HII database to search
+                                  for the  specified string.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.
+  @param  String                  Points to the new null-terminated string.
+  @param  StringSize              On entry, points to the size of the buffer
+                                  pointed to by  String, in bytes. On return,
+                                  points to the length of the string, in bytes.
+  @param  StringFontInfo          If not NULL, points to the string's font
+                                  information.  It's caller's responsibility to
+                                  free this buffer.
+
+  @retval EFI_SUCCESS             The string was returned successfully.
+  @retval EFI_NOT_FOUND           The string specified by StringId is not
+                                  available.
+  @retval EFI_NOT_FOUND           The string specified by StringId is available but
+                                                not in the specified language.
+                                                The specified PackageList is not in the database.
+  @retval EFI_INVALID_LANGUAGE   - The string specified by StringId is available but
+  @retval EFI_BUFFER_TOO_SMALL    The buffer specified by StringSize is too small
+                                  to  hold the string.
+  @retval EFI_INVALID_PARAMETER   The String or Language or StringSize was NULL.
+  @retval EFI_OUT_OF_RESOURCES    There were insufficient resources to complete the
+                                   request.
+
+**/
+EFI_STATUS
+EFIAPI
+IntHiiGetString (
+  IN  CONST EFI_HII_STRING_PROTOCOL   *This,
+  IN  CONST CHAR8                     *Language,
+  IN  EFI_HII_HANDLE                  PackageList,
+  IN  EFI_STRING_ID                   StringId,
+  OUT EFI_STRING                      String,
+  IN  OUT UINTN                       *StringSize,
+  OUT EFI_FONT_INFO                   **StringFontInfo OPTIONAL
+  );
+
+
+/**
+  This function updates the string specified by StringId in the specified PackageList to the text
+  specified by String and, optionally, the font information specified by StringFontInfo.
+
+  @param  This                    A pointer to the EFI_HII_STRING_PROTOCOL
+                                  instance.
+  @param  PackageList             The package list containing the strings.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.
+  @param  Language                Points to the language for the updated string.
+  @param  String                  Points to the new null-terminated string.
+  @param  StringFontInfo          Points to the string's font information or NULL
+                                  if the string font information is not changed.
+
+  @retval EFI_SUCCESS             The string was updated successfully.
+  @retval EFI_NOT_FOUND           The string specified by StringId is not in the
+                                  database.
+  @retval EFI_INVALID_PARAMETER   The String or Language was NULL.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+EFIAPI
+IntHiiSetString (
+  IN CONST EFI_HII_STRING_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                   PackageList,
+  IN EFI_STRING_ID                    StringId,
+  IN CONST CHAR8                      *Language,
+  IN CONST EFI_STRING                 String,
+  IN CONST EFI_FONT_INFO              *StringFontInfo OPTIONAL
+  );
+
+
+/**
+  This function returns the list of supported languages, in the format specified
+  in Appendix M of UEFI 2.1 spec.
+
+  @param  This                    A pointer to the EFI_HII_STRING_PROTOCOL
+                                  instance.
+  @param  PackageList             The package list to examine.
+  @param  Languages               Points to the buffer to hold the returned
+                                  null-terminated ASCII string.
+  @param  LanguagesSize           On entry, points to the size of the buffer
+                                  pointed to by  Languages, in bytes. On  return,
+                                  points to the length of Languages, in bytes.
+
+  @retval EFI_SUCCESS             The languages were returned successfully.
+  @retval EFI_INVALID_PARAMETER   The Languages or LanguagesSize was NULL.
+  @retval EFI_BUFFER_TOO_SMALL    The LanguagesSize is too small to hold the list
+                                  of  supported languages. LanguageSize is updated
+                                  to contain the required size.
+  @retval EFI_NOT_FOUND           Could not find string package in specified
+                                  packagelist.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetLanguages (
+  IN CONST EFI_HII_STRING_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                   PackageList,
+  IN OUT CHAR8                        *Languages,
+  IN OUT UINTN                        *LanguagesSize
+  );
+
+
+/**
+  Each string package has associated with it a single primary language and zero
+  or more secondary languages. This routine returns the secondary languages
+  associated with a package list.
+
+  @param  This                    A pointer to the EFI_HII_STRING_PROTOCOL
+                                  instance.
+  @param  PackageList             The package list to examine.
+  @param  PrimaryLanguage         Points to the null-terminated ASCII string that specifies
+                                  the primary language. Languages are specified in the
+                                  format specified in Appendix M of the UEFI 2.0 specification.
+  @param  SecondaryLanguages      Points to the buffer to hold the returned null-terminated
+                                  ASCII string that describes the list of
+                                  secondary languages for the specified
+                                  PrimaryLanguage. If there are no secondary
+                                  languages, the function returns successfully,
+                                  but this is set to NULL.
+  @param  SecondaryLanguagesSize  On entry, points to the size of the buffer
+                                  pointed to by SecondaryLanguages, in bytes. On
+                                  return, points to the length of SecondaryLanguages
+                                  in bytes.
+
+  @retval EFI_SUCCESS             Secondary languages were correctly returned.
+  @retval EFI_INVALID_PARAMETER   PrimaryLanguage or SecondaryLanguages or
+                                  SecondaryLanguagesSize was NULL.
+  @retval EFI_BUFFER_TOO_SMALL    The buffer specified by SecondaryLanguagesSize is
+                                  too small to hold the returned information.
+                                  SecondaryLanguageSize is updated to hold the size of
+                                  the buffer required.
+  @retval EFI_INVALID_LANGUAGE    The language specified by PrimaryLanguage is not
+                                  present in the specified package list.
+  @retval EFI_NOT_FOUND          The specified PackageList is not in the Database.                                
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetSecondaryLanguages (
+  IN CONST EFI_HII_STRING_PROTOCOL   *This,
+  IN EFI_HII_HANDLE                  PackageList,
+  IN CONST CHAR8                     *PrimaryLanguage,
+  IN OUT CHAR8                       *SecondaryLanguages,
+  IN OUT UINTN                       *SecondaryLanguagesSize
+  );
+
+//
+// EFI_HII_DATABASE_PROTOCOL protocol interfaces
+//
+
+
+/**
+  This function adds the packages in the package list to the database and returns a handle. If there is a
+  EFI_DEVICE_PATH_PROTOCOL associated with the DriverHandle, then this function will
+  create a package of type EFI_PACKAGE_TYPE_DEVICE_PATH and add it to the package list.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  PackageList             A pointer to an EFI_HII_PACKAGE_LIST_HEADER
+                                  structure.
+  @param  DriverHandle            Associate the package list with this EFI handle.
+                                  If a NULL is specified, this data will not be associate
+                                  with any drivers and cannot have a callback induced.
+  @param  Handle                  A pointer to the EFI_HII_HANDLE instance.
+
+  @retval EFI_SUCCESS             The package list associated with the Handle was
+                                  added to the HII database.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate necessary resources for the
+                                  new database contents.
+  @retval EFI_INVALID_PARAMETER   PackageList is NULL or Handle is NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiNewPackageList (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN CONST EFI_HII_PACKAGE_LIST_HEADER  *PackageList,
+  IN CONST EFI_HANDLE                   DriverHandle, OPTIONAL
+  OUT EFI_HII_HANDLE                    *Handle
+  );
+
+
+/**
+  This function removes the package list that is associated with a handle Handle
+  from the HII database. Before removing the package, any registered functions
+  with the notification type REMOVE_PACK and the same package type will be called.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  Handle                  The handle that was registered to the data that
+                                  is requested  for removal.
+
+  @retval EFI_SUCCESS             The data associated with the Handle was removed
+                                  from  the HII database.
+  @retval EFI_NOT_FOUND           The specified Handle is not in database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiRemovePackageList (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                     Handle
+  );
+
+
+/**
+  This function updates the existing package list (which has the specified Handle)
+  in the HII databases, using the new package list specified by PackageList.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  Handle                  The handle that was registered to the data that
+                                  is  requested to be updated.
+  @param  PackageList             A pointer to an EFI_HII_PACKAGE_LIST_HEADER
+                                  package.
+
+  @retval EFI_SUCCESS             The HII database was successfully updated.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate enough memory for the updated
+                                  database.
+  @retval EFI_INVALID_PARAMETER  PackageList was NULL.
+  @retval EFI_NOT_FOUND          The specified Handle is not in database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiUpdatePackageList (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                     Handle,
+  IN CONST EFI_HII_PACKAGE_LIST_HEADER  *PackageList
+  );
+
+
+/**
+  This function returns a list of the package handles of the specified type
+  that are currently active in the database. The pseudo-type
+  EFI_HII_PACKAGE_TYPE_ALL will cause all package handles to be listed.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  PackageType             Specifies the package type of the packages to
+                                  list or EFI_HII_PACKAGE_TYPE_ALL for all packages
+                                  to be listed.
+  @param  PackageGuid             If PackageType is EFI_HII_PACKAGE_TYPE_GUID, then
+                                  this  is the pointer to the GUID which must match
+                                  the Guid field of EFI_HII_GUID_PACKAGE_GUID_HDR.
+                                  Otherwise,  it must be NULL.
+  @param  HandleBufferLength      On input, a pointer to the length of the handle
+                                  buffer.  On output, the length of the handle
+                                  buffer that is required for the handles found.
+  @param  Handle                  An array of EFI_HII_HANDLE instances returned.
+
+  @retval EFI_SUCCESS             The matching handles are outputed successfully.
+                                                HandleBufferLength is updated with the actual length.
+  @retval EFI_BUFFER_TO_SMALL     The HandleBufferLength parameter indicates that
+                                  Handle is too small to support the number of
+                                  handles. HandleBufferLength is updated with a
+                                  value that will  enable the data to fit.
+  @retval EFI_NOT_FOUND           No matching handle could not be found in
+                                  database.
+  @retval EFI_INVALID_PARAMETER   Handle or HandleBufferLength was NULL.
+  @retval EFI_INVALID_PARAMETER  PackageType is not a EFI_HII_PACKAGE_TYPE_GUID but
+                         PackageGuid is not NULL, PackageType is a EFI_HII_
+                         PACKAGE_TYPE_GUID but PackageGuid is NULL.
+  
+
+**/
+EFI_STATUS
+EFIAPI
+HiiListPackageLists (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  UINT8                             PackageType,
+  IN  CONST EFI_GUID                    *PackageGuid,
+  IN  OUT UINTN                         *HandleBufferLength,
+  OUT EFI_HII_HANDLE                    *Handle
+  );
+
+
+/**
+  This function will export one or all package lists in the database to a buffer.
+  For each package list exported, this function will call functions registered
+  with EXPORT_PACK and then copy the package list to the buffer.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  Handle                  An EFI_HII_HANDLE that corresponds to the desired
+                                  package list in the HII database to export or
+                                  NULL to indicate  all package lists should be
+                                  exported.
+  @param  BufferSize              On input, a pointer to the length of the buffer.
+                                  On output, the length of the buffer that is
+                                  required for the exported data.
+  @param  Buffer                  A pointer to a buffer that will contain the
+                                  results of  the export function.
+
+  @retval EFI_SUCCESS             Package exported.
+  @retval EFI_BUFFER_TO_SMALL     The HandleBufferLength parameter indicates that
+                                  Handle is too small to support the number of
+                                  handles.      HandleBufferLength is updated with
+                                  a value that will enable the data to fit.
+  @retval EFI_NOT_FOUND           The specifiecd Handle could not be found in the
+                                  current database.
+  @retval EFI_INVALID_PARAMETER   Handle or Buffer or BufferSize was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiExportPackageLists (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                    Handle,
+  IN  OUT UINTN                         *BufferSize,
+  OUT EFI_HII_PACKAGE_LIST_HEADER       *Buffer
+  );
+
+
+/**
+  This function registers a function which will be called when specified actions related to packages of
+  the specified type occur in the HII database. By registering a function, other HII-related drivers are
+  notified when specific package types are added, removed or updated in the HII database.
+  Each driver or application which registers a notification should use
+  EFI_HII_DATABASE_PROTOCOL.UnregisterPackageNotify() before exiting.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  PackageType             Specifies the package type of the packages to
+                                  list or EFI_HII_PACKAGE_TYPE_ALL for all packages
+                                  to be listed.
+  @param  PackageGuid             If PackageType is EFI_HII_PACKAGE_TYPE_GUID, then
+                                  this is the pointer to the GUID which must match
+                                  the Guid field of
+                                  EFI_HII_GUID_PACKAGE_GUID_HDR. Otherwise, it must
+                                  be NULL.
+  @param  PackageNotifyFn         Points to the function to be called when the
+                                  event specified by
+                                  NotificationType occurs.
+  @param  NotifyType              Describes the types of notification which this
+                                  function will be receiving.
+  @param  NotifyHandle            Points to the unique handle assigned to the
+                                  registered notification. Can be used in
+                                  EFI_HII_DATABASE_PROTOCOL.UnregisterPackageNotify()
+                                  to stop notifications.
+
+  @retval EFI_SUCCESS             Notification registered successfully.
+  @retval EFI_OUT_OF_RESOURCES    Unable to allocate necessary data structures
+  @retval EFI_INVALID_PARAMETER   NotifyHandle is NULL.
+  @retval EFI_INVALID_PARAMETER   PackageGuid is not NULL when PackageType is not
+                                  EFI_HII_PACKAGE_TYPE_GUID.
+  @retval EFI_INVALID_PARAMETER   PackageGuid is NULL when PackageType is
+                                  EFI_HII_PACKAGE_TYPE_GUID.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiRegisterPackageNotify (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  UINT8                             PackageType,
+  IN  CONST EFI_GUID                    *PackageGuid,
+  IN  CONST EFI_HII_DATABASE_NOTIFY     PackageNotifyFn,
+  IN  EFI_HII_DATABASE_NOTIFY_TYPE      NotifyType,
+  OUT EFI_HANDLE                        *NotifyHandle
+  );
+
+
+/**
+  Removes the specified HII database package-related notification.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  NotificationHandle      The handle of the notification function being
+                                  unregistered.
+
+  @retval EFI_SUCCESS             Notification is unregistered successfully.
+  @retval EFI_NOT_FOUND          The incoming notification handle does not exist 
+                           in current hii database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiUnregisterPackageNotify (
+  IN CONST EFI_HII_DATABASE_PROTOCOL    *This,
+  IN EFI_HANDLE                         NotificationHandle
+  );
+
+
+/**
+  This routine retrieves an array of GUID values for each keyboard layout that
+  was previously registered in the system.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  KeyGuidBufferLength     On input, a pointer to the length of the keyboard
+                                  GUID  buffer. On output, the length of the handle
+                                  buffer  that is required for the handles found.
+  @param  KeyGuidBuffer           An array of keyboard layout GUID instances
+                                  returned.
+
+  @retval EFI_SUCCESS             KeyGuidBuffer was updated successfully.
+  @retval EFI_BUFFER_TOO_SMALL    The KeyGuidBufferLength parameter indicates
+                                  that KeyGuidBuffer is too small to support the
+                                  number of GUIDs. KeyGuidBufferLength is
+                                  updated with a value that will enable the data to
+                                  fit.
+  @retval EFI_INVALID_PARAMETER   The KeyGuidBuffer or KeyGuidBufferLength was
+                                  NULL.
+  @retval EFI_NOT_FOUND           There was no keyboard layout.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiFindKeyboardLayouts (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  OUT UINT16                        *KeyGuidBufferLength,
+  OUT EFI_GUID                          *KeyGuidBuffer
+  );
+
+
+/**
+  This routine retrieves the requested keyboard layout. The layout is a physical description of the keys
+  on a keyboard and the character(s) that are associated with a particular set of key strokes.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  KeyGuid                 A pointer to the unique ID associated with a
+                                  given keyboard layout. If KeyGuid is NULL then
+                                  the current layout will be retrieved.
+  @param  KeyboardLayoutLength    On input, a pointer to the length of the
+                                  KeyboardLayout buffer.  On output, the length of
+                                  the data placed into KeyboardLayout.
+  @param  KeyboardLayout          A pointer to a buffer containing the retrieved
+                                  keyboard layout.
+
+  @retval EFI_SUCCESS             The keyboard layout was retrieved successfully.
+  @retval EFI_NOT_FOUND           The requested keyboard layout was not found.
+  @retval EFI_INVALID_PARAMETER   The KeyboardLayout or KeyboardLayoutLength was
+                                  NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetKeyboardLayout (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL   *This,
+  IN  CONST EFI_GUID                          *KeyGuid,
+  IN OUT UINT16                         *KeyboardLayoutLength,
+  OUT EFI_HII_KEYBOARD_LAYOUT           *KeyboardLayout
+  );
+
+
+/**
+  This routine sets the default keyboard layout to the one referenced by KeyGuid. When this routine
+  is called, an event will be signaled of the EFI_HII_SET_KEYBOARD_LAYOUT_EVENT_GUID
+  group type. This is so that agents which are sensitive to the current keyboard layout being changed
+  can be notified of this change.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  KeyGuid                 A pointer to the unique ID associated with a
+                                  given keyboard layout.
+
+  @retval EFI_SUCCESS             The current keyboard layout was successfully set.
+  @retval EFI_NOT_FOUND           The referenced keyboard layout was not found, so
+                                  action was taken.
+  @retval EFI_INVALID_PARAMETER   The KeyGuid was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiSetKeyboardLayout (
+  IN CONST EFI_HII_DATABASE_PROTOCOL          *This,
+  IN CONST EFI_GUID                           *KeyGuid
+  );
+
+
+/**
+  Return the EFI handle associated with a package list.
+
+  @param  This                    A pointer to the EFI_HII_DATABASE_PROTOCOL
+                                  instance.
+  @param  PackageListHandle       An EFI_HII_HANDLE that corresponds to the desired
+                                  package list in the HIIdatabase.
+  @param  DriverHandle            On return, contains the EFI_HANDLE which was
+                                  registered with the package list in
+                                  NewPackageList().
+
+  @retval EFI_SUCCESS             The DriverHandle was returned successfully.
+  @retval EFI_INVALID_PARAMETER   The PackageListHandle was not valid or
+                                  DriverHandle was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetPackageListHandle (
+  IN  CONST EFI_HII_DATABASE_PROTOCOL         *This,
+  IN  EFI_HII_HANDLE                    PackageListHandle,
+  OUT EFI_HANDLE                        *DriverHandle
+  );
+
+//
+// EFI_HII_CONFIG_ROUTING_PROTOCOL interfaces
+//
+
+
+/**
+  This function allows a caller to extract the current configuration
+  for one or more named elements from one or more drivers.
+
+  @param  This                    A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                  instance.
+  @param  Request                 A null-terminated Unicode string in
+                                  <MultiConfigRequest> format.
+  @param  Progress                On return, points to a character in the Request
+                                  string. Points to the string's null terminator if
+                                  request was successful. Points to the most recent
+                                  & before the first failing name / value pair (or
+                                  the beginning of the string if the failure is in
+                                  the first name / value pair) if the request was
+                                  not successful.
+  @param  Results                 Null-terminated Unicode string in
+                                  <MultiConfigAltResp> format which has all values
+                                  filled in for the names in the Request string.
+                                  String to be allocated by the called function.
+
+  @retval EFI_SUCCESS             The Results string is filled with the values
+                                  corresponding to all requested names.
+  @retval EFI_OUT_OF_RESOURCES    Not enough memory to store the parts of the
+                                  results that must be stored awaiting possible
+                                  future        protocols.
+  @retval EFI_NOT_FOUND           Routing data doesn't match any known driver.
+                                     Progress set to the "G" in "GUID" of the
+                                  routing  header that doesn't match. Note: There
+                                  is no         requirement that all routing data
+                                  be validated before any configuration extraction.
+  @retval EFI_INVALID_PARAMETER   For example, passing in a NULL for the Request
+                                  parameter would result in this type of error. The
+                                  Progress parameter is set to NULL.
+  @retval EFI_INVALID_PARAMETER   Illegal syntax. Progress set to most recent &
+                                  before the error or the beginning of the string.
+  @retval EFI_INVALID_PARAMETER   Unknown name. Progress points to the & before the
+                                  name in question.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigRoutingExtractConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  CONST EFI_STRING                       Request,
+  OUT EFI_STRING                             *Progress,
+  OUT EFI_STRING                             *Results
+  );
+
+
+/**
+  This function allows the caller to request the current configuration for the
+  entirety of the current HII database and returns the data in a null-terminated Unicode string.
+
+  @param  This                    A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                  instance.
+  @param  Results                 Null-terminated Unicode string in
+                                  <MultiConfigAltResp> format which has all values
+                                  filled in for the names in the Request string.
+                                  String to be allocated by the  called function.
+                                  De-allocation is up to the caller.
+
+  @retval EFI_SUCCESS             The Results string is filled with the values
+                                  corresponding to all requested names.
+  @retval EFI_OUT_OF_RESOURCES    Not enough memory to store the parts of the
+                                  results that must be stored awaiting possible
+                                  future        protocols.
+  @retval EFI_INVALID_PARAMETER   For example, passing in a NULL for the Results
+                                  parameter would result in this type of error.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigRoutingExportConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  OUT EFI_STRING                             *Results
+  );
+
+
+/**
+  This function processes the results of processing forms and routes it to the
+  appropriate handlers or storage.
+
+  @param  This                    A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                  instance.
+  @param  Configuration           A null-terminated Unicode string in
+                                  <MulltiConfigResp> format.
+  @param  Progress                A pointer to a string filled in with the offset
+                                  of the most recent & before the first failing
+                                  name / value pair (or the beginning of the string
+                                  if the failure is in the first name / value pair)
+                                  or the terminating NULL if all was successful.
+
+  @retval EFI_SUCCESS             The results have been distributed or are awaiting
+                                  distribution.
+  @retval EFI_OUT_OF_RESOURCES    Not enough memory to store the parts of the
+                                  results that must be stored awaiting possible
+                                  future        protocols.
+  @retval EFI_INVALID_PARAMETER   Passing in a NULL for the Configuration parameter
+                                  would result in this type of error.
+  @retval EFI_NOT_FOUND           Target for the specified routing data was not
+                                  found.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigRoutingRouteConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  CONST EFI_STRING                       Configuration,
+  OUT EFI_STRING                             *Progress
+  );
+
+
+
+/**
+  This helper function is to be called by drivers to map configuration data stored
+  in byte array ("block") formats such as UEFI Variables into current configuration strings.
+
+  @param  This                    A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                  instance.
+  @param  ConfigRequest           A null-terminated Unicode string in
+                                  <ConfigRequest> format.
+  @param  Block                   Array of bytes defining the block's
+                                  configuration.
+  @param  BlockSize               Length in bytes of Block.
+  @param  Config                  Filled-in configuration string. String allocated
+                                  by  the function. Returned only if call is
+                                  successful.
+  @param  Progress                A pointer to a string filled in with the offset
+                                  of  the most recent & before the first failing
+                                  name/value pair (or the beginning of the string
+                                  if the failure is in the first name / value pair)
+                                  or the terminating NULL if all was successful.
+
+  @retval EFI_SUCCESS             The request succeeded. Progress points to the
+                                  null terminator at the end of the ConfigRequest
+                                        string.
+  @retval EFI_OUT_OF_RESOURCES    Not enough memory to allocate Config.
+                                  Progress points to the first character of
+                                  ConfigRequest.
+  @retval EFI_INVALID_PARAMETER   Passing in a NULL for the ConfigRequest or
+                                  Block parameter would result in this type of
+                                  error. Progress points to the first character of
+                                  ConfigRequest.
+  @retval EFI_NOT_FOUND           Target for the specified routing data was not
+                                  found. Progress points to the "G" in "GUID" of
+                                  the      errant routing data.
+  @retval EFI_DEVICE_ERROR        Block not large enough. Progress undefined.
+  @retval EFI_INVALID_PARAMETER   Encountered non <BlockName> formatted string.
+                                       Block is left updated and Progress points at
+                                  the '&' preceding the first non-<BlockName>.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiBlockToConfig (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL  *This,
+  IN  CONST EFI_STRING                       ConfigRequest,
+  IN  CONST UINT8                            *Block,
+  IN  CONST UINTN                            BlockSize,
+  OUT EFI_STRING                             *Config,
+  OUT EFI_STRING                             *Progress
+  );
+
+
+/**
+  This helper function is to be called by drivers to map configuration strings
+  to configurations stored in byte array ("block") formats such as UEFI Variables.
+
+  @param  This                    A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                  instance.
+  @param  ConfigResp              A null-terminated Unicode string in <ConfigResp>
+                                  format.
+  @param  Block                   A possibly null array of bytes representing the
+                                  current  block. Only bytes referenced in the
+                                  ConfigResp string  in the block are modified. If
+                                  this parameter is null or if the *BlockSize
+                                  parameter is (on input) shorter than required by
+                                  the Configuration string, only the BlockSize
+                                  parameter is updated and an appropriate status
+                                  (see below)  is returned.
+  @param  BlockSize               The length of the Block in units of UINT8.  On
+                                  input, this is the size of the Block. On output,
+                                  if successful, contains the index of the  last
+                                  modified byte in the Block.
+  @param  Progress                On return, points to an element of the ConfigResp
+                                   string filled in with the offset of the most
+                                  recent '&' before the first failing name / value
+                                  pair (or  the beginning of the string if the
+                                  failure is in the  first name / value pair) or
+                                  the terminating NULL if all was successful.
+
+  @retval EFI_SUCCESS             The request succeeded. Progress points to the
+                                  null terminator at the end of the ConfigResp
+                                  string.
+  @retval EFI_OUT_OF_RESOURCES    Not enough memory to allocate Config.
+                                  Progress points to the first character of
+                                  ConfigResp.
+  @retval EFI_INVALID_PARAMETER   Passing in a NULL for the ConfigResp or
+                                  Block parameter would result in this type of
+                                  error. Progress points to the first character of
+                                           ConfigResp.
+  @retval EFI_NOT_FOUND           Target for the specified routing data was not
+                                  found. Progress points to the "G" in "GUID" of
+                                  the      errant routing data.
+  @retval EFI_INVALID_PARAMETER   Encountered non <BlockName> formatted name /
+                                  value pair. Block is left updated and
+                                  Progress points at the '&' preceding the first
+                                  non-<BlockName>.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiConfigToBlock (
+  IN     CONST EFI_HII_CONFIG_ROUTING_PROTOCOL *This,
+  IN     CONST EFI_STRING                      ConfigResp,
+  IN OUT UINT8                                 *Block,
+  IN OUT UINTN                                 *BlockSize,
+  OUT    EFI_STRING                            *Progress
+  );
+
+
+/**
+  This helper function is to be called by drivers to extract portions of
+  a larger configuration string.
+
+  @param  This                    A pointer to the EFI_HII_CONFIG_ROUTING_PROTOCOL
+                                  instance.
+  @param  Configuration           A null-terminated Unicode string in
+                                  <MultiConfigAltResp> format.
+  @param  Guid                    A pointer to the GUID value to search for in the
+                                  routing portion of the ConfigResp string when
+                                  retrieving  the requested data. If Guid is NULL,
+                                  then all GUID  values will be searched for.
+  @param  Name                    A pointer to the NAME value to search for in the
+                                  routing portion of the ConfigResp string when
+                                  retrieving  the requested data. If Name is NULL,
+                                  then all Name  values will be searched for.
+  @param  DevicePath              A pointer to the PATH value to search for in the
+                                  routing portion of the ConfigResp string when
+                                  retrieving  the requested data. If DevicePath is
+                                  NULL, then all  DevicePath values will be
+                                  searched for.
+  @param  AltCfgId                A pointer to the ALTCFG value to search for in
+                                  the  routing portion of the ConfigResp string
+                                  when retrieving  the requested data.  If this
+                                  parameter is NULL,  then the current setting will
+                                  be retrieved.
+  @param  AltCfgResp              A pointer to a buffer which will be allocated by
+                                  the  function which contains the retrieved string
+                                  as requested.   This buffer is only allocated if
+                                  the call was successful.
+
+  @retval EFI_SUCCESS             The request succeeded. The requested data was
+                                  extracted  and placed in the newly allocated
+                                  AltCfgResp buffer.
+  @retval EFI_OUT_OF_RESOURCES    Not enough memory to allocate AltCfgResp.
+  @retval EFI_INVALID_PARAMETER   Any parameter is invalid.
+  @retval EFI_NOT_FOUND           Target for the specified routing data was not
+                                  found.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetAltCfg (
+  IN  CONST EFI_HII_CONFIG_ROUTING_PROTOCOL    *This,
+  IN  CONST EFI_STRING                         Configuration,
+  IN  CONST EFI_GUID                           *Guid,
+  IN  CONST EFI_STRING                         Name,
+  IN  CONST EFI_DEVICE_PATH_PROTOCOL           *DevicePath,
+  IN  CONST UINT16                             *AltCfgId,
+  OUT EFI_STRING                               *AltCfgResp
+  );
+
+
+/**
+  Compare whether two names of languages are identical.
+
+  @param  Language1              Name of language 1 from StringPackage
+  @param  Language2              Name of language 2 to be compared with language 1.
+
+  @retval TRUE                   same
+  @retval FALSE                  not same
+
+**/
+BOOLEAN
+HiiCompareLanguage (
+  IN  CHAR8  *Language1,
+  IN  CHAR8  *Language2
+  )
+;
+
+//
+// Global variables
+//
+extern EFI_EVENT gHiiKeyboardLayoutChanged;
+#endif
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabaseDxe.inf
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabaseDxe.inf	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabaseDxe.inf	(working copy)
@@ -0,0 +1,83 @@
+## @file
+# The DXE driver produces HII protocols defined in UEFI HII 2.1 specificatin.
+#
+# Copyright (c) 2007 - 2011, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials       
+#  are licensed and made available under the terms and conditions of the BSD License   
+#  which accompanies this distribution. The full text of the license may be found at  
+#  http://opensource.org/licenses/bsd-license.php           
+#  
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,      
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = HiiDatabase
+  FILE_GUID                      = 348C4D62-BFBD-4882-9ECE-C80BB1C4783B
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = InitializeHiiDatabase
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  HiiDatabaseEntry.c
+  Image.c
+  HiiDatabase.h
+  ConfigRouting.c
+  String.c
+  Database.c
+  Font.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+
+
+[LibraryClasses]
+  MemoryAllocationLib
+  DevicePathLib
+  BaseLib
+  UefiBootServicesTableLib
+  UefiDriverEntryPoint
+  BaseMemoryLib
+  DebugLib
+  UefiLib
+  PcdLib
+  UefiRuntimeServicesTableLib
+  PrintLib
+
+[Protocols]
+  gEfiDevicePathProtocolGuid                                            ## SOMETIMES_CONSUMES
+  gEfiHiiStringProtocolGuid                                             ## PRODUCES
+  gEfiHiiImageProtocolGuid |gEfiMdeModulePkgTokenSpaceGuid.PcdSupportHiiImageProtocol                  ## PRODUCES
+  gEfiHiiConfigRoutingProtocolGuid                                      ## PRODUCES
+  gEfiHiiDatabaseProtocolGuid                                           ## PRODUCES
+  gEfiHiiFontProtocolGuid                                               ## PRODUCES
+  gEfiHiiConfigAccessProtocolGuid                                       ## CONSUMES
+
+[FeaturePcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSupportHiiImageProtocol
+
+[Pcd]
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultPlatformLang
+
+[Guids]  
+  gEfiGlobalVariableGuid  ## SOMETIMES_CONSUMES ## Variable:"PlatformLang"
+  ##
+  # Event registered to EFI_HII_SET_KEYBOARD_LAYOUT_EVENT_GUID group,
+  # which will be triggered by EFI_HII_DATABASE_PROTOCOL.SetKeyboardLayout().
+  ##
+  gEfiHiiKeyBoardLayoutGuid  ## SOMETIME_CONSUMES  ## Event
+
+[Depex]
+  TRUE
+
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabaseEntry.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabaseEntry.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/HiiDatabaseEntry.c	(working copy)
@@ -0,0 +1,238 @@
+/** @file
+This file contains the entry code to the HII database, which is defined by
+UEFI 2.1 specification.
+
+Copyright (c) 2007 - 2008, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "HiiDatabase.h"
+#include <Library/UefiLib.h>
+
+//
+// Global variables
+//
+EFI_EVENT gHiiKeyboardLayoutChanged;
+
+HII_DATABASE_PRIVATE_DATA mPrivate = {
+  HII_DATABASE_PRIVATE_DATA_SIGNATURE,
+  {
+    (LIST_ENTRY *) NULL,
+    (LIST_ENTRY *) NULL
+  },
+  {
+    (LIST_ENTRY *) NULL,
+    (LIST_ENTRY *) NULL
+  },
+  {
+    HiiStringToImage,
+    HiiStringIdToImage,
+    HiiGetGlyph,
+    HiiGetFontInfo
+  },
+  {
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+  },
+  {
+    HiiNewString,
+    IntHiiGetString,
+    IntHiiSetString,
+    HiiGetLanguages,
+    HiiGetSecondaryLanguages
+  },
+  {
+    HiiNewPackageList,
+    HiiRemovePackageList,
+    HiiUpdatePackageList,
+    HiiListPackageLists,
+    HiiExportPackageLists,
+    HiiRegisterPackageNotify,
+    HiiUnregisterPackageNotify,
+    HiiFindKeyboardLayouts,
+    HiiGetKeyboardLayout,
+    HiiSetKeyboardLayout,
+    HiiGetPackageListHandle
+  },
+  {
+    HiiConfigRoutingExtractConfig,
+    HiiConfigRoutingExportConfig,
+    HiiConfigRoutingRouteConfig,
+    HiiBlockToConfig,
+    HiiConfigToBlock,
+    HiiGetAltCfg
+  },
+  {
+    (LIST_ENTRY *) NULL,
+    (LIST_ENTRY *) NULL
+  },
+  0,
+  {
+    (LIST_ENTRY *) NULL,
+    (LIST_ENTRY *) NULL
+  },
+  EFI_TEXT_ATTR (EFI_LIGHTGRAY, EFI_BLACK),
+  {
+    0x00000000,
+    0x0000,
+    0x0000,
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+  },
+  NULL
+};
+
+GLOBAL_REMOVE_IF_UNREFERENCED CONST EFI_HII_IMAGE_PROTOCOL mImageProtocol = {
+  HiiNewImage,
+  HiiGetImage,
+  HiiSetImage,
+  HiiDrawImage,
+  HiiDrawImageId
+};
+
+/**
+  The default event handler for gHiiKeyboardLayoutChanged
+  event group.
+
+  This is internal function.
+
+  @param Event           The event that triggered this notification function.
+  @param Context         Pointer to the notification functions context.
+
+**/
+VOID
+EFIAPI
+KeyboardLayoutChangeNullEvent (
+  IN EFI_EVENT                Event,
+  IN VOID                     *Context
+  )
+{
+  return;
+}
+
+/**
+  Initialize HII Database.
+
+
+  @param ImageHandle     The image handle.
+  @param SystemTable     The system table.
+
+  @retval EFI_SUCCESS    The Hii database is setup correctly.
+  @return Other value if failed to create the default event for
+          gHiiKeyboardLayoutChanged. Check gBS->CreateEventEx for
+          details. Or failed to insatll the protocols.
+          Check gBS->InstallMultipleProtocolInterfaces for details.
+
+**/
+EFI_STATUS
+EFIAPI
+InitializeHiiDatabase (
+  IN EFI_HANDLE           ImageHandle,
+  IN EFI_SYSTEM_TABLE     *SystemTable
+  )
+{
+  EFI_STATUS                             Status;
+  EFI_HANDLE                             Handle;
+  VOID                                   *Instance;
+  BOOLEAN                                AlreadyInstalled = FALSE;
+
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiHiiDatabaseProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiHiiDatabaseProtocolGuid already installed\n");
+	AlreadyInstalled = TRUE;
+  }
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiHiiFontProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiHiiFontProtocolGuid already installed\n");
+	AlreadyInstalled = TRUE;
+  }
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiHiiImageProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiHiiImageProtocolGuid already installed\n");
+	AlreadyInstalled = TRUE;
+  }
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiHiiStringProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiHiiStringProtocolGuid already installed\n");
+	AlreadyInstalled = TRUE;
+  }
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiHiiConfigRoutingProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiHiiConfigRoutingProtocolGuid already installed\n");
+	AlreadyInstalled = TRUE;
+  }
+  
+  //
+  // There will be only one HII Database in the system
+  // If there is another out there, someone is trying to install us
+  // again.  Fail that scenario.
+  //
+  if (AlreadyInstalled) {
+	return EFI_ALREADY_STARTED;
+  }
+  /*
+  ASSERT_PROTOCOL_ALREADY_INSTALLED (NULL, &gEfiHiiDatabaseProtocolGuid);
+  ASSERT_PROTOCOL_ALREADY_INSTALLED (NULL, &gEfiHiiFontProtocolGuid);
+  ASSERT_PROTOCOL_ALREADY_INSTALLED (NULL, &gEfiHiiImageProtocolGuid);
+  ASSERT_PROTOCOL_ALREADY_INSTALLED (NULL, &gEfiHiiStringProtocolGuid);
+  ASSERT_PROTOCOL_ALREADY_INSTALLED (NULL, &gEfiHiiConfigRoutingProtocolGuid);
+  */
+  
+  InitializeListHead (&mPrivate.DatabaseList);
+  InitializeListHead (&mPrivate.DatabaseNotifyList);
+  InitializeListHead (&mPrivate.HiiHandleList);
+  InitializeListHead (&mPrivate.FontInfoList);
+
+  //
+  // Create a event with EFI_HII_SET_KEYBOARD_LAYOUT_EVENT_GUID group type.
+  //
+  Status = gBS->CreateEventEx (
+                  EVT_NOTIFY_SIGNAL,
+                  TPL_NOTIFY,
+                  KeyboardLayoutChangeNullEvent,
+                  NULL,
+                  &gEfiHiiKeyBoardLayoutGuid,
+                  &gHiiKeyboardLayoutChanged
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  Handle = NULL;
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &Handle,
+                  &gEfiHiiFontProtocolGuid,
+                  &mPrivate.HiiFont,
+                  &gEfiHiiStringProtocolGuid,
+                  &mPrivate.HiiString,
+                  &gEfiHiiDatabaseProtocolGuid,
+                  &mPrivate.HiiDatabase,
+                  &gEfiHiiConfigRoutingProtocolGuid,
+                  &mPrivate.ConfigRouting,
+                  NULL
+                  );
+
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  if (FeaturePcdGet (PcdSupportHiiImageProtocol)) {
+    CopyMem (&mPrivate.HiiImage, &mImageProtocol, sizeof (mImageProtocol));
+
+    Status = gBS->InstallMultipleProtocolInterfaces (
+                    &Handle,
+                    &gEfiHiiImageProtocolGuid,
+                    &mPrivate.HiiImage,
+                    NULL
+                    );
+
+  }
+
+  return Status;
+}
+
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Image.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Image.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/Image.c	(working copy)
@@ -0,0 +1,1493 @@
+/** @file
+Implementation for EFI_HII_IMAGE_PROTOCOL.
+
+
+Copyright (c) 2007 - 2008, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "HiiDatabase.h"
+
+
+/**
+  Get the imageid of last image block: EFI_HII_IIBT_END_BLOCK when input
+  ImageId is zero, otherwise return the address of the
+  corresponding image block with identifier specified by ImageId.
+
+  This is a internal function.
+
+  @param ImageBlock      Points to the beginning of a series of image blocks stored in order.
+  @param ImageId         If input ImageId is 0, output the image id of the EFI_HII_IIBT_END_BLOCK;
+                         else use this id to find its corresponding image block address.
+
+  @return The image block address when input ImageId is not zero; otherwise return NULL.
+
+**/
+UINT8*
+GetImageIdOrAddress (
+  IN  UINT8           *ImageBlock,
+  IN OUT EFI_IMAGE_ID *ImageId
+  )
+{
+  EFI_IMAGE_ID                   ImageIdCurrent;
+  UINT8                          *ImageBlockHdr;
+  UINT8                          Length8;
+  UINT16                         Length16;
+  UINT32                         Length32;
+  EFI_HII_IIBT_IMAGE_1BIT_BLOCK  Iibt1bit;
+  EFI_HII_IIBT_IMAGE_4BIT_BLOCK  Iibt4bit;
+  EFI_HII_IIBT_IMAGE_8BIT_BLOCK  Iibt8bit;
+  UINT16                         Width;
+  UINT16                         Height;
+
+  ASSERT (ImageBlock != NULL && ImageId != NULL);
+
+  ImageBlockHdr  = ImageBlock;
+  ImageIdCurrent = 1;
+
+  while (((EFI_HII_IMAGE_BLOCK *) ImageBlock)->BlockType != EFI_HII_IIBT_END) {
+    if (*ImageId > 0) {
+      if (*ImageId == ImageIdCurrent) {
+        //
+        // If the found image block is a duplicate block, update the ImageId to
+        // find the previous defined image block.
+        //
+        if (((EFI_HII_IMAGE_BLOCK *) ImageBlock)->BlockType == EFI_HII_IIBT_DUPLICATE) {
+          CopyMem (ImageId, ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK), sizeof (EFI_IMAGE_ID));
+          ASSERT (*ImageId != ImageIdCurrent);
+          ImageBlock = ImageBlockHdr;
+          ImageIdCurrent = 1;
+          continue;
+        }
+
+        return ImageBlock;
+      }
+      if (*ImageId < ImageIdCurrent) {
+        //
+        // Can not find the specified image block in this image.
+        //
+        return NULL;
+      }
+    }
+    switch (((EFI_HII_IMAGE_BLOCK *) ImageBlock)->BlockType) {
+    case EFI_HII_IIBT_EXT1:
+      Length8 = *(ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK) + sizeof (UINT8));
+      ImageBlock += Length8;
+      ImageIdCurrent++;
+      break;
+    case EFI_HII_IIBT_EXT2:
+      CopyMem (
+        &Length16,
+        ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK) + sizeof (UINT8),
+        sizeof (UINT16)
+        );
+      ImageBlock += Length16;
+      ImageIdCurrent++;
+      break;
+    case EFI_HII_IIBT_EXT4:
+      CopyMem (
+        &Length32,
+        ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK) + sizeof (UINT8),
+        sizeof (UINT32)
+        );
+      ImageBlock += Length32;
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_IMAGE_1BIT:
+    case EFI_HII_IIBT_IMAGE_1BIT_TRANS:
+      CopyMem (&Iibt1bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_1BIT_BLOCK));
+      ImageBlock += sizeof (EFI_HII_IIBT_IMAGE_1BIT_BLOCK) - sizeof (UINT8) +
+                    BITMAP_LEN_1_BIT (Iibt1bit.Bitmap.Width, Iibt1bit.Bitmap.Height);
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_IMAGE_4BIT:
+    case EFI_HII_IIBT_IMAGE_4BIT_TRANS:
+      CopyMem (&Iibt4bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_4BIT_BLOCK));
+      ImageBlock += sizeof (EFI_HII_IIBT_IMAGE_4BIT_BLOCK) - sizeof (UINT8) +
+                    BITMAP_LEN_4_BIT (Iibt4bit.Bitmap.Width, Iibt4bit.Bitmap.Height);
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_IMAGE_8BIT:
+    case EFI_HII_IIBT_IMAGE_8BIT_TRANS:
+      CopyMem (&Iibt8bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_8BIT_BLOCK));
+      ImageBlock += sizeof (EFI_HII_IIBT_IMAGE_8BIT_BLOCK) - sizeof (UINT8) +
+                    BITMAP_LEN_8_BIT (Iibt8bit.Bitmap.Width, Iibt8bit.Bitmap.Height);
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_IMAGE_24BIT:
+    case EFI_HII_IIBT_IMAGE_24BIT_TRANS:
+      CopyMem (&Width, ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK), sizeof (UINT16));
+      CopyMem (
+        &Height,
+        ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK) + sizeof (UINT16),
+        sizeof (UINT16)
+        );
+      ImageBlock += sizeof (EFI_HII_IIBT_IMAGE_24BIT_BLOCK) - sizeof (EFI_HII_RGB_PIXEL) +
+                    BITMAP_LEN_24_BIT (Width, Height);
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_DUPLICATE:
+      ImageBlock += sizeof (EFI_HII_IIBT_DUPLICATE_BLOCK);
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_IMAGE_JPEG:
+      CopyMem (&Length32, ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK), sizeof (UINT32));
+      ImageBlock += Length32;
+      ImageIdCurrent++;
+      break;
+
+    case EFI_HII_IIBT_SKIP1:
+      Length8 = *(ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK));
+      ImageBlock += sizeof (EFI_HII_IIBT_SKIP1_BLOCK);
+      ImageIdCurrent = (UINT16) (ImageIdCurrent + Length8);
+      break;
+
+    case EFI_HII_IIBT_SKIP2:
+      CopyMem (&Length16, ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK), sizeof (UINT16));
+      ImageBlock += sizeof (EFI_HII_IIBT_SKIP2_BLOCK);
+      ImageIdCurrent = (UINT16) (ImageIdCurrent + Length16);
+      break;
+
+    default:
+      //
+      // Unknown image blocks can not be skipped, processing halts.
+      //
+      ASSERT (FALSE);
+    }
+  }
+
+  //
+  // When ImageId is zero, return the imageid of last image block: EFI_HII_IIBT_END_BLOCK.
+  //
+  if (*ImageId == 0) {
+    *ImageId = ImageIdCurrent;
+    return ImageBlock;
+  }
+
+  return NULL;
+}
+
+
+
+/**
+  Convert pixels from EFI_GRAPHICS_OUTPUT_BLT_PIXEL to EFI_HII_RGB_PIXEL style.
+
+  This is a internal function.
+
+
+  @param  BitMapOut              Pixels in EFI_HII_RGB_PIXEL format.
+  @param  BitMapIn               Pixels in EFI_GRAPHICS_OUTPUT_BLT_PIXEL format.
+  @param  PixelNum               The number of pixels to be converted.
+
+
+**/
+VOID
+CopyGopToRgbPixel (
+  OUT EFI_HII_RGB_PIXEL              *BitMapOut,
+  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL  *BitMapIn,
+  IN  UINTN                          PixelNum
+  )
+{
+  UINTN Index;
+
+  ASSERT (BitMapOut != NULL && BitMapIn != NULL);
+
+  for (Index = 0; Index < PixelNum; Index++) {
+    CopyMem (BitMapOut + Index, BitMapIn + Index, sizeof (EFI_HII_RGB_PIXEL));
+  }
+}
+
+
+/**
+  Convert pixels from EFI_HII_RGB_PIXEL to EFI_GRAPHICS_OUTPUT_BLT_PIXEL style.
+
+  This is a internal function.
+
+
+  @param  BitMapOut              Pixels in EFI_GRAPHICS_OUTPUT_BLT_PIXEL format.
+  @param  BitMapIn               Pixels in EFI_HII_RGB_PIXEL format.
+  @param  PixelNum               The number of pixels to be converted.
+
+
+**/
+VOID
+CopyRgbToGopPixel (
+  OUT EFI_GRAPHICS_OUTPUT_BLT_PIXEL  *BitMapOut,
+  IN  EFI_HII_RGB_PIXEL              *BitMapIn,
+  IN  UINTN                          PixelNum
+  )
+{
+  UINTN Index;
+
+  ASSERT (BitMapOut != NULL && BitMapIn != NULL);
+
+  for (Index = 0; Index < PixelNum; Index++) {
+    CopyMem (BitMapOut + Index, BitMapIn + Index, sizeof (EFI_HII_RGB_PIXEL));
+  }
+}
+
+
+/**
+  Output pixels in "1 bit per pixel" format to an image.
+
+  This is a internal function.
+
+
+  @param  Image                  Points to the image which will store the pixels.
+  @param  Data                   Stores the value of output pixels, 0 or 1.
+  @param  PaletteInfo            PaletteInfo which stores the color of the output
+                                 pixels. First entry corresponds to color 0 and
+                                 second one to color 1.
+
+
+**/
+VOID
+Output1bitPixel (
+  IN OUT EFI_IMAGE_INPUT             *Image,
+  IN UINT8                           *Data,
+  IN EFI_HII_IMAGE_PALETTE_INFO      *PaletteInfo
+  )
+{
+  UINT16                             Xpos;
+  UINT16                             Ypos;
+  UINTN                              OffsetY;
+  UINT8                              Index;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      *BitMapPtr;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      PaletteValue[2];
+  EFI_HII_IMAGE_PALETTE_INFO         *Palette;
+  UINT16                             PaletteSize;
+  UINT8                              Byte;
+
+  ASSERT (Image != NULL && Data != NULL && PaletteInfo != NULL);
+
+  BitMapPtr = Image->Bitmap;
+
+  //
+  // First entry corresponds to color 0 and second entry corresponds to color 1.
+  //
+  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));
+  PaletteSize += sizeof (UINT16);
+  Palette = AllocateZeroPool (PaletteSize);
+  ASSERT (Palette != NULL);
+  CopyMem (Palette, PaletteInfo, PaletteSize);
+
+  ZeroMem (PaletteValue, sizeof (PaletteValue));
+  CopyRgbToGopPixel (&PaletteValue[0], &Palette->PaletteValue[0], 1);
+  CopyRgbToGopPixel (&PaletteValue[1], &Palette->PaletteValue[1], 1);
+  FreePool (Palette);
+
+  //
+  // Convert the pixel from one bit to corresponding color.
+  //
+  for (Ypos = 0; Ypos < Image->Height; Ypos++) {
+    OffsetY = BITMAP_LEN_1_BIT (Image->Width, Ypos);
+    //
+    // All bits in these bytes are meaningful
+    //
+    for (Xpos = 0; Xpos < Image->Width / 8; Xpos++) {
+      Byte = *(Data + OffsetY + Xpos);
+      for (Index = 0; Index < 8; Index++) {
+        if ((Byte & (1 << Index)) != 0) {
+          BitMapPtr[Ypos * Image->Width + Xpos * 8 + (8 - Index - 1)] = PaletteValue[1];
+        } else {
+          BitMapPtr[Ypos * Image->Width + Xpos * 8 + (8 - Index - 1)] = PaletteValue[0];
+        }
+      }
+    }
+
+    if (Image->Width % 8 != 0) {
+      //
+      // Padding bits in this byte should be ignored.
+      //
+      Byte = *(Data + OffsetY + Xpos);
+      for (Index = 0; Index < Image->Width % 8; Index++) {
+        if ((Byte & (1 << (8 - Index - 1))) != 0) {
+          BitMapPtr[Ypos * Image->Width + Xpos * 8 + Index] = PaletteValue[1];
+        } else {
+          BitMapPtr[Ypos * Image->Width + Xpos * 8 + Index] = PaletteValue[0];
+        }
+      }
+    }
+  }
+}
+
+
+/**
+  Output pixels in "4 bit per pixel" format to an image.
+
+  This is a internal function.
+
+
+  @param  Image                  Points to the image which will store the pixels.
+  @param  Data                   Stores the value of output pixels, 0 ~ 15.
+  @param[in]  PaletteInfo            PaletteInfo which stores the color of the output
+                                 pixels. Each entry corresponds to a color within
+                                 [0, 15].
+
+
+**/
+VOID
+Output4bitPixel (
+  IN OUT EFI_IMAGE_INPUT             *Image,
+  IN UINT8                           *Data,
+  IN EFI_HII_IMAGE_PALETTE_INFO      *PaletteInfo
+  )
+{
+  UINT16                             Xpos;
+  UINT16                             Ypos;
+  UINTN                              OffsetY;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      *BitMapPtr;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      PaletteValue[16];
+  EFI_HII_IMAGE_PALETTE_INFO         *Palette;
+  UINT16                             PaletteSize;
+  UINT16                             PaletteNum;
+  UINT8                              Byte;
+
+  ASSERT (Image != NULL && Data != NULL && PaletteInfo != NULL);
+
+  BitMapPtr = Image->Bitmap;
+
+  //
+  // The bitmap should allocate each color index starting from 0.
+  //
+  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));
+  PaletteSize += sizeof (UINT16);
+  Palette = AllocateZeroPool (PaletteSize);
+  ASSERT (Palette != NULL);
+  CopyMem (Palette, PaletteInfo, PaletteSize);
+  PaletteNum = (UINT16)(Palette->PaletteSize / sizeof (EFI_HII_RGB_PIXEL));
+
+  ZeroMem (PaletteValue, sizeof (PaletteValue));
+  CopyRgbToGopPixel (PaletteValue, Palette->PaletteValue, PaletteNum);
+  FreePool (Palette);
+
+  //
+  // Convert the pixel from 4 bit to corresponding color.
+  //
+  for (Ypos = 0; Ypos < Image->Height; Ypos++) {
+    OffsetY = BITMAP_LEN_4_BIT (Image->Width, Ypos);
+    //
+    // All bits in these bytes are meaningful
+    //
+    for (Xpos = 0; Xpos < Image->Width / 2; Xpos++) {
+      Byte = *(Data + OffsetY + Xpos);
+      BitMapPtr[Ypos * Image->Width + Xpos * 2]     = PaletteValue[Byte >> 4];
+      BitMapPtr[Ypos * Image->Width + Xpos * 2 + 1] = PaletteValue[Byte & 0x0F];
+    }
+
+    if (Image->Width % 2 != 0) {
+      //
+      // Padding bits in this byte should be ignored.
+      //
+      Byte = *(Data + OffsetY + Xpos);
+      BitMapPtr[Ypos * Image->Width + Xpos * 2]     = PaletteValue[Byte >> 4];
+    }
+  }
+}
+
+
+/**
+  Output pixels in "8 bit per pixel" format to an image.
+
+  This is a internal function.
+
+
+  @param  Image                  Points to the image which will store the pixels.
+  @param  Data                   Stores the value of output pixels, 0 ~ 255.
+  @param[in]  PaletteInfo        PaletteInfo which stores the color of the output
+                                 pixels. Each entry corresponds to a color within
+                                 [0, 255].
+
+
+**/
+VOID
+Output8bitPixel (
+  IN OUT EFI_IMAGE_INPUT             *Image,
+  IN UINT8                           *Data,
+  IN EFI_HII_IMAGE_PALETTE_INFO      *PaletteInfo
+  )
+{
+  UINT16                             Xpos;
+  UINT16                             Ypos;
+  UINTN                              OffsetY;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      *BitMapPtr;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      PaletteValue[256];
+  EFI_HII_IMAGE_PALETTE_INFO         *Palette;
+  UINT16                             PaletteSize;
+  UINT16                             PaletteNum;
+  UINT8                              Byte;
+
+  ASSERT (Image != NULL && Data != NULL && PaletteInfo != NULL);
+
+  BitMapPtr = Image->Bitmap;
+
+  //
+  // The bitmap should allocate each color index starting from 0.
+  //
+  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));
+  PaletteSize += sizeof (UINT16);
+  Palette = AllocateZeroPool (PaletteSize);
+  ASSERT (Palette != NULL);
+  CopyMem (Palette, PaletteInfo, PaletteSize);
+  PaletteNum = (UINT16)(Palette->PaletteSize / sizeof (EFI_HII_RGB_PIXEL));
+  ZeroMem (PaletteValue, sizeof (PaletteValue));
+  CopyRgbToGopPixel (PaletteValue, Palette->PaletteValue, PaletteNum);
+  FreePool (Palette);
+
+  //
+  // Convert the pixel from 8 bits to corresponding color.
+  //
+  for (Ypos = 0; Ypos < Image->Height; Ypos++) {
+    OffsetY = BITMAP_LEN_8_BIT (Image->Width, Ypos);
+    //
+    // All bits are meaningful since the bitmap is 8 bits per pixel.
+    //
+    for (Xpos = 0; Xpos < Image->Width; Xpos++) {
+      Byte = *(Data + OffsetY + Xpos);
+      BitMapPtr[OffsetY + Xpos] = PaletteValue[Byte];
+    }
+  }
+
+}
+
+
+/**
+  Output pixels in "24 bit per pixel" format to an image.
+
+  This is a internal function.
+
+
+  @param  Image                  Points to the image which will store the pixels.
+  @param  Data                   Stores the color of output pixels, allowing 16.8
+                                 millions colors.
+
+
+**/
+VOID
+Output24bitPixel (
+  IN OUT EFI_IMAGE_INPUT             *Image,
+  IN EFI_HII_RGB_PIXEL               *Data
+  )
+{
+  UINT16                             Ypos;
+  UINTN                              OffsetY;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      *BitMapPtr;
+
+  ASSERT (Image != NULL && Data != NULL);
+
+  BitMapPtr = Image->Bitmap;
+
+  for (Ypos = 0; Ypos < Image->Height; Ypos++) {
+    OffsetY = BITMAP_LEN_8_BIT (Image->Width, Ypos);
+    CopyRgbToGopPixel (&BitMapPtr[OffsetY], &Data[OffsetY], Image->Width);
+  }
+
+}
+
+
+/**
+  Convert the image from EFI_IMAGE_INPUT to EFI_IMAGE_OUTPUT format.
+
+  This is a internal function.
+
+
+  @param  BltBuffer              Buffer points to bitmap data of incoming image.
+  @param  BltX                   Specifies the offset from the left and top edge of
+                                  the output image of the first pixel in the image.
+  @param  BltY                   Specifies the offset from the left and top edge of
+                                  the output image of the first pixel in the image.
+  @param  Width                  Width of the incoming image, in pixels.
+  @param  Height                 Height of the incoming image, in pixels.
+  @param  Transparent            If TRUE, all "off" pixels in the image will be
+                                 drawn using the pixel value from blt and all other
+                                 pixels will be copied.
+  @param  Blt                    Buffer points to bitmap data of output image.
+
+  @retval EFI_SUCCESS            The image was successfully converted.
+  @retval EFI_INVALID_PARAMETER  Any incoming parameter is invalid.
+
+**/
+EFI_STATUS
+ImageToBlt (
+  IN EFI_GRAPHICS_OUTPUT_BLT_PIXEL   *BltBuffer,
+  IN UINTN                           BltX,
+  IN UINTN                           BltY,
+  IN UINTN                           Width,
+  IN UINTN                           Height,
+  IN BOOLEAN                         Transparent,
+  IN OUT EFI_IMAGE_OUTPUT            **Blt
+  )
+{
+  EFI_IMAGE_OUTPUT                   *ImageOut;
+  UINTN                              Xpos;
+  UINTN                              Ypos;
+  UINTN                              OffsetY1; // src buffer
+  UINTN                              OffsetY2; // dest buffer
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      SrcPixel;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL      ZeroPixel;
+
+  if (BltBuffer == NULL || Blt == NULL || *Blt == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  ImageOut = *Blt;
+
+  if (Width + BltX > ImageOut->Width) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (Height + BltY > ImageOut->Height) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  ZeroMem (&ZeroPixel, sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+
+  for (Ypos = 0; Ypos < Height; Ypos++) {
+    OffsetY1 = Width * Ypos;
+    OffsetY2 = ImageOut->Width * (BltY + Ypos);
+    for (Xpos = 0; Xpos < Width; Xpos++) {
+      SrcPixel = BltBuffer[OffsetY1 + Xpos];
+      if (Transparent) {
+        if (CompareMem (&SrcPixel, &ZeroPixel, 3) != 0) {
+          ImageOut->Image.Bitmap[OffsetY2 + BltX + Xpos] = SrcPixel;
+        }
+      } else {
+        ImageOut->Image.Bitmap[OffsetY2 + BltX + Xpos] = SrcPixel;
+      }
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function adds the image Image to the group of images owned by PackageList, and returns
+  a new image identifier (ImageId).
+
+  @param  This                   A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  PackageList            Handle of the package list where this image will
+                                 be added.
+  @param  ImageId                On return, contains the new image id, which is
+                                 unique within PackageList.
+  @param  Image                  Points to the image.
+
+  @retval EFI_SUCCESS            The new image was added successfully.
+  @retval EFI_NOT_FOUND          The specified PackageList could not be found in
+                                 database.
+  @retval EFI_OUT_OF_RESOURCES   Could not add the image due to lack of resources.
+  @retval EFI_INVALID_PARAMETER  Image is NULL or ImageId is NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiNewImage (
+  IN  CONST EFI_HII_IMAGE_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                 PackageList,
+  OUT EFI_IMAGE_ID                   *ImageId,
+  IN  CONST EFI_IMAGE_INPUT          *Image
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_IMAGE_PACKAGE_INSTANCE          *ImagePackage;
+  UINT8                               *ImageBlock;
+  UINTN                               BlockSize;
+  UINT8                               *NewBlock;
+  UINT8                               *NewBlockPtr;
+  UINTN                               NewBlockSize;
+  EFI_IMAGE_INPUT                     *ImageIn;
+
+  if (This == NULL || ImageId == NULL || Image == NULL || Image->Bitmap == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_IMAGE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Get the specified package list
+  //
+
+  PackageListNode = NULL;
+
+  for (Link = Private->DatabaseList.ForwardLink;
+       Link != &Private->DatabaseList;
+       Link = Link->ForwardLink
+      ) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = DatabaseRecord->PackageList;
+      break;
+    }
+  }
+
+  if (PackageListNode == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  ImageIn = (EFI_IMAGE_INPUT *) Image;
+
+  NewBlockSize = sizeof (EFI_HII_IIBT_IMAGE_24BIT_BLOCK) - sizeof (EFI_HII_RGB_PIXEL) +
+                 BITMAP_LEN_24_BIT (ImageIn->Width, ImageIn->Height);
+
+  //
+  // Get the image package in the package list,
+  // or create a new image package if image package does not exist.
+  //
+  if (PackageListNode->ImagePkg != NULL) {
+    ImagePackage = PackageListNode->ImagePkg;
+
+    //
+    // Output the image id of the incoming image being inserted, which is the
+    // image id of the EFI_HII_IIBT_END block of old image package.
+    //
+    *ImageId = 0;
+    GetImageIdOrAddress (ImagePackage->ImageBlock, ImageId);
+
+    //
+    // Update the package's image block by appending the new block to the end.
+    //
+    BlockSize  = ImagePackage->ImageBlockSize + NewBlockSize;
+    ImageBlock = (UINT8 *) AllocateZeroPool (BlockSize);
+    if (ImageBlock == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    //
+    // Copy the original content.
+    //
+    CopyMem (
+      ImageBlock,
+      ImagePackage->ImageBlock,
+      ImagePackage->ImageBlockSize - sizeof (EFI_HII_IIBT_END_BLOCK)
+      );
+    FreePool (ImagePackage->ImageBlock);
+    ImagePackage->ImageBlock = ImageBlock;
+    ImageBlock += ImagePackage->ImageBlockSize - sizeof (EFI_HII_IIBT_END_BLOCK);
+    //
+    // Temp memory to store new block.
+    //
+    NewBlock = AllocateZeroPool (NewBlockSize);
+    if (NewBlock == NULL) {
+      FreePool (ImagePackage->ImageBlock);
+      return EFI_OUT_OF_RESOURCES;
+    }
+    NewBlockPtr = NewBlock;
+
+    //
+    // Update the length record.
+    //
+    ImagePackage->ImageBlockSize = (UINT32) BlockSize;
+    ImagePackage->ImagePkgHdr.Header.Length += (UINT32) NewBlockSize;
+    PackageListNode->PackageListHdr.PackageLength += (UINT32) NewBlockSize;
+
+  } else {
+    //
+    // The specified package list does not contain image package.
+    // Create one to add this image block.
+    //
+    ImagePackage = (HII_IMAGE_PACKAGE_INSTANCE *) AllocateZeroPool (sizeof (HII_IMAGE_PACKAGE_INSTANCE));
+    if (ImagePackage == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    //
+    // Output the image id of the incoming image being inserted, which is the
+    // first image block so that id is initially to one.
+    //
+    *ImageId = 1;
+    BlockSize    = sizeof (EFI_HII_IIBT_END_BLOCK) + NewBlockSize;
+    //
+    // Fill in image package header.
+    //
+    ImagePackage->ImagePkgHdr.Header.Length     = (UINT32) BlockSize + sizeof (EFI_HII_IMAGE_PACKAGE_HDR);
+    ImagePackage->ImagePkgHdr.Header.Type       = EFI_HII_PACKAGE_IMAGES;
+    ImagePackage->ImagePkgHdr.ImageInfoOffset   = sizeof (EFI_HII_IMAGE_PACKAGE_HDR);
+    ImagePackage->ImagePkgHdr.PaletteInfoOffset = 0;
+
+    //
+    // Fill in palette info.
+    //
+    ImagePackage->PaletteBlock    = NULL;
+    ImagePackage->PaletteInfoSize = 0;
+
+    //
+    // Fill in image blocks.
+    //
+    ImagePackage->ImageBlockSize = (UINT32) BlockSize;
+    ImagePackage->ImageBlock = (UINT8 *) AllocateZeroPool (BlockSize);
+    if (ImagePackage->ImageBlock == NULL) {
+      FreePool (ImagePackage);
+      return EFI_OUT_OF_RESOURCES;
+    }
+    ImageBlock = ImagePackage->ImageBlock;
+
+    //
+    // Temp memory to store new block.
+    //
+    NewBlock = AllocateZeroPool (NewBlockSize);
+    if (NewBlock == NULL) {
+      FreePool (ImagePackage->ImageBlock);
+      FreePool (ImagePackage);
+      return EFI_OUT_OF_RESOURCES;
+    }
+    NewBlockPtr = NewBlock;
+
+    //
+    // Insert this image package.
+    //
+    PackageListNode->ImagePkg = ImagePackage;
+    PackageListNode->PackageListHdr.PackageLength += ImagePackage->ImagePkgHdr.Header.Length;
+  }
+
+  //
+  // Append the new block here
+  //
+  if (ImageIn->Flags == EFI_IMAGE_TRANSPARENT) {
+    *NewBlock = EFI_HII_IIBT_IMAGE_24BIT_TRANS;
+  } else {
+    *NewBlock = EFI_HII_IIBT_IMAGE_24BIT;
+  }
+  NewBlock++;
+  CopyMem (NewBlock, &ImageIn->Width, sizeof (UINT16));
+  NewBlock += sizeof (UINT16);
+  CopyMem (NewBlock, &ImageIn->Height, sizeof (UINT16));
+  NewBlock += sizeof (UINT16);
+  CopyGopToRgbPixel ((EFI_HII_RGB_PIXEL *) NewBlock, ImageIn->Bitmap, ImageIn->Width * ImageIn->Height);
+
+  CopyMem (ImageBlock, NewBlockPtr, NewBlockSize);
+  FreePool (NewBlockPtr);
+
+  //
+  // Append the block end
+  //
+  ImageBlock += NewBlockSize;
+  ((EFI_HII_IIBT_END_BLOCK *) (ImageBlock))->Header.BlockType = EFI_HII_IIBT_END;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  This function retrieves the image specified by ImageId which is associated with
+  the specified PackageList and copies it into the buffer specified by Image.
+
+  @param  This                   A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  PackageList            Handle of the package list where this image will
+                                 be searched.
+  @param  ImageId                The image's id,, which is unique within
+                                 PackageList.
+  @param  Image                  Points to the image.
+
+  @retval EFI_SUCCESS            The new image was returned successfully.
+  @retval EFI_NOT_FOUND           The image specified by ImageId is not in the
+                                                database. The specified PackageList is not in the database.
+  @retval EFI_BUFFER_TOO_SMALL   The buffer specified by ImageSize is too small to
+                                 hold the image.
+  @retval EFI_INVALID_PARAMETER  The Image or ImageSize was NULL.
+  @retval EFI_OUT_OF_RESOURCES   The bitmap could not be retrieved because there was not
+                                                     enough memory.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetImage (
+  IN  CONST EFI_HII_IMAGE_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                 PackageList,
+  IN  EFI_IMAGE_ID                   ImageId,
+  OUT EFI_IMAGE_INPUT                *Image
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_IMAGE_PACKAGE_INSTANCE          *ImagePackage;
+  UINT8                               *ImageBlock;
+  EFI_IMAGE_ID                        LocalImageId;
+  UINT8                               BlockType;
+  EFI_HII_IIBT_IMAGE_1BIT_BLOCK       Iibt1bit;
+  UINT16                              Width;
+  UINT16                              Height;
+  UINTN                               ImageLength;
+  BOOLEAN                             Flag;
+  UINT8                               *PaletteInfo;
+  UINT8                               PaletteIndex;
+  UINT16                              PaletteSize;
+
+  if (This == NULL || Image == NULL || ImageId < 1) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_IMAGE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Get the specified package list and image package.
+  //
+  PackageListNode = NULL;
+  for (Link = Private->DatabaseList.ForwardLink;
+       Link != &Private->DatabaseList;
+       Link = Link->ForwardLink
+      ) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = DatabaseRecord->PackageList;
+      break;
+    }
+  }
+  if (PackageListNode == NULL) {
+    return EFI_NOT_FOUND;
+  }
+  ImagePackage = PackageListNode->ImagePkg;
+  if (ImagePackage == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Find the image block specified by ImageId
+  //
+  LocalImageId = ImageId;
+  ImageBlock = GetImageIdOrAddress (ImagePackage->ImageBlock, &LocalImageId);
+  if (ImageBlock == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  Flag      = FALSE;
+  BlockType = *ImageBlock;
+
+  switch (BlockType) {
+  case EFI_HII_IIBT_IMAGE_JPEG:
+    //
+    // BUGBUG: need to be supported as soon as image tool is designed.
+    //
+    return EFI_UNSUPPORTED;
+    break;
+
+  case EFI_HII_IIBT_IMAGE_1BIT_TRANS:
+  case EFI_HII_IIBT_IMAGE_4BIT_TRANS:
+  case EFI_HII_IIBT_IMAGE_8BIT_TRANS:
+    Flag = TRUE;
+    //
+    // fall through
+    //
+  case EFI_HII_IIBT_IMAGE_1BIT:
+  case EFI_HII_IIBT_IMAGE_4BIT:
+  case EFI_HII_IIBT_IMAGE_8BIT:
+    //
+    // Use the common block code since the definition of these structures is the same.
+    //
+    CopyMem (&Iibt1bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_1BIT_BLOCK));
+    ImageLength = sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL) *
+                  (Iibt1bit.Bitmap.Width * Iibt1bit.Bitmap.Height);
+    Image->Bitmap = (EFI_GRAPHICS_OUTPUT_BLT_PIXEL *) AllocateZeroPool (ImageLength);
+    if (Image->Bitmap == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    if (Flag) {
+      Image->Flags = EFI_IMAGE_TRANSPARENT;
+    }
+    Image->Width  = Iibt1bit.Bitmap.Width;
+    Image->Height = Iibt1bit.Bitmap.Height;
+
+    PaletteInfo = ImagePackage->PaletteBlock + sizeof (EFI_HII_IMAGE_PALETTE_INFO_HEADER);
+    for (PaletteIndex = 1; PaletteIndex < Iibt1bit.PaletteIndex; PaletteIndex++) {
+      CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));
+      PaletteInfo += PaletteSize + sizeof (UINT16);
+    }
+    ASSERT (PaletteIndex == Iibt1bit.PaletteIndex);
+
+    //
+    // Output bitmap data
+    //
+    if (BlockType == EFI_HII_IIBT_IMAGE_1BIT || BlockType == EFI_HII_IIBT_IMAGE_1BIT_TRANS) {
+      Output1bitPixel (
+        Image,
+        (UINT8 *) (ImageBlock + sizeof (EFI_HII_IIBT_IMAGE_1BIT_BLOCK) - sizeof (UINT8)),
+        (EFI_HII_IMAGE_PALETTE_INFO *) PaletteInfo
+        );
+    } else if (BlockType == EFI_HII_IIBT_IMAGE_4BIT || BlockType == EFI_HII_IIBT_IMAGE_4BIT_TRANS) {
+      Output4bitPixel (
+        Image,
+        (UINT8 *) (ImageBlock + sizeof (EFI_HII_IIBT_IMAGE_4BIT_BLOCK) - sizeof (UINT8)),
+        (EFI_HII_IMAGE_PALETTE_INFO *) PaletteInfo
+        );
+    } else {
+      Output8bitPixel (
+        Image,
+        (UINT8 *) (ImageBlock + sizeof (EFI_HII_IIBT_IMAGE_8BIT_BLOCK) - sizeof (UINT8)),
+        (EFI_HII_IMAGE_PALETTE_INFO *) PaletteInfo
+        );
+    }
+
+    return EFI_SUCCESS;
+    break;
+
+  case EFI_HII_IIBT_IMAGE_24BIT_TRANS:
+    Flag = TRUE;
+    //
+    // fall through
+    //
+  case EFI_HII_IIBT_IMAGE_24BIT:
+    CopyMem (&Width, ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK), sizeof (UINT16));
+    CopyMem (
+      &Height,
+      ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK) + sizeof (UINT16),
+      sizeof (UINT16)
+      );
+    ImageLength = sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL) * (Width * Height);
+    Image->Bitmap = (EFI_GRAPHICS_OUTPUT_BLT_PIXEL *) AllocateZeroPool (ImageLength);
+    if (Image->Bitmap == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    if (Flag) {
+      Image->Flags = EFI_IMAGE_TRANSPARENT;
+    }
+    Image->Width  = Width;
+    Image->Height = Height;
+
+    //
+    // Output the bimap data directly.
+    //
+    Output24bitPixel (
+      Image,
+      (EFI_HII_RGB_PIXEL *) (ImageBlock + sizeof (EFI_HII_IIBT_IMAGE_24BIT_BLOCK) - sizeof (EFI_HII_RGB_PIXEL))
+      );
+    return EFI_SUCCESS;
+    break;
+
+  default:
+    return EFI_NOT_FOUND;
+    break;
+  }
+}
+
+
+/**
+  This function updates the image specified by ImageId in the specified PackageListHandle to
+  the image specified by Image.
+
+  @param  This                   A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  PackageList            The package list containing the images.
+  @param  ImageId                The image's id,, which is unique within
+                                 PackageList.
+  @param  Image                  Points to the image.
+
+  @retval EFI_SUCCESS            The new image was updated successfully.
+  @retval EFI_NOT_FOUND          The image specified by ImageId is not in the
+                                                database. The specified PackageList is not in the database.    
+  @retval EFI_INVALID_PARAMETER  The Image was NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiSetImage (
+  IN CONST EFI_HII_IMAGE_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                  PackageList,
+  IN EFI_IMAGE_ID                    ImageId,
+  IN CONST EFI_IMAGE_INPUT           *Image
+  )
+{
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_IMAGE_PACKAGE_INSTANCE          *ImagePackage;
+  UINT8                               *ImageBlock;
+  EFI_IMAGE_ID                        LocalImageId;
+  UINT8                               BlockType;
+  EFI_HII_IIBT_IMAGE_1BIT_BLOCK       Iibt1bit;
+  EFI_HII_IIBT_IMAGE_4BIT_BLOCK       Iibt4bit;
+  EFI_HII_IIBT_IMAGE_8BIT_BLOCK       Iibt8bit;
+  UINT16                              Width;
+  UINT16                              Height;
+  UINT32                              BlockSize;
+  UINT32                              NewBlockSize;
+  UINT32                              OldBlockSize;
+  EFI_IMAGE_INPUT                     *ImageIn;
+  UINT8                               *NewBlock;
+  UINT8                               *NewBlockPtr;
+  UINT8                               *Block;
+  UINT8                               *BlockPtr;
+  UINT32                               Part1Size;
+  UINT32                               Part2Size;
+
+  if (This == NULL || Image == NULL || ImageId < 1 || Image->Bitmap == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_IMAGE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // Get the specified package list and image package.
+  //
+  PackageListNode = NULL;
+  for (Link = Private->DatabaseList.ForwardLink;
+       Link != &Private->DatabaseList;
+       Link = Link->ForwardLink
+      ) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = DatabaseRecord->PackageList;
+      break;
+    }
+  }
+  if (PackageListNode == NULL) {
+    return EFI_NOT_FOUND;
+  }
+  ImagePackage = PackageListNode->ImagePkg;
+  if (ImagePackage == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Find the image block specified by ImageId
+  //
+  LocalImageId = ImageId;
+  ImageBlock = GetImageIdOrAddress (ImagePackage->ImageBlock, &LocalImageId);
+  if (ImageBlock == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  BlockType = *ImageBlock;
+
+  //
+  // Get the size of original image block. Use some common block code here
+  // since the definition of some structures is the same.
+  //
+  switch (BlockType) {
+  case EFI_HII_IIBT_IMAGE_JPEG:
+    //
+    // BUGBUG: need to be supported as soon as image tool is designed.
+    //
+    return EFI_UNSUPPORTED;
+    break;
+
+  case EFI_HII_IIBT_IMAGE_1BIT:
+  case EFI_HII_IIBT_IMAGE_1BIT_TRANS:
+    CopyMem (&Iibt1bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_1BIT_BLOCK));
+    OldBlockSize = sizeof (EFI_HII_IIBT_IMAGE_1BIT_BLOCK) - sizeof (UINT8) +
+                   BITMAP_LEN_1_BIT (Iibt1bit.Bitmap.Width, Iibt1bit.Bitmap.Height);
+    break;
+  case EFI_HII_IIBT_IMAGE_4BIT:
+  case EFI_HII_IIBT_IMAGE_4BIT_TRANS:
+    CopyMem (&Iibt4bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_4BIT_BLOCK));
+    OldBlockSize = sizeof (EFI_HII_IIBT_IMAGE_4BIT_BLOCK) - sizeof (UINT8) +
+                   BITMAP_LEN_4_BIT (Iibt4bit.Bitmap.Width, Iibt4bit.Bitmap.Height);
+    break;
+  case EFI_HII_IIBT_IMAGE_8BIT:
+  case EFI_HII_IIBT_IMAGE_8BIT_TRANS:
+    CopyMem (&Iibt8bit, ImageBlock, sizeof (EFI_HII_IIBT_IMAGE_8BIT_BLOCK));
+    OldBlockSize = sizeof (EFI_HII_IIBT_IMAGE_8BIT_BLOCK) - sizeof (UINT8) +
+                   BITMAP_LEN_8_BIT (Iibt8bit.Bitmap.Width, Iibt8bit.Bitmap.Height);
+    break;
+  case EFI_HII_IIBT_IMAGE_24BIT:
+  case EFI_HII_IIBT_IMAGE_24BIT_TRANS:
+    CopyMem (&Width, ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK), sizeof (UINT16));
+    CopyMem (
+      &Height,
+      ImageBlock + sizeof (EFI_HII_IMAGE_BLOCK) + sizeof (UINT16),
+      sizeof (UINT16)
+      );
+    OldBlockSize = sizeof (EFI_HII_IIBT_IMAGE_24BIT_BLOCK) - sizeof (EFI_HII_RGB_PIXEL) +
+                   BITMAP_LEN_24_BIT (Width , Height);
+    break;
+  default:
+    return EFI_NOT_FOUND;
+    break;
+  }
+
+  //
+  // Create the new image block according to input image.
+  //
+  ImageIn = (EFI_IMAGE_INPUT *) Image;
+  NewBlockSize = sizeof (EFI_HII_IIBT_IMAGE_24BIT_BLOCK) - sizeof (EFI_HII_RGB_PIXEL) +
+                 BITMAP_LEN_24_BIT (ImageIn->Width, ImageIn->Height);
+  NewBlock = (UINT8 *) AllocateZeroPool (NewBlockSize);
+  if (NewBlock == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  NewBlockPtr = NewBlock;
+  if ((ImageIn->Flags & EFI_IMAGE_TRANSPARENT) == EFI_IMAGE_TRANSPARENT) {
+    *NewBlockPtr = EFI_HII_IIBT_IMAGE_24BIT_TRANS;
+  } else {
+    *NewBlockPtr = EFI_HII_IIBT_IMAGE_24BIT;
+  }
+  NewBlockPtr++;
+
+  CopyMem (NewBlockPtr, &ImageIn->Width, sizeof (UINT16));
+  NewBlockPtr += sizeof (UINT16);
+  CopyMem (NewBlockPtr, &ImageIn->Height, sizeof (UINT16));
+  NewBlockPtr += sizeof (UINT16);
+
+  CopyGopToRgbPixel ((EFI_HII_RGB_PIXEL *) NewBlockPtr, ImageIn->Bitmap, ImageIn->Width * ImageIn->Height);
+
+  //
+  // Adjust the image package to remove the original block firstly then add the new block.
+  //
+  BlockSize = ImagePackage->ImageBlockSize + NewBlockSize - OldBlockSize;
+  Block = (UINT8 *) AllocateZeroPool (BlockSize);
+  if (Block == NULL) {
+    FreePool (NewBlock);
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BlockPtr  = Block;
+  Part1Size = (UINT32) (ImageBlock - ImagePackage->ImageBlock);
+  Part2Size = ImagePackage->ImageBlockSize - Part1Size - OldBlockSize;
+  CopyMem (BlockPtr, ImagePackage->ImageBlock, Part1Size);
+  BlockPtr += Part1Size;
+  CopyMem (BlockPtr, NewBlock, NewBlockSize);
+  BlockPtr += NewBlockSize;
+  CopyMem (BlockPtr, ImageBlock + OldBlockSize, Part2Size);
+
+  FreePool (ImagePackage->ImageBlock);
+  FreePool (NewBlock);
+  ImagePackage->ImageBlock     = Block;
+  ImagePackage->ImageBlockSize = BlockSize;
+  ImagePackage->ImagePkgHdr.Header.Length += NewBlockSize - OldBlockSize;
+  PackageListNode->PackageListHdr.PackageLength += NewBlockSize - OldBlockSize;
+
+  return EFI_SUCCESS;
+
+}
+
+
+/**
+  This function renders an image to a bitmap or the screen using the specified
+  color and options. It draws the image on an existing bitmap, allocates a new
+  bitmap or uses the screen. The images can be clipped.
+
+  @param  This                   A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  Flags                  Describes how the image is to be drawn.
+  @param  Image                  Points to the image to be displayed.
+  @param  Blt                    If this points to a non-NULL on entry, this points
+                                 to the image, which is Width pixels wide and
+                                 Height pixels high.  The image will be drawn onto
+                                 this image and  EFI_HII_DRAW_FLAG_CLIP is implied.
+                                 If this points to a  NULL on entry, then a buffer
+                                 will be allocated to hold  the generated image and
+                                 the pointer updated on exit. It is the caller's
+                                 responsibility to free this buffer.
+  @param  BltX                   Specifies the offset from the left and top edge of
+                                 the  output image of the first pixel in the image.
+  @param  BltY                   Specifies the offset from the left and top edge of
+                                 the  output image of the first pixel in the image.
+
+  @retval EFI_SUCCESS            The image was successfully drawn.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate an output buffer for Blt.
+  @retval EFI_INVALID_PARAMETER  The Image or Blt was NULL.
+  @retval EFI_INVALID_PARAMETER  Any combination of Flags is invalid.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiDrawImage (
+  IN CONST EFI_HII_IMAGE_PROTOCOL    *This,
+  IN EFI_HII_DRAW_FLAGS              Flags,
+  IN CONST EFI_IMAGE_INPUT           *Image,
+  IN OUT EFI_IMAGE_OUTPUT            **Blt,
+  IN UINTN                           BltX,
+  IN UINTN                           BltY
+  )
+{
+  EFI_STATUS                          Status;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  BOOLEAN                             Transparent;
+  EFI_IMAGE_INPUT                     *ImageIn;
+  EFI_IMAGE_OUTPUT                    *ImageOut;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL       *BltBuffer;
+  UINTN                               BufferLen;
+  UINTN                               Width;
+  UINTN                               Height;
+  UINTN                               Xpos;
+  UINTN                               Ypos;
+  UINTN                               OffsetY1;
+  UINTN                               OffsetY2;
+  EFI_FONT_DISPLAY_INFO               *FontInfo;
+  UINTN                               Index;
+
+  if (This == NULL || Image == NULL || Blt == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if ((Flags & EFI_HII_DRAW_FLAG_CLIP) == EFI_HII_DRAW_FLAG_CLIP && *Blt == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if ((Flags & EFI_HII_DRAW_FLAG_TRANSPARENT) == EFI_HII_DRAW_FLAG_TRANSPARENT) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  ImageIn = (EFI_IMAGE_INPUT *) Image;
+
+  //
+  // Check whether the image will be drawn transparently or opaquely.
+  //
+  Transparent = FALSE;
+  if ((Flags & EFI_HII_DRAW_FLAG_TRANSPARENT) == EFI_HII_DRAW_FLAG_FORCE_TRANS) {
+    Transparent = TRUE;
+  } else if ((Flags & EFI_HII_DRAW_FLAG_TRANSPARENT) == EFI_HII_DRAW_FLAG_FORCE_OPAQUE){
+    Transparent = FALSE;
+  } else {
+    //
+    // Now EFI_HII_DRAW_FLAG_DEFAULT is set, whether image will be drawn depending
+    // on the image's transparency setting.
+    //
+    if ((ImageIn->Flags & EFI_IMAGE_TRANSPARENT) == EFI_IMAGE_TRANSPARENT) {
+      Transparent = TRUE;
+    }
+  }
+
+  //
+  // Image cannot be drawn transparently if Blt points to NULL on entry.
+  // Currently output to Screen transparently is not supported, either.
+  //
+  if (Transparent) {
+    if (*Blt == NULL) {
+      return EFI_INVALID_PARAMETER;
+    } else if ((Flags & EFI_HII_DIRECT_TO_SCREEN) == EFI_HII_DIRECT_TO_SCREEN) {
+      return EFI_INVALID_PARAMETER;
+    }
+  }
+
+  Private = HII_IMAGE_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  //
+  // When Blt points to a non-NULL on entry, this image will be drawn onto
+  // this bitmap or screen pointed by "*Blt" and EFI_HII_DRAW_FLAG_CLIP is implied.
+  // Otherwise a new bitmap will be allocated to hold this image.
+  //
+  if (*Blt != NULL) {
+    //
+    // Clip the image by (Width, Height)
+    //
+
+    Width  = ImageIn->Width;
+    Height = ImageIn->Height;
+
+    if (Width > (*Blt)->Width - BltX) {
+      Width = (*Blt)->Width - BltX;
+    }
+    if (Height > (*Blt)->Height - BltY) {
+      Height = (*Blt)->Height - BltY;
+    }
+
+    BufferLen = Width * Height * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL);
+    BltBuffer = (EFI_GRAPHICS_OUTPUT_BLT_PIXEL *) AllocateZeroPool (BufferLen);
+    if (BltBuffer == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    if (Width == ImageIn->Width && Height == ImageIn->Height) {
+      CopyMem (BltBuffer, ImageIn->Bitmap, BufferLen);
+    } else {
+      for (Ypos = 0; Ypos < Height; Ypos++) {
+        OffsetY1 = ImageIn->Width * Ypos;
+        OffsetY2 = Width * Ypos;
+        for (Xpos = 0; Xpos < Width; Xpos++) {
+          BltBuffer[OffsetY2 + Xpos] = ImageIn->Bitmap[OffsetY1 + Xpos];
+        }
+      }
+    }
+
+    //
+    // Draw the image to existing bitmap or screen depending on flag.
+    //
+    if ((Flags & EFI_HII_DIRECT_TO_SCREEN) == EFI_HII_DIRECT_TO_SCREEN) {
+      //
+      // Caller should make sure the current UGA console is grarphic mode.
+      //
+
+      //
+      // Write the image directly to the output device specified by Screen.
+      //
+      Status = (*Blt)->Image.Screen->Blt (
+                                       (*Blt)->Image.Screen,
+                                       BltBuffer,
+                                       EfiBltBufferToVideo,
+                                       0,
+                                       0,
+                                       BltX,
+                                       BltY,
+                                       Width,
+                                       Height,
+                                       0
+                                       );
+    } else {
+      //
+      // Draw the image onto the existing bitmap specified by Bitmap.
+      //
+      Status = ImageToBlt (
+                 BltBuffer,
+                 BltX,
+                 BltY,
+                 Width,
+                 Height,
+                 Transparent,
+                 Blt
+                 );
+
+    }
+
+    FreePool (BltBuffer);
+    return Status;
+
+  } else {
+    //
+    // Allocate a new bitmap to hold the incoming image.
+    //
+    Width  = ImageIn->Width  + BltX;
+    Height = ImageIn->Height + BltY;
+
+    BufferLen = Width * Height * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL);
+    BltBuffer = (EFI_GRAPHICS_OUTPUT_BLT_PIXEL *) AllocateZeroPool (BufferLen);
+    if (BltBuffer == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    ImageOut = (EFI_IMAGE_OUTPUT *) AllocateZeroPool (sizeof (EFI_IMAGE_OUTPUT));
+    if (ImageOut == NULL) {
+      FreePool (BltBuffer);
+      return EFI_OUT_OF_RESOURCES;
+    }
+    ImageOut->Width        = (UINT16) Width;
+    ImageOut->Height       = (UINT16) Height;
+    ImageOut->Image.Bitmap = BltBuffer;
+
+    //
+    // BUGBUG: Now all the "blank" pixels are filled with system default background
+    // color. Not sure if it need to be updated or not.
+    //
+    Status = GetSystemFont (Private, &FontInfo, NULL);
+    if (EFI_ERROR (Status)) {
+      FreePool (BltBuffer);
+      FreePool (ImageOut);
+      return Status;
+    }
+    for (Index = 0; Index < Width * Height; Index++) {
+      BltBuffer[Index] = FontInfo->BackgroundColor;
+    }
+    FreePool (FontInfo);
+
+    //
+    // Draw the incoming image to the new created image.
+    //
+    *Blt = ImageOut;
+    return ImageToBlt (
+             ImageIn->Bitmap,
+             BltX,
+             BltY,
+             ImageIn->Width,
+             ImageIn->Height,
+             Transparent,
+             Blt
+             );
+
+  }
+}
+
+
+/**
+  This function renders an image to a bitmap or the screen using the specified
+  color and options. It draws the image on an existing bitmap, allocates a new
+  bitmap or uses the screen. The images can be clipped.
+
+  @param  This                   A pointer to the EFI_HII_IMAGE_PROTOCOL instance.
+  @param  Flags                  Describes how the image is to be drawn.
+  @param  PackageList            The package list in the HII database to search for
+                                 the  specified image.
+  @param  ImageId                The image's id, which is unique within
+                                 PackageList.
+  @param  Blt                    If this points to a non-NULL on entry, this points
+                                 to the image, which is Width pixels wide and
+                                 Height pixels high. The image will be drawn onto
+                                 this image and
+                                 EFI_HII_DRAW_FLAG_CLIP is implied. If this points
+                                 to a  NULL on entry, then a buffer will be
+                                 allocated to hold  the generated image and the
+                                 pointer updated on exit. It is the caller's
+                                 responsibility to free this buffer.
+  @param  BltX                   Specifies the offset from the left and top edge of
+                                 the  output image of the first pixel in the image.
+  @param  BltY                   Specifies the offset from the left and top edge of
+                                 the  output image of the first pixel in the image.
+
+  @retval EFI_SUCCESS            The image was successfully drawn.
+  @retval EFI_OUT_OF_RESOURCES   Unable to allocate an output buffer for Blt.
+  @retval EFI_INVALID_PARAMETER  The Blt was NULL.
+  @retval EFI_NOT_FOUND          The image specified by ImageId is not in the database. 
+                           The specified PackageList is not in the database.                             
+
+**/
+EFI_STATUS
+EFIAPI
+HiiDrawImageId (
+  IN CONST EFI_HII_IMAGE_PROTOCOL    *This,
+  IN EFI_HII_DRAW_FLAGS              Flags,
+  IN EFI_HII_HANDLE                  PackageList,
+  IN EFI_IMAGE_ID                    ImageId,
+  IN OUT EFI_IMAGE_OUTPUT            **Blt,
+  IN UINTN                           BltX,
+  IN UINTN                           BltY
+  )
+{
+  EFI_STATUS                          Status;
+  EFI_IMAGE_INPUT                     Image;
+
+  //
+  // Check input parameter.
+  //
+  if (This == NULL || Blt == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Get the specified Image.
+  //
+  Status = HiiGetImage (This, PackageList, ImageId, &Image);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Draw this image.
+  //
+  Status = HiiDrawImage (This, Flags, &Image, Blt, BltX, BltY);
+  if (Image.Bitmap != NULL) {
+    FreePool (Image.Bitmap);
+  }
+  return Status;
+}
+
Index: Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/String.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/String.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/HiiDatabaseDxe/String.c	(working copy)
@@ -0,0 +1,2045 @@
+/** @file
+Implementation for EFI_HII_STRING_PROTOCOL.
+
+
+Copyright (c) 2007 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "HiiDatabase.h"
+
+CHAR16 mLanguageWindow[16] = {
+  0x0000, 0x0080, 0x0100, 0x0300,
+  0x2000, 0x2080, 0x2100, 0x3000,
+  0x0080, 0x00C0, 0x0400, 0x0600,
+  0x0900, 0x3040, 0x30A0, 0xFF00
+};
+
+
+/**
+  This function checks whether a global font info is referred by local
+  font info list or not. (i.e. HII_FONT_INFO is generated.) If not, create
+  a HII_FONT_INFO to refer it locally.
+
+  This is a internal function.
+
+
+  @param  Private                Hii database private structure.
+  @param  StringPackage          HII string package instance.
+  @param  FontId                Font identifer, which must be unique within the string package.
+  @param  DuplicateEnable        If true, duplicate HII_FONT_INFO which refers to
+                                 the same EFI_FONT_INFO is permitted. Otherwise it
+                                 is not allowed.
+  @param  GlobalFontInfo         Input a global font info which specify a
+                                 EFI_FONT_INFO.
+  @param  LocalFontInfo          Output a local font info which refers to a
+                                 EFI_FONT_INFO.
+
+  @retval TRUE                   Already referred before calling this function.
+  @retval FALSE                  Not referred before calling this function.
+
+**/
+BOOLEAN
+ReferFontInfoLocally (
+  IN  HII_DATABASE_PRIVATE_DATA   *Private,
+  IN  HII_STRING_PACKAGE_INSTANCE *StringPackage,
+  IN  UINT8                       FontId,
+  IN  BOOLEAN                     DuplicateEnable,
+  IN  HII_GLOBAL_FONT_INFO        *GlobalFontInfo,
+  OUT HII_FONT_INFO               **LocalFontInfo
+  )
+{
+  HII_FONT_INFO                 *LocalFont;
+  LIST_ENTRY                    *Link;
+
+  ASSERT (Private != NULL && StringPackage != NULL && GlobalFontInfo != NULL && LocalFontInfo != NULL);
+
+  if (!DuplicateEnable) {
+    for (Link = StringPackage->FontInfoList.ForwardLink;
+         Link != &StringPackage->FontInfoList;
+         Link = Link->ForwardLink
+        ) {
+      LocalFont = CR (Link, HII_FONT_INFO, Entry, HII_FONT_INFO_SIGNATURE);
+      if (LocalFont->GlobalEntry == &GlobalFontInfo->Entry) {
+        //
+        // Already referred by local font info list, return directly.
+        //
+        *LocalFontInfo = LocalFont;
+        return TRUE;
+      }
+    }
+  }
+  // FontId identifies EFI_FONT_INFO in local string package uniquely.
+  // GlobalEntry points to a HII_GLOBAL_FONT_INFO which identifies
+  // EFI_FONT_INFO uniquely in whole hii database.
+  //
+  LocalFont = (HII_FONT_INFO *) AllocateZeroPool (sizeof (HII_FONT_INFO));
+  ASSERT (LocalFont != NULL);
+
+  LocalFont->Signature   = HII_FONT_INFO_SIGNATURE;
+  LocalFont->FontId      = FontId;
+  LocalFont->GlobalEntry = &GlobalFontInfo->Entry;
+  InsertTailList (&StringPackage->FontInfoList, &LocalFont->Entry);
+
+  *LocalFontInfo = LocalFont;
+  return FALSE;
+}
+
+
+/**
+  Convert Ascii string text to unicode string test.
+
+  This is a internal function.
+
+
+  @param  StringDest             Buffer to store the string text. If it is NULL,
+                                 only the size will be returned.
+  @param  StringSrc              Points to current null-terminated string.
+  @param  BufferSize             Length of the buffer.
+
+  @retval EFI_SUCCESS            The string text was outputed successfully.
+  @retval EFI_BUFFER_TOO_SMALL   Buffer is insufficient to store the found string
+                                 text. BufferSize is updated to the required buffer
+                                 size.
+
+**/
+EFI_STATUS
+ConvertToUnicodeText (
+  OUT EFI_STRING       StringDest,
+  IN  CHAR8            *StringSrc,
+  IN  OUT UINTN        *BufferSize
+  )
+{
+  UINTN  StringSize;
+  UINTN  Index;
+
+  ASSERT (StringSrc != NULL && BufferSize != NULL);
+
+  StringSize = AsciiStrSize (StringSrc) * 2;
+  if (*BufferSize < StringSize || StringDest == NULL) {
+    *BufferSize = StringSize;
+    return EFI_BUFFER_TOO_SMALL;
+  }
+
+  for (Index = 0; Index < AsciiStrLen (StringSrc); Index++) {
+    StringDest[Index] = (CHAR16) StringSrc[Index];
+  }
+
+  StringDest[Index] = 0;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Calculate the size of StringSrc and output it. If StringDest is not NULL,
+  copy string text from src to dest.
+
+  This is a internal function.
+
+  @param  StringDest             Buffer to store the string text. If it is NULL,
+                                 only the size will be returned.
+  @param  StringSrc              Points to current null-terminated string.
+  @param  BufferSize             Length of the buffer.
+
+  @retval EFI_SUCCESS            The string text was outputed successfully.
+  @retval EFI_BUFFER_TOO_SMALL   Buffer is insufficient to store the found string
+                                 text. BufferSize is updated to the required buffer
+                                 size.
+
+**/
+EFI_STATUS
+GetUnicodeStringTextOrSize (
+  OUT EFI_STRING       StringDest, OPTIONAL
+  IN  UINT8            *StringSrc,
+  IN  OUT UINTN        *BufferSize
+  )
+{
+  UINTN  StringSize;
+  UINT8  *StringPtr;
+
+  ASSERT (StringSrc != NULL && BufferSize != NULL);
+
+  StringSize = sizeof (CHAR16);
+  StringPtr  = StringSrc;
+  while (ReadUnaligned16 ((UINT16 *) StringPtr) != 0) {
+    StringSize += sizeof (CHAR16);
+    StringPtr += sizeof (CHAR16);
+  }
+
+  if (*BufferSize < StringSize) {
+    *BufferSize = StringSize;
+    return EFI_BUFFER_TOO_SMALL;
+  }
+  if (StringDest != NULL) {
+    CopyMem (StringDest, StringSrc, StringSize);
+  }
+
+  *BufferSize = StringSize;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Copy string font info to a buffer.
+
+  This is a internal function.
+
+  @param  StringPackage          Hii string package instance.
+  @param  FontId                 Font identifier which is unique in a string
+                                 package.
+  @param  StringFontInfo         Buffer to record the output font info. It's
+                                 caller's responsibility to free this buffer.
+
+  @retval EFI_SUCCESS            The string font is outputed successfully.
+  @retval EFI_NOT_FOUND          The specified font id does not exist.
+
+**/
+EFI_STATUS
+GetStringFontInfo (
+  IN  HII_STRING_PACKAGE_INSTANCE     *StringPackage,
+  IN  UINT8                           FontId,
+  OUT EFI_FONT_INFO                   **StringFontInfo
+  )
+{
+  LIST_ENTRY                           *Link;
+  HII_FONT_INFO                        *FontInfo;
+  HII_GLOBAL_FONT_INFO                 *GlobalFont;
+
+  ASSERT (StringFontInfo != NULL && StringPackage != NULL);
+
+  for (Link = StringPackage->FontInfoList.ForwardLink; Link != &StringPackage->FontInfoList; Link = Link->ForwardLink) {
+    FontInfo = CR (Link, HII_FONT_INFO, Entry, HII_FONT_INFO_SIGNATURE);
+    if (FontInfo->FontId == FontId) {
+      GlobalFont = CR (FontInfo->GlobalEntry, HII_GLOBAL_FONT_INFO, Entry, HII_GLOBAL_FONT_INFO_SIGNATURE);
+      *StringFontInfo = (EFI_FONT_INFO *) AllocateZeroPool (GlobalFont->FontInfoSize);
+      if (*StringFontInfo == NULL) {
+        return EFI_OUT_OF_RESOURCES;
+      }
+      CopyMem (*StringFontInfo, GlobalFont->FontInfo, GlobalFont->FontInfoSize);
+      return EFI_SUCCESS;
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  Parse all string blocks to find a String block specified by StringId.
+  If StringId = (EFI_STRING_ID) (-1), find out all EFI_HII_SIBT_FONT blocks
+  within this string package and backup its information. If LastStringId is 
+  specified, the string id of last string block will also be output.
+  If StringId = 0, output the string id of last string block (EFI_HII_SIBT_STRING).
+
+  @param  Private                 Hii database private structure.
+  @param  StringPackage           Hii string package instance.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.
+  @param  BlockType               Output the block type of found string block.
+  @param  StringBlockAddr         Output the block address of found string block.
+  @param  StringTextOffset        Offset, relative to the found block address, of
+                                  the  string text information.
+  @param  LastStringId            Output the last string id when StringId = 0 or StringId = -1.
+  @param  StartStringId           The first id in the skip block which StringId in the block.
+
+  @retval EFI_SUCCESS             The string text and font is retrieved
+                                  successfully.
+  @retval EFI_NOT_FOUND           The specified text or font info can not be found
+                                  out.
+  @retval EFI_OUT_OF_RESOURCES    The system is out of resources to accomplish the
+                                  task.
+
+**/
+EFI_STATUS
+FindStringBlock (
+  IN HII_DATABASE_PRIVATE_DATA        *Private,
+  IN  HII_STRING_PACKAGE_INSTANCE     *StringPackage,
+  IN  EFI_STRING_ID                   StringId,
+  OUT UINT8                           *BlockType, OPTIONAL
+  OUT UINT8                           **StringBlockAddr, OPTIONAL
+  OUT UINTN                           *StringTextOffset, OPTIONAL
+  OUT EFI_STRING_ID                   *LastStringId, OPTIONAL
+  OUT EFI_STRING_ID                   *StartStringId OPTIONAL
+  )
+{
+  UINT8                                *BlockHdr;
+  EFI_STRING_ID                        CurrentStringId;
+  UINTN                                BlockSize;
+  UINTN                                Index;
+  UINT8                                *StringTextPtr;
+  UINTN                                Offset;
+  HII_FONT_INFO                        *LocalFont;
+  EFI_FONT_INFO                        *FontInfo;
+  HII_GLOBAL_FONT_INFO                 *GlobalFont;
+  UINTN                                FontInfoSize;
+  UINT16                               StringCount;
+  UINT16                               SkipCount;
+  EFI_HII_FONT_STYLE                   FontStyle;
+  UINT16                               FontSize;
+  UINT8                                Length8;
+  EFI_HII_SIBT_EXT2_BLOCK              Ext2;
+  UINT8                                FontId;
+  UINT32                               Length32;
+  UINTN                                StringSize;
+  CHAR16                               Zero;
+
+  ASSERT (StringPackage != NULL);
+  ASSERT (StringPackage->Signature == HII_STRING_PACKAGE_SIGNATURE);
+
+  CurrentStringId = 1;
+
+  if (StringId != (EFI_STRING_ID) (-1) && StringId != 0) {
+    ASSERT (BlockType != NULL && StringBlockAddr != NULL && StringTextOffset != NULL);
+    if (StringId > StringPackage->MaxStringId) {
+      return EFI_NOT_FOUND;
+    }
+  } else {
+    ASSERT (Private != NULL && Private->Signature == HII_DATABASE_PRIVATE_DATA_SIGNATURE);
+    if (StringId == 0 && LastStringId != NULL) {
+      *LastStringId = StringPackage->MaxStringId;
+      return EFI_SUCCESS;
+    }
+  }
+
+  ZeroMem (&Zero, sizeof (CHAR16));
+
+  //
+  // Parse the string blocks to get the string text and font.
+  //
+  BlockHdr  = StringPackage->StringBlock;
+  BlockSize = 0;
+  Offset    = 0;
+  while (*BlockHdr != EFI_HII_SIBT_END) {
+    switch (*BlockHdr) {
+    case EFI_HII_SIBT_STRING_SCSU:
+      Offset = sizeof (EFI_HII_STRING_BLOCK);
+      StringTextPtr = BlockHdr + Offset;
+      BlockSize += Offset + AsciiStrSize ((CHAR8 *) StringTextPtr);
+      CurrentStringId++;
+      break;
+
+    case EFI_HII_SIBT_STRING_SCSU_FONT:
+      Offset = sizeof (EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK) - sizeof (UINT8);
+      StringTextPtr = BlockHdr + Offset;
+      BlockSize += Offset + AsciiStrSize ((CHAR8 *) StringTextPtr);
+      CurrentStringId++;
+      break;
+
+    case EFI_HII_SIBT_STRINGS_SCSU:
+      CopyMem (&StringCount, BlockHdr + sizeof (EFI_HII_STRING_BLOCK), sizeof (UINT16));
+      StringTextPtr = BlockHdr + sizeof (EFI_HII_SIBT_STRINGS_SCSU_BLOCK) - sizeof (UINT8);
+      BlockSize += StringTextPtr - BlockHdr;
+
+      for (Index = 0; Index < StringCount; Index++) {
+        BlockSize += AsciiStrSize ((CHAR8 *) StringTextPtr);
+        if (CurrentStringId == StringId) {
+          ASSERT (BlockType != NULL && StringBlockAddr != NULL && StringTextOffset != NULL);
+          *BlockType        = *BlockHdr;
+          *StringBlockAddr  = BlockHdr;
+          *StringTextOffset = StringTextPtr - BlockHdr;
+          return EFI_SUCCESS;
+        }
+        StringTextPtr = StringTextPtr + AsciiStrSize ((CHAR8 *) StringTextPtr);
+        CurrentStringId++;
+      }
+      break;
+
+    case EFI_HII_SIBT_STRINGS_SCSU_FONT:
+      CopyMem (
+        &StringCount,
+        BlockHdr + sizeof (EFI_HII_STRING_BLOCK) + sizeof (UINT8),
+        sizeof (UINT16)
+        );
+      StringTextPtr = BlockHdr + sizeof (EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK) - sizeof (UINT8);
+      BlockSize += StringTextPtr - BlockHdr;
+
+      for (Index = 0; Index < StringCount; Index++) {
+        BlockSize += AsciiStrSize ((CHAR8 *) StringTextPtr);
+        if (CurrentStringId == StringId) {
+          ASSERT (BlockType != NULL && StringBlockAddr != NULL && StringTextOffset != NULL);
+          *BlockType        = *BlockHdr;
+          *StringBlockAddr  = BlockHdr;
+          *StringTextOffset = StringTextPtr - BlockHdr;
+          return EFI_SUCCESS;
+        }
+        StringTextPtr = StringTextPtr + AsciiStrSize ((CHAR8 *) StringTextPtr);
+        CurrentStringId++;
+      }
+      break;
+
+    case EFI_HII_SIBT_STRING_UCS2:
+      Offset        = sizeof (EFI_HII_STRING_BLOCK);
+      StringTextPtr = BlockHdr + Offset;
+      //
+      // Use StringSize to store the size of the specified string, including the NULL
+      // terminator.
+      //
+      GetUnicodeStringTextOrSize (NULL, StringTextPtr, &StringSize);
+      BlockSize += Offset + StringSize;
+      CurrentStringId++;
+      break;
+
+    case EFI_HII_SIBT_STRING_UCS2_FONT:
+      Offset = sizeof (EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK)  - sizeof (CHAR16);
+      StringTextPtr = BlockHdr + Offset;
+      //
+      // Use StrSize to store the size of the specified string, including the NULL
+      // terminator.
+      //
+      GetUnicodeStringTextOrSize (NULL, StringTextPtr, &StringSize);
+      BlockSize += Offset + StringSize;
+      CurrentStringId++;
+      break;
+
+    case EFI_HII_SIBT_STRINGS_UCS2:
+      Offset = sizeof (EFI_HII_SIBT_STRINGS_UCS2_BLOCK) - sizeof (CHAR16);
+      StringTextPtr = BlockHdr + Offset;
+      BlockSize += Offset;
+      CopyMem (&StringCount, BlockHdr + sizeof (EFI_HII_STRING_BLOCK), sizeof (UINT16));
+      for (Index = 0; Index < StringCount; Index++) {
+        GetUnicodeStringTextOrSize (NULL, StringTextPtr, &StringSize);
+        BlockSize += StringSize;
+        if (CurrentStringId == StringId) {
+          ASSERT (BlockType != NULL && StringBlockAddr != NULL && StringTextOffset != NULL);
+          *BlockType        = *BlockHdr;
+          *StringBlockAddr  = BlockHdr;
+          *StringTextOffset = StringTextPtr - BlockHdr;
+          return EFI_SUCCESS;
+        }
+        StringTextPtr = StringTextPtr + StringSize;
+        CurrentStringId++;
+      }
+      break;
+
+    case EFI_HII_SIBT_STRINGS_UCS2_FONT:
+      Offset = sizeof (EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK) - sizeof (CHAR16);
+      StringTextPtr = BlockHdr + Offset;
+      BlockSize += Offset;
+      CopyMem (
+        &StringCount,
+        BlockHdr + sizeof (EFI_HII_STRING_BLOCK) + sizeof (UINT8),
+        sizeof (UINT16)
+        );
+      for (Index = 0; Index < StringCount; Index++) {
+        GetUnicodeStringTextOrSize (NULL, StringTextPtr, &StringSize);
+        BlockSize += StringSize;
+        if (CurrentStringId == StringId) {
+          ASSERT (BlockType != NULL && StringBlockAddr != NULL && StringTextOffset != NULL);
+          *BlockType        = *BlockHdr;
+          *StringBlockAddr  = BlockHdr;
+          *StringTextOffset = StringTextPtr - BlockHdr;
+          return EFI_SUCCESS;
+        }
+        StringTextPtr = StringTextPtr + StringSize;
+        CurrentStringId++;
+      }
+      break;
+
+    case EFI_HII_SIBT_DUPLICATE:
+      if (CurrentStringId == StringId) {
+        //
+        // Incoming StringId is an id of a duplicate string block.
+        // Update the StringId to be the previous string block.
+        // Go back to the header of string block to search.
+        //
+        CopyMem (
+          &StringId,
+          BlockHdr + sizeof (EFI_HII_STRING_BLOCK),
+          sizeof (EFI_STRING_ID)
+          );
+        ASSERT (StringId != CurrentStringId);
+        CurrentStringId = 1;
+        BlockSize       = 0;
+      } else {
+        BlockSize       += sizeof (EFI_HII_SIBT_DUPLICATE_BLOCK);
+        CurrentStringId++;
+      }
+      break;
+
+    case EFI_HII_SIBT_SKIP1:
+      SkipCount = (UINT16) (*(BlockHdr + sizeof (EFI_HII_STRING_BLOCK)));
+      CurrentStringId = (UINT16) (CurrentStringId + SkipCount);
+      BlockSize       +=  sizeof (EFI_HII_SIBT_SKIP1_BLOCK);
+      break;
+
+    case EFI_HII_SIBT_SKIP2:
+      CopyMem (&SkipCount, BlockHdr + sizeof (EFI_HII_STRING_BLOCK), sizeof (UINT16));
+      CurrentStringId = (UINT16) (CurrentStringId + SkipCount);
+      BlockSize       +=  sizeof (EFI_HII_SIBT_SKIP2_BLOCK);
+      break;
+
+    case EFI_HII_SIBT_EXT1:
+      CopyMem (
+        &Length8,
+        BlockHdr + sizeof (EFI_HII_STRING_BLOCK) + sizeof (UINT8),
+        sizeof (UINT8)
+        );
+      BlockSize += Length8;
+      break;
+
+    case EFI_HII_SIBT_EXT2:
+      CopyMem (&Ext2, BlockHdr, sizeof (EFI_HII_SIBT_EXT2_BLOCK));
+      if (Ext2.BlockType2 == EFI_HII_SIBT_FONT && StringId == (EFI_STRING_ID) (-1)) {
+        //
+        // Find the relationship between global font info and the font info of
+        // this EFI_HII_SIBT_FONT block then backup its information in local package.
+        //
+        BlockHdr += sizeof (EFI_HII_SIBT_EXT2_BLOCK);
+        CopyMem (&FontId, BlockHdr, sizeof (UINT8));
+        BlockHdr += sizeof (UINT8);
+        CopyMem (&FontSize, BlockHdr, sizeof (UINT16));
+        BlockHdr += sizeof (UINT16);
+        CopyMem (&FontStyle, BlockHdr, sizeof (EFI_HII_FONT_STYLE));
+        BlockHdr += sizeof (EFI_HII_FONT_STYLE);
+        GetUnicodeStringTextOrSize (NULL, BlockHdr, &StringSize);
+
+        FontInfoSize = sizeof (EFI_FONT_INFO) - sizeof (CHAR16) + StringSize;
+        FontInfo = (EFI_FONT_INFO *) AllocateZeroPool (FontInfoSize);
+        if (FontInfo == NULL) {
+          return EFI_OUT_OF_RESOURCES;
+        }
+        FontInfo->FontStyle = FontStyle;
+        FontInfo->FontSize  = FontSize;
+        CopyMem (FontInfo->FontName, BlockHdr, StringSize);
+
+        //
+        // If find the corresponding global font info, save the relationship.
+        // Otherwise ignore this EFI_HII_SIBT_FONT block.
+        //
+        if (IsFontInfoExisted (Private, FontInfo, NULL, NULL, &GlobalFont)) {
+          ReferFontInfoLocally (Private, StringPackage, FontId, TRUE, GlobalFont, &LocalFont);
+        }
+
+        //
+        // Since string package tool set FontId initially to 0 and increases it
+        // progressively by one, StringPackage->FondId always represents an unique
+        // and available FontId.
+        //        
+        StringPackage->FontId++;
+
+        FreePool (FontInfo);
+      }
+
+      BlockSize += Ext2.Length;
+
+      break;
+
+    case EFI_HII_SIBT_EXT4:
+      CopyMem (
+        &Length32,
+        BlockHdr + sizeof (EFI_HII_STRING_BLOCK) + sizeof (UINT8),
+        sizeof (UINT32)
+        );
+
+      BlockSize += Length32;
+      break;
+
+    default:
+      break;
+    }
+
+    if (StringId > 0 && StringId != (EFI_STRING_ID)(-1)) {
+      ASSERT (BlockType != NULL && StringBlockAddr != NULL && StringTextOffset != NULL);
+      *BlockType        = *BlockHdr;
+      *StringBlockAddr  = BlockHdr;
+      *StringTextOffset = Offset;
+
+      if (StringId == CurrentStringId - 1) {
+        //
+        // if only one skip item, return EFI_NOT_FOUND.
+        //
+        if(*BlockType == EFI_HII_SIBT_SKIP2 || *BlockType == EFI_HII_SIBT_SKIP1) {
+          return EFI_NOT_FOUND;
+        } else {
+          return EFI_SUCCESS;
+        }
+      }
+
+      if (StringId < CurrentStringId - 1) {
+        return EFI_NOT_FOUND;
+      }
+    }
+    BlockHdr  = StringPackage->StringBlock + BlockSize;
+    if (StartStringId != NULL) {
+        *StartStringId  = CurrentStringId;
+    }
+  }
+  
+  //
+  // Get last string ID
+  //
+  if (StringId == (EFI_STRING_ID) (-1) && LastStringId != NULL) {
+    *LastStringId = (EFI_STRING_ID) (CurrentStringId - 1);
+    return EFI_SUCCESS;
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+/**
+  Parse all string blocks to get a string specified by StringId.
+
+  This is a internal function.
+
+  @param  Private                Hii database private structure.
+  @param  StringPackage          Hii string package instance.
+  @param  StringId               The string's id, which is unique within
+                                 PackageList.
+  @param  String                 Points to retrieved null-terminated string.
+  @param  StringSize             On entry, points to the size of the buffer pointed
+                                 to by String, in bytes. On return, points to the
+                                 length of the string, in bytes.
+  @param  StringFontInfo         If not NULL, allocate a buffer to record the
+                                 output font info. It's caller's responsibility to
+                                 free this buffer.
+
+  @retval EFI_SUCCESS            The string text and font is retrieved
+                                 successfully.
+  @retval EFI_NOT_FOUND          The specified text or font info can not be found
+                                 out.
+  @retval EFI_BUFFER_TOO_SMALL   The buffer specified by StringSize is too small to
+                                 hold the string.
+
+**/
+EFI_STATUS
+GetStringWorker (
+  IN HII_DATABASE_PRIVATE_DATA        *Private,
+  IN  HII_STRING_PACKAGE_INSTANCE     *StringPackage,
+  IN  EFI_STRING_ID                   StringId,
+  OUT EFI_STRING                      String,
+  IN  OUT UINTN                       *StringSize, OPTIONAL
+  OUT EFI_FONT_INFO                   **StringFontInfo OPTIONAL
+  )
+{
+  UINT8                                *StringTextPtr;
+  UINT8                                BlockType;
+  UINT8                                *StringBlockAddr;
+  UINTN                                StringTextOffset;
+  EFI_STATUS                           Status;
+  UINT8                                FontId;
+
+  ASSERT (StringPackage != NULL);
+  ASSERT (Private != NULL && Private->Signature == HII_DATABASE_PRIVATE_DATA_SIGNATURE);
+
+  //
+  // Find the specified string block
+  //
+  Status = FindStringBlock (
+             Private,
+             StringPackage,
+             StringId,
+             &BlockType,
+             &StringBlockAddr,
+             &StringTextOffset,
+             NULL,
+             NULL
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  if (StringSize == NULL) {
+    //
+    // String text buffer is not requested
+    //
+    return EFI_SUCCESS;
+  }
+
+  //
+  // Get the string text.
+  //
+  StringTextPtr = StringBlockAddr + StringTextOffset;
+  switch (BlockType) {
+  case EFI_HII_SIBT_STRING_SCSU:
+  case EFI_HII_SIBT_STRING_SCSU_FONT:
+  case EFI_HII_SIBT_STRINGS_SCSU:
+  case EFI_HII_SIBT_STRINGS_SCSU_FONT:
+    Status = ConvertToUnicodeText (String, (CHAR8 *) StringTextPtr, StringSize);
+    break;
+  case EFI_HII_SIBT_STRING_UCS2:
+  case EFI_HII_SIBT_STRING_UCS2_FONT:
+  case EFI_HII_SIBT_STRINGS_UCS2:
+  case EFI_HII_SIBT_STRINGS_UCS2_FONT:
+    Status = GetUnicodeStringTextOrSize (String, StringTextPtr, StringSize);
+    break;
+  default:
+    return EFI_NOT_FOUND;
+  }
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Get the string font. The FontId 0 is the default font for those string blocks which 
+  // do not specify a font identifier. If default font is not specified, return NULL.
+  //
+  if (StringFontInfo != NULL) {
+    switch (BlockType) {
+    case EFI_HII_SIBT_STRING_SCSU_FONT:
+    case EFI_HII_SIBT_STRINGS_SCSU_FONT:
+    case EFI_HII_SIBT_STRING_UCS2_FONT:
+    case EFI_HII_SIBT_STRINGS_UCS2_FONT:
+      FontId = *(StringBlockAddr + sizeof (EFI_HII_STRING_BLOCK));
+      break;
+    default:
+      FontId = 0;
+    }
+    Status = GetStringFontInfo (StringPackage, FontId, StringFontInfo);
+    if (Status == EFI_NOT_FOUND) {
+        *StringFontInfo = NULL;
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  If GetStringBlock find the StringId's string is not saved in the exist string block,
+  this function will create the UCS2 string block to save the string; also split the 
+  skip block into two or one skip block.
+
+  This is a internal function.
+  
+  @param  StringPackage           Hii string package instance.
+  @param  StartStringId           The first id in the skip block which StringId in the block.
+  @param  StringId                The string's id, which is unique within
+                                  PackageList.  
+  @param  BlockType               Output the block type of found string block.  
+  @param  StringBlockAddr         Output the block address of found string block.  
+  @param  FontBlock               whether this string block has font info.
+
+  @retval EFI_SUCCESS            The string font is outputed successfully.
+  @retval EFI_OUT_OF_RESOURCES   NO resource for the memory to save the new string block.
+
+**/
+EFI_STATUS
+InsertLackStringBlock (
+  IN OUT HII_STRING_PACKAGE_INSTANCE         *StringPackage,
+  IN EFI_STRING_ID                           StartStringId,
+  IN EFI_STRING_ID                           StringId,
+  IN OUT UINT8                               *BlockType,
+  IN OUT UINT8                               **StringBlockAddr,
+  IN BOOLEAN                                 FontBlock
+  )
+{
+  UINT8                                *BlockPtr;
+  UINT8                                *StringBlock;
+  UINT32                               SkipLen;    
+  UINT32                               OldBlockSize;
+  UINT32                               NewBlockSize;
+  UINT32                               FrontSkipNum;
+  UINT32                               NewUCSBlockLen;
+  UINT8                                *OldStringAddr;
+  UINT32                               IdCount;
+
+  FrontSkipNum  = 0;
+  SkipLen       = 0;
+  OldStringAddr = *StringBlockAddr;
+  
+  ASSERT (*BlockType == EFI_HII_SIBT_SKIP1 || *BlockType == EFI_HII_SIBT_SKIP2);
+  //
+  // Old skip block size.
+  //
+  if (*BlockType == EFI_HII_SIBT_SKIP1) {
+    SkipLen = sizeof (EFI_HII_SIBT_SKIP1_BLOCK);
+    IdCount = *(UINT8*)(OldStringAddr + sizeof (EFI_HII_STRING_BLOCK));
+  } else {
+    SkipLen = sizeof (EFI_HII_SIBT_SKIP2_BLOCK);
+    IdCount = *(UINT16*)(OldStringAddr + sizeof (EFI_HII_STRING_BLOCK));
+  } 
+
+  //
+  // New create UCS or UCS2 block size.
+  //
+  if (FontBlock) {
+    NewUCSBlockLen = sizeof (EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK);
+  } else {
+    NewUCSBlockLen = sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK);
+  }
+
+  OldBlockSize = StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+
+  if (StartStringId == StringId) {
+    //
+    // New block + [Skip block]
+    //
+    if (IdCount > 1) {
+      NewBlockSize = OldBlockSize + NewUCSBlockLen;
+    } else {
+      NewBlockSize = OldBlockSize + NewUCSBlockLen - SkipLen;
+    }
+  } else if (StartStringId + IdCount - 1 == StringId){
+    //
+    // Skip block + New block
+    //
+    NewBlockSize = OldBlockSize + NewUCSBlockLen;
+    FrontSkipNum = StringId - StartStringId;
+  } else {
+    //
+    // Skip block + New block + [Skip block]
+    //
+    NewBlockSize = OldBlockSize + NewUCSBlockLen + SkipLen;
+    FrontSkipNum = StringId - StartStringId;
+  }
+
+  StringBlock = (UINT8 *) AllocateZeroPool (NewBlockSize);
+  if (StringBlock == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // Copy old block in front of skip block.
+  //
+  CopyMem (StringBlock, StringPackage->StringBlock, OldStringAddr - StringPackage->StringBlock);  
+  BlockPtr = StringBlock + (OldStringAddr - StringPackage->StringBlock);
+
+  if (FrontSkipNum > 0) {
+    *BlockPtr = *BlockType;
+    if (*BlockType == EFI_HII_SIBT_SKIP1) {
+      *(BlockPtr + sizeof (EFI_HII_STRING_BLOCK)) = (UINT8) FrontSkipNum;
+    } else {
+      *(UINT16 *)(BlockPtr + sizeof (EFI_HII_STRING_BLOCK)) = (UINT16) FrontSkipNum;
+    }
+    BlockPtr += SkipLen;
+  }
+
+  //
+  // Create a EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK
+  //
+  *StringBlockAddr = BlockPtr;
+  if (FontBlock) {
+    *BlockPtr = EFI_HII_SIBT_STRING_UCS2_FONT;
+  } else {
+    *BlockPtr = EFI_HII_SIBT_STRING_UCS2;
+  }
+  BlockPtr += NewUCSBlockLen;
+
+  if (IdCount > FrontSkipNum + 1) {
+    *BlockPtr = *BlockType;
+    if (*BlockType == EFI_HII_SIBT_SKIP1) {
+      *(BlockPtr + sizeof (EFI_HII_STRING_BLOCK)) = (UINT8) (IdCount - FrontSkipNum - 1);
+    } else {
+      *(UINT16 *)(BlockPtr + sizeof (EFI_HII_STRING_BLOCK)) = (UINT16) (IdCount - FrontSkipNum - 1);
+    }
+    BlockPtr += SkipLen;
+  }
+
+  //
+  // Append a EFI_HII_SIBT_END block to the end.
+  //
+  CopyMem (BlockPtr, OldStringAddr + SkipLen, OldBlockSize - (OldStringAddr - StringPackage->StringBlock) - SkipLen);  
+
+  if (FontBlock) {
+    *BlockType = EFI_HII_SIBT_STRING_UCS2_FONT;
+  } else {
+    *BlockType = EFI_HII_SIBT_STRING_UCS2;
+  }
+  FreePool (StringPackage->StringBlock);
+  StringPackage->StringBlock = StringBlock;
+  StringPackage->StringPkgHdr->Header.Length += NewBlockSize - OldBlockSize;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Parse all string blocks to set a String specified by StringId.
+
+  This is a internal function.
+
+  @param  Private                HII database driver private structure.
+  @param  StringPackage          HII string package instance.
+  @param  StringId               The string's id, which is unique within
+                                 PackageList.
+  @param  String                 Points to the new null-terminated string.
+  @param  StringFontInfo         Points to the input font info.
+
+  @retval EFI_SUCCESS            The string was updated successfully.
+  @retval EFI_NOT_FOUND          The string specified by StringId is not in the
+                                 database.
+  @retval EFI_INVALID_PARAMETER  The String or Language was NULL.
+  @retval EFI_INVALID_PARAMETER  The specified StringFontInfo does not exist in
+                                 current database.
+  @retval EFI_OUT_OF_RESOURCES   The system is out of resources to accomplish the
+                                 task.
+
+**/
+EFI_STATUS
+SetStringWorker (
+  IN  HII_DATABASE_PRIVATE_DATA       *Private,
+  IN OUT HII_STRING_PACKAGE_INSTANCE  *StringPackage,
+  IN  EFI_STRING_ID                   StringId,
+  IN  EFI_STRING                      String,
+  IN  EFI_FONT_INFO                   *StringFontInfo OPTIONAL
+  )
+{
+  UINT8                                *StringTextPtr;
+  UINT8                                BlockType;
+  UINT8                                *StringBlockAddr;
+  UINTN                                StringTextOffset;
+  EFI_STATUS                           Status;
+  UINT8                                *Block;
+  UINT8                                *BlockPtr;
+  UINTN                                BlockSize;
+  UINTN                                OldBlockSize;
+  HII_FONT_INFO                        *LocalFont;
+  HII_GLOBAL_FONT_INFO                 *GlobalFont;
+  BOOLEAN                              Referred;
+  EFI_HII_SIBT_EXT2_BLOCK              Ext2;
+  UINTN                                StringSize;
+  UINTN                                TmpSize;
+  EFI_STRING_ID                        StartStringId;
+
+  StartStringId = 0;
+  ASSERT (Private != NULL && StringPackage != NULL && String != NULL);
+  ASSERT (Private->Signature == HII_DATABASE_PRIVATE_DATA_SIGNATURE);
+  //
+  // Find the specified string block
+  //
+  Status = FindStringBlock (
+             Private,
+             StringPackage,
+             StringId,
+             &BlockType,
+             &StringBlockAddr,
+             &StringTextOffset,
+             NULL,
+             &StartStringId
+             );
+  if (EFI_ERROR (Status) && (BlockType == EFI_HII_SIBT_SKIP1 || BlockType == EFI_HII_SIBT_SKIP2)) {
+    Status = InsertLackStringBlock(StringPackage, 
+                          StartStringId, 
+                          StringId, 
+                          &BlockType,
+                          &StringBlockAddr,
+                          (BOOLEAN)(StringFontInfo != NULL)
+                          );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+    if (StringFontInfo != NULL) {
+      StringTextOffset = sizeof (EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK) - sizeof (CHAR16);
+    } else {
+      StringTextOffset = sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK) - sizeof (CHAR16);
+    }
+  }
+
+  LocalFont  = NULL;
+  GlobalFont = NULL;
+  Referred   = FALSE;
+
+  //
+  // The input StringFontInfo should exist in current database if specified.
+  //
+  if (StringFontInfo != NULL) {
+    if (!IsFontInfoExisted (Private, StringFontInfo, NULL, NULL, &GlobalFont)) {
+      return EFI_INVALID_PARAMETER;
+    } else {
+      Referred = ReferFontInfoLocally (
+                   Private, 
+                   StringPackage, 
+                   StringPackage->FontId, 
+                   FALSE, 
+                   GlobalFont, 
+                   &LocalFont
+                   );
+      if (!Referred) {
+        StringPackage->FontId++;
+      }
+    }
+    //
+    // Update the FontId of the specified string block to input font info.
+    //
+    switch (BlockType) {
+    case EFI_HII_SIBT_STRING_SCSU_FONT:  
+    case EFI_HII_SIBT_STRINGS_SCSU_FONT:
+    case EFI_HII_SIBT_STRING_UCS2_FONT:
+    case EFI_HII_SIBT_STRINGS_UCS2_FONT:
+      *(StringBlockAddr + sizeof (EFI_HII_STRING_BLOCK)) = LocalFont->FontId;
+      break;
+    default:
+      //
+      // When modify the font info of these blocks, the block type should be updated
+      // to contain font info thus the whole structure should be revised.
+      // It is recommended to use tool to modify the block type not in the code.
+      //      
+      return EFI_UNSUPPORTED;
+    }
+  }
+
+  OldBlockSize = StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+
+  //
+  // Set the string text and font.
+  //
+  StringTextPtr = StringBlockAddr + StringTextOffset;
+  switch (BlockType) {
+  case EFI_HII_SIBT_STRING_SCSU:
+  case EFI_HII_SIBT_STRING_SCSU_FONT:
+  case EFI_HII_SIBT_STRINGS_SCSU:
+  case EFI_HII_SIBT_STRINGS_SCSU_FONT:
+    BlockSize = OldBlockSize + StrLen (String);
+    BlockSize -= AsciiStrSize ((CHAR8 *) StringTextPtr);
+    Block = AllocateZeroPool (BlockSize);
+    if (Block == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    CopyMem (Block, StringPackage->StringBlock, StringTextPtr - StringPackage->StringBlock);
+    BlockPtr = Block + (StringTextPtr - StringPackage->StringBlock);
+
+    while (*String != 0) {
+      *BlockPtr++ = (CHAR8) *String++;
+    }
+    *BlockPtr++ = 0;
+
+    
+    TmpSize = OldBlockSize - (StringTextPtr - StringPackage->StringBlock) - AsciiStrSize ((CHAR8 *) StringTextPtr);
+    CopyMem (
+      BlockPtr,
+      StringTextPtr + AsciiStrSize ((CHAR8 *)StringTextPtr),
+      TmpSize
+      );
+
+    FreePool (StringPackage->StringBlock);
+    StringPackage->StringBlock = Block;
+    StringPackage->StringPkgHdr->Header.Length += (UINT32) (BlockSize - OldBlockSize);
+    break;
+
+  case EFI_HII_SIBT_STRING_UCS2:
+  case EFI_HII_SIBT_STRING_UCS2_FONT:
+  case EFI_HII_SIBT_STRINGS_UCS2:
+  case EFI_HII_SIBT_STRINGS_UCS2_FONT:
+    //
+    // Use StrSize to store the size of the specified string, including the NULL
+    // terminator.
+    //
+    GetUnicodeStringTextOrSize (NULL, StringTextPtr, &StringSize);
+
+    BlockSize = OldBlockSize + StrSize (String) - StringSize;
+    Block = AllocateZeroPool (BlockSize);
+    if (Block == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    CopyMem (Block, StringPackage->StringBlock, StringTextPtr - StringPackage->StringBlock);
+    BlockPtr = Block + (StringTextPtr - StringPackage->StringBlock);
+
+    CopyMem (BlockPtr, String, StrSize (String));
+    BlockPtr += StrSize (String);
+
+    CopyMem (
+      BlockPtr,
+      StringTextPtr + StringSize,
+      OldBlockSize - (StringTextPtr - StringPackage->StringBlock) - StringSize
+      );
+
+    FreePool (StringPackage->StringBlock);
+    StringPackage->StringBlock = Block;
+    StringPackage->StringPkgHdr->Header.Length += (UINT32) (BlockSize - OldBlockSize);
+    break;
+
+  default:
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Insert a new EFI_HII_SIBT_FONT_BLOCK to the header of string block, if incoming
+  // StringFontInfo does not exist in current string package.
+  //
+  // This new block does not impact on the value of StringId.
+  //
+  //
+  if (StringFontInfo == NULL || Referred) {
+    return EFI_SUCCESS;
+  }
+
+  OldBlockSize = StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+  BlockSize = OldBlockSize + sizeof (EFI_HII_SIBT_FONT_BLOCK) - sizeof (CHAR16) +
+              StrSize (GlobalFont->FontInfo->FontName);
+
+  Block = AllocateZeroPool (BlockSize);
+  if (Block == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  BlockPtr = Block;
+  Ext2.Header.BlockType = EFI_HII_SIBT_EXT2;
+  Ext2.BlockType2       = EFI_HII_SIBT_FONT;
+  Ext2.Length           = (UINT16) (BlockSize - OldBlockSize);
+  CopyMem (BlockPtr, &Ext2, sizeof (EFI_HII_SIBT_EXT2_BLOCK));
+  BlockPtr += sizeof (EFI_HII_SIBT_EXT2_BLOCK);
+
+  *BlockPtr = LocalFont->FontId;
+  BlockPtr += sizeof (UINT8);
+  CopyMem (BlockPtr, &GlobalFont->FontInfo->FontSize, sizeof (UINT16));
+  BlockPtr += sizeof (UINT16);
+  CopyMem (BlockPtr, &GlobalFont->FontInfo->FontStyle, sizeof (UINT32));
+  BlockPtr += sizeof (UINT32);
+  CopyMem (
+    BlockPtr,
+    GlobalFont->FontInfo->FontName,
+    StrSize (GlobalFont->FontInfo->FontName)
+    );
+  BlockPtr += StrSize (GlobalFont->FontInfo->FontName);
+
+  CopyMem (BlockPtr, StringPackage->StringBlock, OldBlockSize);
+
+  FreePool (StringPackage->StringBlock);
+  StringPackage->StringBlock = Block;
+  StringPackage->StringPkgHdr->Header.Length += Ext2.Length;
+
+  return EFI_SUCCESS;
+
+}
+
+
+/**
+  This function adds the string String to the group of strings owned by PackageList, with the
+  specified font information StringFontInfo and returns a new string id. 
+  The new string identifier is guaranteed to be unique within the package list. 
+  That new string identifier is reserved for all languages in the package list. 
+
+
+  @param  This                   A pointer to the EFI_HII_STRING_PROTOCOL instance.
+  @param  PackageList            Handle of the package list where this string will
+                                 be added.
+  @param  StringId               On return, contains the new strings id, which is
+                                 unique within PackageList.
+  @param  Language               Points to the language for the new string.
+  @param  LanguageName           Points to the printable language name to associate
+                                 with the passed in  Language field.If LanguageName
+                                 is not NULL and the string package header's
+                                 LanguageName  associated with a given Language is
+                                 not zero, the LanguageName being passed  in will
+                                 be ignored.
+  @param  String                 Points to the new null-terminated string.
+  @param  StringFontInfo         Points to the new string's font information or
+                                 NULL if the string should have the default system
+                                 font, size and style.
+
+  @retval EFI_SUCCESS            The new string was added successfully.
+  @retval EFI_NOT_FOUND          The specified PackageList could not be found in
+                                 database.
+  @retval EFI_OUT_OF_RESOURCES   Could not add the string due to lack of resources.
+  @retval EFI_INVALID_PARAMETER  String is NULL or StringId is NULL or Language is
+                                 NULL.
+  @retval EFI_INVALID_PARAMETER  The specified StringFontInfo does not exist in
+                                 current database.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiNewString (
+  IN  CONST EFI_HII_STRING_PROTOCOL   *This,
+  IN  EFI_HII_HANDLE                  PackageList,
+  OUT EFI_STRING_ID                   *StringId,
+  IN  CONST CHAR8                     *Language,
+  IN  CONST CHAR16                    *LanguageName, OPTIONAL
+  IN  CONST EFI_STRING                String,
+  IN  CONST EFI_FONT_INFO             *StringFontInfo OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_STRING_PACKAGE_INSTANCE         *StringPackage;
+  UINT32                              HeaderSize;
+  UINT32                              BlockSize;
+  UINT32                              OldBlockSize;
+  UINT8                               *StringBlock;
+  UINT8                               *BlockPtr;
+  UINT32                              Ucs2BlockSize;
+  UINT32                              FontBlockSize;
+  UINT32                              Ucs2FontBlockSize;
+  EFI_HII_SIBT_EXT2_BLOCK             Ext2;
+  HII_FONT_INFO                       *LocalFont;
+  HII_GLOBAL_FONT_INFO                *GlobalFont;
+  EFI_STRING_ID                       NewStringId;
+  EFI_STRING_ID                       NextStringId;
+  EFI_STRING_ID                       Index;
+  HII_STRING_PACKAGE_INSTANCE         *MatchStringPackage;
+  BOOLEAN                             NewStringPackageCreated;
+
+
+  if (This == NULL || String == NULL || StringId == NULL || Language == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private    = HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  GlobalFont = NULL;
+
+  //
+  // If StringFontInfo specify a paritcular font, it should exist in current database.
+  //
+  if (StringFontInfo != NULL) {
+    if (!IsFontInfoExisted (Private, (EFI_FONT_INFO *) StringFontInfo, NULL, NULL, &GlobalFont)) {
+      return EFI_INVALID_PARAMETER;
+    }
+  }
+
+  //
+  // Get the matching package list.
+  //
+  PackageListNode = NULL;
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = DatabaseRecord->PackageList;
+      break;
+    }
+  }
+  if (PackageListNode == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  Status = EFI_SUCCESS;
+  NewStringPackageCreated = FALSE;
+  NewStringId   = 0;
+  NextStringId  = 0;
+  StringPackage = NULL;
+  MatchStringPackage = NULL;
+  for (Link = PackageListNode->StringPkgHdr.ForwardLink;
+       Link != &PackageListNode->StringPkgHdr;
+       Link = Link->ForwardLink
+      ) {
+    StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    //
+    // Create a string block and corresponding font block if exists, then append them
+    // to the end of the string package.
+    //
+    Status = FindStringBlock (
+               Private,
+               StringPackage,
+               0,
+               NULL,
+               NULL,
+               NULL,
+               &NextStringId,
+               NULL
+               );
+    if (EFI_ERROR (Status)) {
+      goto Done;
+    }
+    //
+    // Make sure that new StringId is same in all String Packages for the different language.
+    //
+    if (NewStringId != 0 && NewStringId != NextStringId) {
+      ASSERT (FALSE);
+      Status = EFI_INVALID_PARAMETER;
+      goto Done;
+    }
+    NewStringId = NextStringId;
+    //
+    // Get the matched string package with language.
+    //
+    if (HiiCompareLanguage (StringPackage->StringPkgHdr->Language, (CHAR8 *) Language)) {
+      MatchStringPackage = StringPackage;
+    } else {
+      OldBlockSize = StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+      //
+      // Create a blank EFI_HII_SIBT_STRING_UCS2_BLOCK to reserve new string ID.
+      //
+      Ucs2BlockSize = (UINT32) sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK);
+
+      StringBlock = (UINT8 *) AllocateZeroPool (OldBlockSize + Ucs2BlockSize);
+      if (StringBlock == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      //
+      // Copy original string blocks, except the EFI_HII_SIBT_END.
+      //
+      CopyMem (StringBlock, StringPackage->StringBlock, OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK));
+      //
+      // Create a blank EFI_HII_SIBT_STRING_UCS2 block
+      //
+      BlockPtr  = StringBlock + OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK);
+      *BlockPtr = EFI_HII_SIBT_STRING_UCS2;
+      BlockPtr  += sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK);
+
+      //
+      // Append a EFI_HII_SIBT_END block to the end.
+      //
+      *BlockPtr = EFI_HII_SIBT_END;
+      FreePool (StringPackage->StringBlock);
+      StringPackage->StringBlock = StringBlock;
+      StringPackage->StringPkgHdr->Header.Length += Ucs2BlockSize;
+      PackageListNode->PackageListHdr.PackageLength += Ucs2BlockSize;
+    }
+  }
+  if (NewStringId == 0) {
+    //
+    // No string package is found.
+    // Create new string package. StringId 1 is reserved for Language Name string.
+    //
+    *StringId = 2;
+  } else {
+    //
+    // Set new StringId
+    //
+    *StringId = (EFI_STRING_ID) (NewStringId + 1);
+  }
+
+  if (MatchStringPackage != NULL) {
+    StringPackage = MatchStringPackage;
+  } else {
+    //
+    // LanguageName is required to create a new string package.
+    //
+    if (LanguageName == NULL) {
+      Status = EFI_INVALID_PARAMETER;
+      goto Done;
+    }
+
+    StringPackage = AllocateZeroPool (sizeof (HII_STRING_PACKAGE_INSTANCE));
+    if (StringPackage == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+
+    StringPackage->Signature   = HII_STRING_PACKAGE_SIGNATURE;
+    StringPackage->MaxStringId = *StringId;
+    StringPackage->FontId      = 0;
+    InitializeListHead (&StringPackage->FontInfoList);
+
+    //
+    // Fill in the string package header
+    //
+    HeaderSize = (UINT32) (AsciiStrSize ((CHAR8 *) Language) - 1 + sizeof (EFI_HII_STRING_PACKAGE_HDR));
+    StringPackage->StringPkgHdr = AllocateZeroPool (HeaderSize);
+    if (StringPackage->StringPkgHdr == NULL) {
+      FreePool (StringPackage);
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+    StringPackage->StringPkgHdr->Header.Type      = EFI_HII_PACKAGE_STRINGS;
+    StringPackage->StringPkgHdr->HdrSize          = HeaderSize;
+    StringPackage->StringPkgHdr->StringInfoOffset = HeaderSize;
+    CopyMem (StringPackage->StringPkgHdr->LanguageWindow, mLanguageWindow, 16 * sizeof (CHAR16));
+    StringPackage->StringPkgHdr->LanguageName     = 1;
+    AsciiStrCpy (StringPackage->StringPkgHdr->Language, (CHAR8 *) Language);
+
+    //
+    // Calculate the length of the string blocks, including string block to record
+    // printable language full name and EFI_HII_SIBT_END_BLOCK.
+    //
+    Ucs2BlockSize = (UINT32) (StrSize ((CHAR16 *) LanguageName) + 
+                              (*StringId - 1) * sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK) - sizeof (CHAR16));
+
+    BlockSize     = Ucs2BlockSize + sizeof (EFI_HII_SIBT_END_BLOCK);
+    StringPackage->StringBlock = (UINT8 *) AllocateZeroPool (BlockSize);
+    if (StringPackage->StringBlock == NULL) {
+      FreePool (StringPackage->StringPkgHdr);
+      FreePool (StringPackage);
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+
+    //
+    // Insert the string block of printable language full name
+    //
+    BlockPtr  = StringPackage->StringBlock;
+    *BlockPtr = EFI_HII_SIBT_STRING_UCS2;
+    BlockPtr  += sizeof (EFI_HII_STRING_BLOCK);
+    CopyMem (BlockPtr, (EFI_STRING) LanguageName, StrSize ((EFI_STRING) LanguageName));
+    BlockPtr += StrSize ((EFI_STRING) LanguageName);
+    for (Index = 2; Index <= *StringId - 1; Index ++) {
+      *BlockPtr = EFI_HII_SIBT_STRING_UCS2;
+      BlockPtr += sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK);
+    }
+    //
+    // Insert the end block
+    //
+    *BlockPtr = EFI_HII_SIBT_END;
+
+    //
+    // Append this string package node to string package array in this package list.
+    //
+    StringPackage->StringPkgHdr->Header.Length    = HeaderSize + BlockSize;
+    PackageListNode->PackageListHdr.PackageLength += StringPackage->StringPkgHdr->Header.Length;
+    InsertTailList (&PackageListNode->StringPkgHdr, &StringPackage->StringEntry);
+    NewStringPackageCreated = TRUE;
+  }
+
+  OldBlockSize = StringPackage->StringPkgHdr->Header.Length - StringPackage->StringPkgHdr->HdrSize;
+
+  if (StringFontInfo == NULL) {
+    //
+    // Create a EFI_HII_SIBT_STRING_UCS2_BLOCK since font info is not specified.
+    //
+    Ucs2BlockSize = (UINT32) (StrSize (String) + sizeof (EFI_HII_SIBT_STRING_UCS2_BLOCK)
+                              - sizeof (CHAR16));
+
+    StringBlock = (UINT8 *) AllocateZeroPool (OldBlockSize + Ucs2BlockSize);
+    if (StringBlock == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto Done;
+    }
+    //
+    // Copy original string blocks, except the EFI_HII_SIBT_END.
+    //
+    CopyMem (StringBlock, StringPackage->StringBlock, OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK));
+    //
+    // Create a EFI_HII_SIBT_STRING_UCS2 block
+    //
+    BlockPtr  = StringBlock + OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK);
+    *BlockPtr = EFI_HII_SIBT_STRING_UCS2;
+    BlockPtr  += sizeof (EFI_HII_STRING_BLOCK);
+    CopyMem (BlockPtr, (EFI_STRING) String, StrSize ((EFI_STRING) String));
+    BlockPtr += StrSize ((EFI_STRING) String);
+
+    //
+    // Append a EFI_HII_SIBT_END block to the end.
+    //
+    *BlockPtr = EFI_HII_SIBT_END;
+    FreePool (StringPackage->StringBlock);
+    StringPackage->StringBlock = StringBlock;
+    StringPackage->StringPkgHdr->Header.Length += Ucs2BlockSize;
+    PackageListNode->PackageListHdr.PackageLength += Ucs2BlockSize;
+
+  } else {
+    //
+    // StringFontInfo is specified here. If there is a EFI_HII_SIBT_FONT_BLOCK
+    // which refers to this font info, create a EFI_HII_SIBT_STRING_UCS2_FONT block
+    // only. Otherwise create a EFI_HII_SIBT_FONT block with a EFI_HII_SIBT_STRING
+    // _UCS2_FONT block.
+    //
+    Ucs2FontBlockSize = (UINT32) (StrSize (String) + sizeof (EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK) -
+                                  sizeof (CHAR16));
+    if (ReferFontInfoLocally (Private, StringPackage, StringPackage->FontId, FALSE, GlobalFont, &LocalFont)) {
+      //
+      // Create a EFI_HII_SIBT_STRING_UCS2_FONT block only.
+      //
+      StringBlock = (UINT8 *) AllocateZeroPool (OldBlockSize + Ucs2FontBlockSize);
+      if (StringBlock == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      //
+      // Copy original string blocks, except the EFI_HII_SIBT_END.
+      //
+      CopyMem (StringBlock, StringPackage->StringBlock, OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK));
+      //
+      // Create a EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK
+      //
+      BlockPtr  = StringBlock + OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK);
+      *BlockPtr = EFI_HII_SIBT_STRING_UCS2_FONT;
+      BlockPtr  += sizeof (EFI_HII_STRING_BLOCK);
+      *BlockPtr = LocalFont->FontId;
+      BlockPtr  += sizeof (UINT8);
+      CopyMem (BlockPtr, (EFI_STRING) String, StrSize ((EFI_STRING) String));
+      BlockPtr += StrSize ((EFI_STRING) String);
+
+      //
+      // Append a EFI_HII_SIBT_END block to the end.
+      //
+      *BlockPtr = EFI_HII_SIBT_END;
+      FreePool (StringPackage->StringBlock);
+      StringPackage->StringBlock = StringBlock;
+      StringPackage->StringPkgHdr->Header.Length += Ucs2FontBlockSize;
+      PackageListNode->PackageListHdr.PackageLength += Ucs2FontBlockSize;
+
+    } else {
+      //
+      // EFI_HII_SIBT_FONT_BLOCK does not exist in current string package, so
+      // create a EFI_HII_SIBT_FONT block to record the font info, then generate
+      // a EFI_HII_SIBT_STRING_UCS2_FONT block to record the incoming string.
+      //
+      FontBlockSize = (UINT32) (StrSize (((EFI_FONT_INFO *) StringFontInfo)->FontName) +
+                                sizeof (EFI_HII_SIBT_FONT_BLOCK) - sizeof (CHAR16));
+      StringBlock = (UINT8 *) AllocateZeroPool (OldBlockSize + FontBlockSize + Ucs2FontBlockSize);
+      if (StringBlock == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        goto Done;
+      }
+      //
+      // Copy original string blocks, except the EFI_HII_SIBT_END.
+      //
+      CopyMem (StringBlock, StringPackage->StringBlock, OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK));
+
+      //
+      // Create a EFI_HII_SIBT_FONT block firstly and then backup its info in string
+      // package instance for future reference.
+      //
+      BlockPtr = StringBlock + OldBlockSize - sizeof (EFI_HII_SIBT_END_BLOCK);
+
+      Ext2.Header.BlockType = EFI_HII_SIBT_EXT2;
+      Ext2.BlockType2       = EFI_HII_SIBT_FONT;
+      Ext2.Length           = (UINT16) FontBlockSize;
+      CopyMem (BlockPtr, &Ext2, sizeof (EFI_HII_SIBT_EXT2_BLOCK));
+      BlockPtr += sizeof (EFI_HII_SIBT_EXT2_BLOCK);
+
+      *BlockPtr = LocalFont->FontId;
+      BlockPtr += sizeof (UINT8);
+      CopyMem (BlockPtr, &((EFI_FONT_INFO *) StringFontInfo)->FontSize, sizeof (UINT16));
+      BlockPtr += sizeof (UINT16);
+      CopyMem (BlockPtr, &((EFI_FONT_INFO *) StringFontInfo)->FontStyle, sizeof (EFI_HII_FONT_STYLE));
+      BlockPtr += sizeof (EFI_HII_FONT_STYLE);
+      CopyMem (
+        BlockPtr,
+        &((EFI_FONT_INFO *) StringFontInfo)->FontName,
+        StrSize (((EFI_FONT_INFO *) StringFontInfo)->FontName)
+        );
+      BlockPtr += StrSize (((EFI_FONT_INFO *) StringFontInfo)->FontName);
+      //
+      // Create a EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK
+      //
+      *BlockPtr = EFI_HII_SIBT_STRING_UCS2_FONT;
+      BlockPtr  += sizeof (EFI_HII_STRING_BLOCK);
+      *BlockPtr = LocalFont->FontId;
+      BlockPtr  += sizeof (UINT8);
+      CopyMem (BlockPtr, (EFI_STRING) String, StrSize ((EFI_STRING) String));
+      BlockPtr += StrSize ((EFI_STRING) String);
+
+      //
+      // Append a EFI_HII_SIBT_END block to the end.
+      //
+      *BlockPtr = EFI_HII_SIBT_END;
+      FreePool (StringPackage->StringBlock);
+      StringPackage->StringBlock = StringBlock;
+      StringPackage->StringPkgHdr->Header.Length += FontBlockSize + Ucs2FontBlockSize;
+      PackageListNode->PackageListHdr.PackageLength += FontBlockSize + Ucs2FontBlockSize;
+
+      //
+      // Increase the FontId to make it unique since we already add 
+      // a EFI_HII_SIBT_FONT block to this string package.
+      //
+      StringPackage->FontId++;
+    }
+  }
+
+Done:
+  if (!EFI_ERROR (Status) && NewStringPackageCreated) {
+    //
+    // Trigger any registered notification function for new string package
+    //
+    Status = InvokeRegisteredFunction (
+      Private,
+      EFI_HII_DATABASE_NOTIFY_NEW_PACK,
+      (VOID *) StringPackage,
+      EFI_HII_PACKAGE_STRINGS,
+      PackageList
+      );
+  }
+
+  if (!EFI_ERROR (Status)) {
+    //
+    // Update MaxString Id to new StringId
+    //
+    for (Link = PackageListNode->StringPkgHdr.ForwardLink;
+      Link != &PackageListNode->StringPkgHdr;
+      Link = Link->ForwardLink
+      ) {
+        StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+        StringPackage->MaxStringId = *StringId;
+    }
+  } else if (NewStringPackageCreated) {
+    //
+    // Free the allocated new string Package when new string can't be added.
+    //
+    RemoveEntryList (&StringPackage->StringEntry);
+    FreePool (StringPackage->StringBlock);
+    FreePool (StringPackage->StringPkgHdr);
+    FreePool (StringPackage);
+  }
+
+  return Status;
+}
+
+
+/**
+  This function retrieves the string specified by StringId which is associated
+  with the specified PackageList in the language Language and copies it into
+  the buffer specified by String.
+
+  @param  This                   A pointer to the EFI_HII_STRING_PROTOCOL instance.
+  @param  Language               Points to the language for the retrieved string.
+  @param  PackageList            The package list in the HII database to search for
+                                 the  specified string.
+  @param  StringId               The string's id, which is unique within
+                                 PackageList.
+  @param  String                 Points to the new null-terminated string.
+  @param  StringSize             On entry, points to the size of the buffer pointed
+                                 to by  String, in bytes. On return, points to the
+                                 length of the string, in bytes.
+  @param  StringFontInfo         If not NULL, points to the string's font
+                                 information.  It's caller's responsibility to free
+                                 this buffer.
+
+  @retval EFI_SUCCESS            The string was returned successfully.
+  @retval EFI_NOT_FOUND          The string specified by StringId is not available.
+  @retval EFI_NOT_FOUND          The string specified by StringId is available but
+                                                not in the specified language.
+                                                The specified PackageList is not in the database.
+  @retval EFI_INVALID_LANGUAGE   - The string specified by StringId is available but
+  @retval EFI_BUFFER_TOO_SMALL   The buffer specified by StringSize is too small to
+                                  hold the string.
+  @retval EFI_INVALID_PARAMETER  The String or Language or StringSize was NULL.
+  @retval EFI_OUT_OF_RESOURCES   There were insufficient resources to complete the
+                                 request.
+
+**/
+EFI_STATUS
+EFIAPI
+IntHiiGetString (
+  IN  CONST EFI_HII_STRING_PROTOCOL   *This,
+  IN  CONST CHAR8                     *Language,
+  IN  EFI_HII_HANDLE                  PackageList,
+  IN  EFI_STRING_ID                   StringId,
+  OUT EFI_STRING                      String,
+  IN  OUT UINTN                       *StringSize,
+  OUT EFI_FONT_INFO                   **StringFontInfo OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_STRING_PACKAGE_INSTANCE         *StringPackage;
+
+  if (This == NULL || Language == NULL || StringId < 1 || StringSize == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (String == NULL && *StringSize != 0) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  PackageListNode = NULL;
+
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = DatabaseRecord->PackageList;
+      break;
+    }
+  }
+
+  if (PackageListNode != NULL) {
+    //
+    // First search: to match the StringId in the specified language.
+    //
+    for (Link =  PackageListNode->StringPkgHdr.ForwardLink;
+         Link != &PackageListNode->StringPkgHdr;
+         Link =  Link->ForwardLink
+        ) {
+        StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+        if (HiiCompareLanguage (StringPackage->StringPkgHdr->Language, (CHAR8 *) Language)) {
+          Status = GetStringWorker (Private, StringPackage, StringId, String, StringSize, StringFontInfo);
+          if (Status != EFI_NOT_FOUND) {
+            return Status;
+          }
+        }
+      }
+      //
+      // Second search: to match the StringId in other available languages if exist.
+      //
+      for (Link =  PackageListNode->StringPkgHdr.ForwardLink; 
+           Link != &PackageListNode->StringPkgHdr;
+           Link =  Link->ForwardLink
+          ) {
+      StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);      
+      Status = GetStringWorker (Private, StringPackage, StringId, NULL, NULL, NULL);
+      if (!EFI_ERROR (Status)) {
+        return EFI_INVALID_LANGUAGE;
+      }
+    }    
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+
+/**
+  This function updates the string specified by StringId in the specified PackageList to the text
+  specified by String and, optionally, the font information specified by StringFontInfo.
+
+  @param  This                   A pointer to the EFI_HII_STRING_PROTOCOL instance.
+  @param  PackageList            The package list containing the strings.
+  @param  StringId               The string's id, which is unique within
+                                 PackageList.
+  @param  Language               Points to the language for the updated string.
+  @param  String                 Points to the new null-terminated string.
+  @param  StringFontInfo         Points to the string's font information or NULL if
+                                 the  string font information is not changed.
+
+  @retval EFI_SUCCESS            The string was updated successfully.
+  @retval EFI_NOT_FOUND          The string specified by StringId is not in the
+                                 database.
+  @retval EFI_INVALID_PARAMETER  The String or Language was NULL.
+  @retval EFI_INVALID_PARAMETER  The specified StringFontInfo does not exist in
+                                 current database.
+  @retval EFI_OUT_OF_RESOURCES   The system is out of resources to accomplish the
+                                 task.
+
+**/
+EFI_STATUS
+EFIAPI
+IntHiiSetString (
+  IN CONST EFI_HII_STRING_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                   PackageList,
+  IN EFI_STRING_ID                    StringId,
+  IN CONST CHAR8                      *Language,
+  IN CONST EFI_STRING                 String,
+  IN CONST EFI_FONT_INFO              *StringFontInfo OPTIONAL
+  )
+{
+  EFI_STATUS                          Status;
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_STRING_PACKAGE_INSTANCE         *StringPackage;
+  UINT32                              OldPackageLen;
+
+  if (This == NULL || Language == NULL || StringId < 1 || String == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+  PackageListNode = NULL;
+
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    DatabaseRecord = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (DatabaseRecord->PackageList);
+    }
+  }
+
+  if (PackageListNode != NULL) {
+    for (Link =  PackageListNode->StringPkgHdr.ForwardLink;
+         Link != &PackageListNode->StringPkgHdr;
+         Link =  Link->ForwardLink
+        ) {
+      StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+      if (HiiCompareLanguage (StringPackage->StringPkgHdr->Language, (CHAR8 *) Language)) {
+        OldPackageLen = StringPackage->StringPkgHdr->Header.Length;
+        Status = SetStringWorker (
+                   Private,
+                   StringPackage,
+                   StringId,
+                   (EFI_STRING) String,
+                   (EFI_FONT_INFO *) StringFontInfo
+                   );
+        if (EFI_ERROR (Status)) {
+          return Status;
+        }
+        PackageListNode->PackageListHdr.PackageLength += StringPackage->StringPkgHdr->Header.Length - OldPackageLen;
+        return EFI_SUCCESS;
+      }
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+
+
+/**
+  This function returns the list of supported languages, in the format specified
+  in Appendix M of UEFI 2.1 spec.
+
+  @param  This                   A pointer to the EFI_HII_STRING_PROTOCOL instance.
+  @param  PackageList            The package list to examine.
+  @param  Languages              Points to the buffer to hold the returned
+                                 null-terminated ASCII string.
+  @param  LanguagesSize          On entry, points to the size of the buffer pointed
+                                 to by  Languages, in bytes. On  return, points to
+                                 the length of Languages, in bytes.
+
+  @retval EFI_SUCCESS            The languages were returned successfully.
+  @retval EFI_INVALID_PARAMETER  The Languages or LanguagesSize was NULL.
+  @retval EFI_BUFFER_TOO_SMALL   The LanguagesSize is too small to hold the list of
+                                  supported languages. LanguageSize is updated to
+                                 contain the required size.
+  @retval EFI_NOT_FOUND          Could not find string package in specified
+                                 packagelist.
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetLanguages (
+  IN CONST EFI_HII_STRING_PROTOCOL    *This,
+  IN EFI_HII_HANDLE                   PackageList,
+  IN OUT CHAR8                        *Languages,
+  IN OUT UINTN                        *LanguagesSize
+  )
+{
+  LIST_ENTRY                          *Link;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_STRING_PACKAGE_INSTANCE         *StringPackage;
+  UINTN                               ResultSize;
+
+  if (This == NULL || Languages == NULL || LanguagesSize == NULL || PackageList == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private = HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  PackageListNode = NULL;
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    DatabaseRecord  = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = DatabaseRecord->PackageList;
+      break;
+    }
+  }
+  if (PackageListNode == NULL) {
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Search the languages in the specified packagelist.
+  //
+  ResultSize = 0;
+  for (Link = PackageListNode->StringPkgHdr.ForwardLink;
+       Link != &PackageListNode->StringPkgHdr;
+       Link = Link->ForwardLink
+      ) {
+    StringPackage = CR (Link, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    ResultSize += AsciiStrSize (StringPackage->StringPkgHdr->Language);
+    if (ResultSize <= *LanguagesSize) {
+      AsciiStrCpy (Languages, StringPackage->StringPkgHdr->Language);
+      Languages += AsciiStrSize (StringPackage->StringPkgHdr->Language);
+      *(Languages - 1) = L';';
+    }
+  }
+  if (ResultSize == 0) {
+    return EFI_NOT_FOUND;
+  }
+
+  if (*LanguagesSize < ResultSize) {
+    *LanguagesSize = ResultSize;
+    return EFI_BUFFER_TOO_SMALL;
+  }
+
+  *(Languages - 1) = 0;
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Each string package has associated with it a single primary language and zero
+  or more secondary languages. This routine returns the secondary languages
+  associated with a package list.
+
+  @param  This                   A pointer to the EFI_HII_STRING_PROTOCOL instance.
+  @param  PackageList            The package list to examine.
+  @param  PrimaryLanguage        Points to the null-terminated ASCII string that specifies
+                                 the primary language. Languages are specified in the
+                                 format specified in Appendix M of the UEFI 2.0 specification.
+  @param  SecondaryLanguages     Points to the buffer to hold the returned null-terminated
+                                 ASCII string that describes the list of
+                                 secondary languages for the specified
+                                 PrimaryLanguage. If there are no secondary
+                                 languages, the function returns successfully, but
+                                 this is set to NULL.
+  @param  SecondaryLanguagesSize On entry, points to the size of the buffer pointed
+                                 to by SecondaryLanguages, in bytes. On return,
+                                 points to the length of SecondaryLanguages in bytes.
+
+  @retval EFI_SUCCESS            Secondary languages were correctly returned.
+  @retval EFI_INVALID_PARAMETER  PrimaryLanguage or SecondaryLanguages or
+                                 SecondaryLanguagesSize was NULL.
+  @retval EFI_BUFFER_TOO_SMALL   The buffer specified by SecondaryLanguagesSize is
+                                 too small to hold the returned information.
+                                 SecondaryLanguageSize is updated to hold the size of
+                                 the buffer required.
+  @retval EFI_INVALID_LANGUAGE   The language specified by PrimaryLanguage is not
+                                 present in the specified package list.
+  @retval EFI_NOT_FOUND          The specified PackageList is not in the Database.                                
+
+**/
+EFI_STATUS
+EFIAPI
+HiiGetSecondaryLanguages (
+  IN CONST EFI_HII_STRING_PROTOCOL   *This,
+  IN EFI_HII_HANDLE                  PackageList,
+  IN CONST CHAR8                     *PrimaryLanguage,
+  IN OUT CHAR8                       *SecondaryLanguages,
+  IN OUT UINTN                       *SecondaryLanguagesSize
+  )
+{
+  LIST_ENTRY                          *Link;
+  LIST_ENTRY                          *Link1;
+  HII_DATABASE_PRIVATE_DATA           *Private;
+  HII_DATABASE_RECORD                 *DatabaseRecord;
+  HII_DATABASE_PACKAGE_LIST_INSTANCE  *PackageListNode;
+  HII_STRING_PACKAGE_INSTANCE         *StringPackage;
+  CHAR8                               *Languages;
+  UINTN                               ResultSize;
+
+  if (This == NULL || PackageList == NULL || PrimaryLanguage == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (SecondaryLanguages == NULL || SecondaryLanguagesSize == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  if (!IsHiiHandleValid (PackageList)) {
+    return EFI_NOT_FOUND;
+  }
+
+  Private    = HII_STRING_DATABASE_PRIVATE_DATA_FROM_THIS (This);
+
+  PackageListNode = NULL;     
+  for (Link = Private->DatabaseList.ForwardLink; Link != &Private->DatabaseList; Link = Link->ForwardLink) {
+    DatabaseRecord  = CR (Link, HII_DATABASE_RECORD, DatabaseEntry, HII_DATABASE_RECORD_SIGNATURE);
+    if (DatabaseRecord->Handle == PackageList) {
+      PackageListNode = (HII_DATABASE_PACKAGE_LIST_INSTANCE *) (DatabaseRecord->PackageList);
+        break;
+      }
+    }
+    if (PackageListNode == NULL) {
+      return EFI_NOT_FOUND;
+    }
+      
+    Languages  = NULL;
+    ResultSize = 0;
+    for (Link1 = PackageListNode->StringPkgHdr.ForwardLink;
+         Link1 != &PackageListNode->StringPkgHdr;
+         Link1 = Link1->ForwardLink
+        ) {
+    StringPackage = CR (Link1, HII_STRING_PACKAGE_INSTANCE, StringEntry, HII_STRING_PACKAGE_SIGNATURE);
+    if (HiiCompareLanguage (StringPackage->StringPkgHdr->Language, (CHAR8 *) PrimaryLanguage)) {
+      Languages = StringPackage->StringPkgHdr->Language;
+      //
+      // Language is a series of ';' terminated strings, first one is primary
+      // language and following with other secondary languages or NULL if no
+      // secondary languages any more.
+      //
+      Languages = AsciiStrStr (Languages, ";");
+      if (Languages == NULL) {
+        break;
+      }
+      Languages++;
+
+      ResultSize = AsciiStrSize (Languages);
+      if (ResultSize <= *SecondaryLanguagesSize) {
+        AsciiStrCpy (SecondaryLanguages, Languages);
+      } else {
+        *SecondaryLanguagesSize = ResultSize;
+        return EFI_BUFFER_TOO_SMALL;
+      }
+
+      return EFI_SUCCESS;
+    }
+  }
+
+  return EFI_INVALID_LANGUAGE;
+}
+
+/**
+  Converts the ascii character of the string from uppercase to lowercase.
+  This is a internal function.
+
+  @param ConfigString  String to be converted
+
+**/
+VOID
+EFIAPI
+AsciiHiiToLower (
+  IN CHAR8  *ConfigString
+  )
+{
+  ASSERT (ConfigString != NULL);
+
+  //
+  // Convert all hex digits in range [A-F] in the configuration header to [a-f]
+  //
+  for (; *ConfigString != '\0'; ConfigString++) {
+    if ( *ConfigString >= 'A' && *ConfigString <= 'Z') {
+      *ConfigString = (CHAR8) (*ConfigString - 'A' + 'a');
+    }
+  }
+}
+
+/**
+  Compare whether two names of languages are identical.
+
+  @param  Language1              Name of language 1 from StringPackage
+  @param  Language2              Name of language 2 to be compared with language 1.
+
+  @retval TRUE                   same
+  @retval FALSE                  not same
+
+**/
+BOOLEAN
+HiiCompareLanguage (
+  IN  CHAR8  *Language1,
+  IN  CHAR8  *Language2
+  )
+{
+  UINTN  Index;
+  UINTN  StrLen;
+  CHAR8  *Lan1;
+  CHAR8  *Lan2;
+
+  //
+  // Convert to lower to compare.
+  //
+  StrLen = AsciiStrSize (Language1);
+  Lan1   = AllocateZeroPool (StrLen);
+  ASSERT (Lan1 != NULL);
+  AsciiStrCpy(Lan1, Language1);
+  AsciiHiiToLower (Lan1);
+
+  StrLen = AsciiStrSize (Language2);
+  Lan2   = AllocateZeroPool (StrLen);
+  ASSERT (Lan2 != NULL);
+  AsciiStrCpy(Lan2, Language2);
+  AsciiHiiToLower (Lan2);
+
+  //
+  // Compare the Primary Language in Language1 to Language2
+  //
+  for (Index = 0; Lan1[Index] != 0 && Lan1[Index] != ';'; Index++) {
+    if (Lan1[Index] != Lan2[Index]) {
+      //
+      // Return FALSE if any characters are different.
+      //
+      return FALSE;
+    }
+  }
+
+  FreePool (Lan1);
+  FreePool (Lan2);
+
+  //
+  // Only return TRUE if Language2[Index] is a Null-terminator which means
+  // the Primary Language in Language1 is the same length as Language2.  If
+  // Language2[Index] is not a Null-terminator, then Language2 is longer than
+  // the Primary Language in Language1, and FALSE must be returned.
+  //
+  return (BOOLEAN) (Language2[Index] == 0);
+}
Index: Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.c	(working copy)
@@ -0,0 +1,130 @@
+/** @file
+  This library retrieves pointers to the UEFI HII Protocol instances in the 
+  library's constructor.  All of the UEFI HII related protocols are optional, 
+  so the consumers of this library class must verify that the global variable 
+  pointers are not NULL before use.   
+
+  Copyright (c) 2006 - 2009, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <Uefi.h>
+#include <Library/UefiLib.h>
+
+#include <Library/UefiHiiServicesLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/DebugLib.h>
+
+#include <Protocol/HiiFont.h>
+#include <Protocol/HiiString.h>
+#include <Protocol/HiiImage.h>
+#include <Protocol/HiiDatabase.h>
+#include <Protocol/HiiConfigRouting.h>
+
+///
+/// Pointer to the UEFI HII Font Protocol
+///
+EFI_HII_FONT_PROTOCOL  *gHiiFont = NULL;
+
+///
+/// Pointer to the UEFI HII String Protocol
+///
+EFI_HII_STRING_PROTOCOL  *gHiiString = NULL;
+
+///
+/// Pointer to the UEFI HII Image Protocol
+///
+EFI_HII_IMAGE_PROTOCOL  *gHiiImage = NULL;
+
+///
+/// Pointer to the UEFI HII Database Protocol
+///
+EFI_HII_DATABASE_PROTOCOL  *gHiiDatabase = NULL;
+
+///
+/// Pointer to the UEFI HII Config Rounting Protocol
+///
+EFI_HII_CONFIG_ROUTING_PROTOCOL  *gHiiConfigRouting = NULL;
+
+EFI_STATUS EFIAPI
+InitializeHiiDatabase(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable);
+
+EFI_STATUS EFIAPI
+InitializeUnicodeCollationEng(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable);
+
+EFI_STATUS EFIAPI
+DevicePathEntryPoint(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable);
+
+/**
+  The constructor function retrieves pointers to the UEFI HII protocol instances
+    
+  The constructor function retrieves pointers to the four UEFI HII protocols from the 
+  handle database.  These include the UEFI HII Font Protocol, the UEFI HII String 
+  Protocol, the UEFI HII Image Protocol, the UEFI HII Database Protocol, and the 
+  UEFI HII Config Routing Protocol.  This function always return EFI_SUCCESS.
+  All of these protocols are optional if the platform does not support configuration
+  and the UEFI HII Image Protocol and the UEFI HII Font Protocol are optional if 
+  the platform does not support a graphical console.  As a result, the consumers
+  of this library much check the protocol pointers againt NULL before using them,
+  or use dependency expressions to guarantee that some of them are present before
+  assuming they are not NULL.
+
+  @param  ImageHandle   The firmware allocated handle for the EFI image.
+  @param  SystemTable   A pointer to the EFI System Table.
+
+  @retval EFI_SUCCESS   The constructor always returns EFI_SUCCESS.
+
+**/
+EFI_STATUS
+EFIAPI
+UefiHiiServicesLibConstructor (
+  IN EFI_HANDLE        ImageHandle,
+  IN EFI_SYSTEM_TABLE  *SystemTable
+  )
+{
+  EFI_STATUS Status;
+
+  //
+  // dmazar: Install Hii protocols
+  //
+  InitializeHiiDatabase(ImageHandle, SystemTable);
+  InitializeUnicodeCollationEng(ImageHandle, SystemTable);
+  DevicePathEntryPoint(ImageHandle, SystemTable);
+  
+  //
+  // Retrieve the pointer to the UEFI HII String Protocol 
+  //
+  Status = gBS->LocateProtocol (&gEfiHiiStringProtocolGuid, NULL, (VOID **) &gHiiString);
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Retrieve the pointer to the UEFI HII Database Protocol 
+  //
+  Status = gBS->LocateProtocol (&gEfiHiiDatabaseProtocolGuid, NULL, (VOID **) &gHiiDatabase);
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Retrieve the pointer to the UEFI HII Config Routing Protocol 
+  //
+  Status = gBS->LocateProtocol (&gEfiHiiConfigRoutingProtocolGuid, NULL, (VOID **) &gHiiConfigRouting);
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Retrieve the pointer to the optional UEFI HII Font Protocol 
+  //
+  gBS->LocateProtocol (&gEfiHiiFontProtocolGuid, NULL, (VOID **) &gHiiFont);
+
+  //
+  // Retrieve the pointer to the optional UEFI HII Image Protocol 
+  //
+  gBS->LocateProtocol (&gEfiHiiImageProtocolGuid, NULL, (VOID **) &gHiiImage);
+  
+  return EFI_SUCCESS;
+}
Index: Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.inf
===================================================================
--- Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.inf	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.inf	(working copy)
@@ -0,0 +1,120 @@
+## @file
+# UEFI HII Services Library implementation.
+# 
+# Copyright (c) 2007 - 2010, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = UefiHiiServicesLib
+  FILE_GUID                      = 894DC1B6-07A3-4a9d-8CDD-333580B3D4B1
+  MODULE_TYPE                    = UEFI_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = UefiHiiServicesLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SAL_DRIVER DXE_SMM_DRIVER UEFI_APPLICATION UEFI_DRIVER 
+
+  CONSTRUCTOR                    = UefiHiiServicesLibConstructor
+
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  UefiHiiServicesLib.c
+#HiiDatabaseDxe
+  HiiDatabaseDxe/HiiDatabaseEntry.c
+  HiiDatabaseDxe/Image.c
+  HiiDatabaseDxe/HiiDatabase.h
+  HiiDatabaseDxe/ConfigRouting.c
+  HiiDatabaseDxe/String.c
+  HiiDatabaseDxe/Database.c
+  HiiDatabaseDxe/Font.c
+#UnicodeCollation
+  UnicodeCollation/EnglishDxe/UnicodeCollationEng.c
+  UnicodeCollation/EnglishDxe/UnicodeCollationEng.h
+#DevicePathDxe
+  DevicePathDxe/DevicePathUtilities.c
+  DevicePathDxe/DevicePathToText.c   ||||gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText
+  DevicePathDxe/DevicePathFromText.c ||||gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText
+  DevicePathDxe/DevicePath.h
+  DevicePathDxe/DevicePath.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+
+[LibraryClasses]
+  UefiBootServicesTableLib
+  DebugLib
+  UefiLib
+  
+[Guids]
+#HiiDatabaseDxe
+  gEfiHiiKeyBoardLayoutGuid  ## SOMETIME_CONSUMES  ## Event
+#DevicePathDxe
+  gEfiVTUTF8Guid         | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiVT100Guid          | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiVT100PlusGuid      | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiPcAnsiGuid         | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiUartDevicePathGuid | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+  gEfiSasDevicePathGuid  | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+
+[Protocols]
+  gEfiHiiFontProtocolGuid
+  gEfiHiiStringProtocolGuid
+  gEfiHiiImageProtocolGuid
+  gEfiHiiDatabaseProtocolGuid
+  gEfiHiiConfigRoutingProtocolGuid
+#HiiDatabaseDxe
+  gEfiHiiConfigAccessProtocolGuid                                       ## CONSUMES
+#UnicodeCollation
+  gEfiUnicodeCollationProtocolGuid  | gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollationSupport  ## PRODUCES
+  gEfiUnicodeCollation2ProtocolGuid | gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollation2Support ## PRODUCES
+#DevicePathDxe
+  gEfiDevicePathProtocolGuid                              # ALWAYS_CONSUMED
+  gEfiDevicePathToTextProtocolGuid                        # ALWAYS_CONSUMED
+  gEfiDevicePathFromTextProtocolGuid | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## PRODUCES
+  gEfiDevicePathUtilitiesProtocolGuid ## PRODUCES
+  gEfiDebugPortProtocolGuid          | gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText OR gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText ## SOMETIMES_CONSUMES ## GUID
+
+[FeaturePcd]
+#HiiDatabaseDxe
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSupportHiiImageProtocol
+#UnicodeCollation
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollationSupport
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollation2Support
+#DevicePathDxe
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText
+
+[Pcd]
+#HiiDatabaseDxe
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultPlatformLang
+
+[Depex.common.DXE_DRIVER]
+  gEfiHiiStringProtocolGuid        AND
+  gEfiHiiDatabaseProtocolGuid      AND
+  gEfiHiiConfigRoutingProtocolGuid
+
+[Depex.common.DXE_RUNTIME_DRIVER]
+  gEfiHiiStringProtocolGuid        AND
+  gEfiHiiDatabaseProtocolGuid      AND
+  gEfiHiiConfigRoutingProtocolGuid
+
+[Depex.common.DXE_SAL_DRIVER]
+  gEfiHiiStringProtocolGuid        AND
+  gEfiHiiDatabaseProtocolGuid      AND
+  gEfiHiiConfigRoutingProtocolGuid
+
+[Depex.common.DXE_SMM_DRIVER]
+  gEfiHiiStringProtocolGuid        AND
+  gEfiHiiDatabaseProtocolGuid      AND
+  gEfiHiiConfigRoutingProtocolGuid
Index: Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/EnglishDxe.inf
===================================================================
--- Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/EnglishDxe.inf	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/EnglishDxe.inf	(working copy)
@@ -0,0 +1,57 @@
+## @file
+#  English module that provides Unicode Collation supports.
+#  
+#  This driver installs Unicode ISO 639-2 Collation and
+#  RFC 4646 Unicode Collation 2 protocols based on feature flags
+#  PcdUnicodeCollationSupport & PcdUnicodeCollation2Support respectively.
+#  It allows code running in the boot services environment to perform lexical
+#  comparison functions on Unicode strings for English languages.
+#  
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#  
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = EnglishDxe
+  FILE_GUID                      = CD3BAFB6-50FB-4fe8-8E4E-AB74D2C1A600
+  MODULE_TYPE                    = UEFI_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = InitializeUnicodeCollationEng
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  UnicodeCollationEng.c
+  UnicodeCollationEng.h
+
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+
+[LibraryClasses]
+  UefiBootServicesTableLib
+  UefiDriverEntryPoint
+  DebugLib
+  PcdLib
+
+[FeaturePcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollationSupport
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollation2Support
+
+[Protocols]
+  gEfiUnicodeCollationProtocolGuid  | gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollationSupport  ## PRODUCES
+  gEfiUnicodeCollation2ProtocolGuid | gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollation2Support ## PRODUCES
+
Index: Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/UnicodeCollationEng.c
===================================================================
--- Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/UnicodeCollationEng.c	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/UnicodeCollationEng.c	(working copy)
@@ -0,0 +1,493 @@
+/** @file
+  Driver to implement English version of Unicode Collation Protocol.
+
+Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include "UnicodeCollationEng.h"
+#include <Library/UefiLib.h>
+
+CHAR8 mEngUpperMap[MAP_TABLE_SIZE];
+CHAR8 mEngLowerMap[MAP_TABLE_SIZE];
+CHAR8 mEngInfoMap[MAP_TABLE_SIZE];
+
+CHAR8 mOtherChars[] = {
+  '0',
+  '1',
+  '2',
+  '3',
+  '4',
+  '5',
+  '6',
+  '7',
+  '8',
+  '9',
+  '\\',
+  '.',
+  '_',
+  '^',
+  '$',
+  '~',
+  '!',
+  '#',
+  '%',
+  '&',
+  '-',
+  '{',
+  '}',
+  '(',
+  ')',
+  '@',
+  '`',
+  '\'',
+  '\0'
+};
+
+EFI_HANDLE  mHandle = NULL;
+
+//
+// EFI Unicode Collation Protocol supporting ISO 639-2 language code
+//
+GLOBAL_REMOVE_IF_UNREFERENCED EFI_UNICODE_COLLATION_PROTOCOL  UnicodeEng = {
+  EngStriColl,
+  EngMetaiMatch,
+  EngStrLwr,
+  EngStrUpr,
+  EngFatToStr,
+  EngStrToFat,
+  "eng"
+};
+
+//
+// EFI Unicode Collation2 Protocol supporting RFC 4646 language code
+//
+GLOBAL_REMOVE_IF_UNREFERENCED EFI_UNICODE_COLLATION_PROTOCOL  Unicode2Eng = {
+  EngStriColl,
+  EngMetaiMatch,
+  EngStrLwr,
+  EngStrUpr,
+  EngFatToStr,
+  EngStrToFat,
+  "en"
+};
+
+/**
+  The user Entry Point for English module.
+ 
+  This function initializes unicode character mapping and then installs Unicode
+  Collation & Unicode Collation 2 Protocols based on the feature flags.  
+
+  @param  ImageHandle    The firmware allocated handle for the EFI image.  
+  @param  SystemTable    A pointer to the EFI System Table.
+  
+  @retval EFI_SUCCESS    The entry point is executed successfully.
+  @retval other          Some error occurs when executing this entry point.
+
+**/
+EFI_STATUS
+EFIAPI
+InitializeUnicodeCollationEng (
+  IN EFI_HANDLE       ImageHandle,
+  IN EFI_SYSTEM_TABLE *SystemTable
+  )
+{
+  EFI_STATUS  Status;
+  UINTN       Index;
+  UINTN       Index2;
+  VOID        *Instance;
+  BOOLEAN     AlreadyInstalled = FALSE;
+
+  if (!EFI_ERROR (gBS->LocateProtocol (&gEfiUnicodeCollation2ProtocolGuid, NULL, &Instance))) {
+    Print(L"gEfiUnicodeCollation2ProtocolGuid already installed\n");
+	AlreadyInstalled = TRUE;
+  }
+  // it seems that gEfiUnicodeCollationProtocolGuid is not needed
+  //if (!EFI_ERROR (gBS->LocateProtocol (&gEfiUnicodeCollationProtocolGuid, NULL, &Instance))) {
+  //  Print(L"gEfiUnicodeCollationProtocolGuid already installed\n");
+  //}
+  
+  if (AlreadyInstalled) {
+	return EFI_ALREADY_STARTED;
+  }
+
+  //
+  // Initialize mapping tables for the supported languages
+  //
+  for (Index = 0; Index < MAP_TABLE_SIZE; Index++) {
+    mEngUpperMap[Index] = (CHAR8) Index;
+    mEngLowerMap[Index] = (CHAR8) Index;
+    mEngInfoMap[Index]  = 0;
+
+    if ((Index >= 'a' && Index <= 'z') || (Index >= 0xe0 && Index <= 0xf6) || (Index >= 0xf8 && Index <= 0xfe)) {
+
+      Index2                = Index - 0x20;
+      mEngUpperMap[Index]   = (CHAR8) Index2;
+      mEngLowerMap[Index2]  = (CHAR8) Index;
+
+      mEngInfoMap[Index] |= CHAR_FAT_VALID;
+      mEngInfoMap[Index2] |= CHAR_FAT_VALID;
+    }
+  }
+
+  for (Index = 0; mOtherChars[Index] != 0; Index++) {
+    Index2 = mOtherChars[Index];
+    mEngInfoMap[Index2] |= CHAR_FAT_VALID;
+  }
+
+  if (FeaturePcdGet (PcdUnicodeCollation2Support)) {
+    if (FeaturePcdGet (PcdUnicodeCollationSupport)) {
+      Status = gBS->InstallMultipleProtocolInterfaces (
+                      &mHandle,
+                      &gEfiUnicodeCollationProtocolGuid,
+                      &UnicodeEng,
+                      &gEfiUnicodeCollation2ProtocolGuid,
+                      &Unicode2Eng,
+                      NULL
+                      );
+ Print(L"Installed UnicodeCollatio, UnicodeCollation2 = %r\n", Status);
+      ASSERT_EFI_ERROR (Status);
+    } else {
+      Status = gBS->InstallMultipleProtocolInterfaces (
+                      &mHandle,
+                      &gEfiUnicodeCollation2ProtocolGuid,
+                      &Unicode2Eng,
+                      NULL
+                      );
+ Print(L"Installed UnicodeCollation2 = %r\n", Status);
+      ASSERT_EFI_ERROR (Status);
+    }
+  } else {
+    if (FeaturePcdGet (PcdUnicodeCollationSupport)) {
+      Status = gBS->InstallMultipleProtocolInterfaces (
+                      &mHandle,
+                      &gEfiUnicodeCollationProtocolGuid,
+                      &UnicodeEng,
+                      NULL
+                      );
+ Print(L"Installed UnicodeCollation = %r\n", Status);
+      ASSERT_EFI_ERROR (Status);
+    } else {
+      //
+      // This module must support to produce at least one of Unicode Collation Protocol
+      // and Unicode Collation 2 Protocol.
+      //
+ Print(L"Unicode not configured = \n");
+      ASSERT (FALSE);
+      Status = EFI_UNSUPPORTED;
+    }
+  }
+
+  return Status;
+}
+
+
+/**
+  Performs a case-insensitive comparison of two Null-terminated strings.
+
+  @param  This Protocol instance pointer.
+  @param  Str1 A pointer to a Null-terminated string.
+  @param  Str2 A pointer to a Null-terminated string.
+
+  @retval 0   Str1 is equivalent to Str2
+  @retval > 0 Str1 is lexically greater than Str2
+  @retval < 0 Str1 is lexically less than Str2
+
+**/
+INTN
+EFIAPI
+EngStriColl (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN CHAR16                           *Str1,
+  IN CHAR16                           *Str2
+  )
+{
+  while (*Str1 != 0) {
+    if (TO_UPPER (*Str1) != TO_UPPER (*Str2)) {
+      break;
+    }
+
+    Str1 += 1;
+    Str2 += 1;
+  }
+
+  return TO_UPPER (*Str1) - TO_UPPER (*Str2);
+}
+
+
+/**
+  Converts all the characters in a Null-terminated string to 
+  lower case characters.
+
+  @param  This   Protocol instance pointer.
+  @param  Str    A pointer to a Null-terminated string.
+
+**/
+VOID
+EFIAPI
+EngStrLwr (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN OUT CHAR16                       *Str
+  )
+{
+  while (*Str != 0) {
+    *Str = TO_LOWER (*Str);
+    Str += 1;
+  }
+}
+
+
+/**
+  Converts all the characters in a Null-terminated string to upper
+  case characters.
+
+  @param  This   Protocol instance pointer.
+  @param  Str    A pointer to a Null-terminated string.
+
+**/
+VOID
+EFIAPI
+EngStrUpr (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN OUT CHAR16                       *Str
+  )
+{
+  while (*Str != 0) {
+    *Str = TO_UPPER (*Str);
+    Str += 1;
+  }
+}
+
+/**
+  Performs a case-insensitive comparison of a Null-terminated
+  pattern string and a Null-terminated string.
+
+  @param  This    Protocol instance pointer.
+  @param  String  A pointer to a Null-terminated string.
+  @param  Pattern A pointer to a Null-terminated pattern string.
+
+  @retval TRUE    Pattern was found in String.
+  @retval FALSE   Pattern was not found in String.
+
+**/
+BOOLEAN
+EFIAPI
+EngMetaiMatch (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN CHAR16                           *String,
+  IN CHAR16                           *Pattern
+  )
+{
+  CHAR16  CharC;
+  CHAR16  CharP;
+  CHAR16  Index3;
+
+  for (;;) {
+    CharP = *Pattern;
+    Pattern += 1;
+
+    switch (CharP) {
+    case 0:
+      //
+      // End of pattern.  If end of string, TRUE match
+      //
+      if (*String != 0) {
+        return FALSE;
+      } else {
+        return TRUE;
+      }
+
+    case '*':
+      //
+      // Match zero or more chars
+      //
+      while (*String != 0) {
+        if (EngMetaiMatch (This, String, Pattern)) {
+          return TRUE;
+        }
+
+        String += 1;
+      }
+
+      return EngMetaiMatch (This, String, Pattern);
+
+    case '?':
+      //
+      // Match any one char
+      //
+      if (*String == 0) {
+        return FALSE;
+      }
+
+      String += 1;
+      break;
+
+    case '[':
+      //
+      // Match char set
+      //
+      CharC = *String;
+      if (CharC == 0) {
+        //
+        // syntax problem
+        //
+        return FALSE;
+      }
+
+      Index3  = 0;
+      CharP   = *Pattern++;
+      while (CharP != 0) {
+        if (CharP == ']') {
+          return FALSE;
+        }
+
+        if (CharP == '-') {
+          //
+          // if range of chars, get high range
+          //
+          CharP = *Pattern;
+          if (CharP == 0 || CharP == ']') {
+            //
+            // syntax problem
+            //
+            return FALSE;
+          }
+
+          if (TO_UPPER (CharC) >= TO_UPPER (Index3) && TO_UPPER (CharC) <= TO_UPPER (CharP)) {
+            //
+            // if in range, it's a match
+            //
+            break;
+          }
+        }
+
+        Index3 = CharP;
+        if (TO_UPPER (CharC) == TO_UPPER (CharP)) {
+          //
+          // if char matches
+          //
+          break;
+        }
+
+        CharP = *Pattern++;
+      }
+      //
+      // skip to end of match char set
+      //
+      while ((CharP != 0) && (CharP != ']')) {
+        CharP = *Pattern;
+        Pattern += 1;
+      }
+
+      String += 1;
+      break;
+
+    default:
+      CharC = *String;
+      if (TO_UPPER (CharC) != TO_UPPER (CharP)) {
+        return FALSE;
+      }
+
+      String += 1;
+      break;
+    }
+  }
+}
+
+
+/**
+  Converts an 8.3 FAT file name in an OEM character set to a Null-terminated string.
+
+  @param  This    Protocol instance pointer.
+  @param  FatSize The size of the string Fat in bytes.
+  @param  Fat     A pointer to a Null-terminated string that contains an 8.3 file
+                  name using an 8-bit OEM character set.
+  @param  String  A pointer to a Null-terminated string. The string must
+                  be preallocated to hold FatSize characters.
+
+**/
+VOID
+EFIAPI
+EngFatToStr (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN UINTN                            FatSize,
+  IN CHAR8                            *Fat,
+  OUT CHAR16                          *String
+  )
+{
+  //
+  // No DBCS issues, just expand and add null terminate to end of string
+  //
+  while ((*Fat != 0) && (FatSize != 0)) {
+    *String = *Fat;
+    String += 1;
+    Fat += 1;
+    FatSize -= 1;
+  }
+
+  *String = 0;
+}
+
+
+/**
+  Converts a Null-terminated string to legal characters in a FAT 
+  filename using an OEM character set. 
+
+  @param  This    Protocol instance pointer.
+  @param  String  A pointer to a Null-terminated string. The string must
+                  be preallocated to hold FatSize characters.
+  @param  FatSize The size of the string Fat in bytes.
+  @param  Fat     A pointer to a Null-terminated string that contains an 8.3 file
+                  name using an OEM character set.
+
+  @retval TRUE    Fat is a Long File Name
+  @retval FALSE   Fat is an 8.3 file name
+
+**/
+BOOLEAN
+EFIAPI
+EngStrToFat (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN CHAR16                           *String,
+  IN UINTN                            FatSize,
+  OUT CHAR8                           *Fat
+  )
+{
+  BOOLEAN SpecialCharExist;
+
+  SpecialCharExist = FALSE;
+  while ((*String != 0) && (FatSize != 0)) {
+    //
+    // Skip '.' or ' ' when making a fat name
+    //
+    if (*String != '.' && *String != ' ') {
+      //
+      // If this is a valid fat char, move it.
+      // Otherwise, move a '_' and flag the fact that the name needs a long file name.
+      //
+      if (*String < MAP_TABLE_SIZE && ((mEngInfoMap[*String] & CHAR_FAT_VALID) != 0)) {
+        *Fat = mEngUpperMap[*String];
+      } else {
+        *Fat              = '_';
+        SpecialCharExist  = TRUE;
+      }
+
+      Fat += 1;
+      FatSize -= 1;
+    }
+
+    String += 1;
+  }
+  //
+  // Do not terminate that fat string
+  //
+  return SpecialCharExist;
+}
Index: Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/UnicodeCollationEng.h
===================================================================
--- Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/UnicodeCollationEng.h	(revision 0)
+++ Library/UefiHiiServicesLibWithDrv/UnicodeCollation/EnglishDxe/UnicodeCollationEng.h	(working copy)
@@ -0,0 +1,187 @@
+/** @file
+  Head file for Unicode Collation Protocol (English)
+
+Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _UNICODE_COLLATION_ENG_H_
+#define _UNICODE_COLLATION_ENG_H_
+
+
+
+#include <Uefi.h>
+
+#include <Protocol/UnicodeCollation.h>
+
+#include <Library/DebugLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/PcdLib.h>
+
+//
+// Bit mask to indicate the validity of character in FAT file name.
+//
+#define CHAR_FAT_VALID  0x01
+
+//
+// Maximum FAT table size.
+//
+#define MAP_TABLE_SIZE  0x100
+
+//
+// Macro to map character a to upper case.
+//
+#define TO_UPPER(a)      (CHAR16) ((a) <= 0xFF ? mEngUpperMap[a] : (a))
+
+//
+// Macro to map character a to lower case.
+//
+#define TO_LOWER(a)      (CHAR16) ((a) <= 0xFF ? mEngLowerMap[a] : (a))
+
+//
+// Prototypes
+//
+/**
+  Performs a case-insensitive comparison of two Null-terminated strings.
+
+  @param  This Protocol instance pointer.
+  @param  Str1 A pointer to a Null-terminated string.
+  @param  Str2 A pointer to a Null-terminated string.
+
+  @retval 0   Str1 is equivalent to Str2
+  @retval > 0 Str1 is lexically greater than Str2
+  @retval < 0 Str1 is lexically less than Str2
+
+**/
+INTN
+EFIAPI
+EngStriColl (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN CHAR16                           *Str1,
+  IN CHAR16                           *Str2
+  );
+
+/**
+  Performs a case-insensitive comparison of a Null-terminated
+  pattern string and a Null-terminated string.
+
+  @param  This    Protocol instance pointer.
+  @param  String  A pointer to a Null-terminated string.
+  @param  Pattern A pointer to a Null-terminated pattern string.
+
+  @retval TRUE    Pattern was found in String.
+  @retval FALSE   Pattern was not found in String.
+
+**/
+BOOLEAN
+EFIAPI
+EngMetaiMatch (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN CHAR16                           *String,
+  IN CHAR16                           *Pattern
+  );
+
+/**
+  Converts all the characters in a Null-terminated string to 
+  lower case characters.
+
+  @param  This   Protocol instance pointer.
+  @param  Str    A pointer to a Null-terminated string.
+
+**/
+VOID
+EFIAPI
+EngStrLwr (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN OUT CHAR16                       *Str
+  );
+
+/**
+  Converts all the characters in a Null-terminated string to upper
+  case characters.
+
+  @param  This   Protocol instance pointer.
+  @param  Str    A pointer to a Null-terminated string.
+
+**/
+VOID
+EFIAPI
+EngStrUpr (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN OUT CHAR16                       *Str
+  );
+
+/**
+  Converts an 8.3 FAT file name in an OEM character set to a Null-terminated string.
+
+  @param  This    Protocol instance pointer.
+  @param  FatSize The size of the string Fat in bytes.
+  @param  Fat     A pointer to a Null-terminated string that contains an 8.3 file
+                  name using an 8-bit OEM character set.
+  @param  String  A pointer to a Null-terminated string. The string must
+                  be preallocated to hold FatSize characters.
+
+**/
+VOID
+EFIAPI
+EngFatToStr (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN UINTN                            FatSize,
+  IN CHAR8                            *Fat,
+  OUT CHAR16                          *String
+  );
+
+/**
+  Converts a Null-terminated string to legal characters in a FAT 
+  filename using an OEM character set. 
+
+  @param  This    Protocol instance pointer.
+  @param  String  A pointer to a Null-terminated string. The string must
+                  be preallocated to hold FatSize characters.
+  @param  FatSize The size of the string Fat in bytes.
+  @param  Fat     A pointer to a Null-terminated string that contains an 8.3 file
+                  name using an OEM character set.
+
+  @retval TRUE    Fat is a Long File Name
+  @retval FALSE   Fat is an 8.3 file name
+
+**/
+BOOLEAN
+EFIAPI
+EngStrToFat (
+  IN EFI_UNICODE_COLLATION_PROTOCOL   *This,
+  IN CHAR16                           *String,
+  IN UINTN                            FatSize,
+  OUT CHAR8                           *Fat
+  );
+
+/**
+  The user Entry Point for English module.
+ 
+  This function initializes unicode character mapping and then installs Unicode
+  Collation & Unicode Collation 2 Protocols based on the feature flags.  
+
+  @param  ImageHandle    The firmware allocated handle for the EFI image.  
+  @param  SystemTable    A pointer to the EFI System Table.
+  
+  @retval EFI_SUCCESS    The entry point is executed successfully.
+  @retval other          Some error occurs when executing this entry point.
+
+**/
+EFI_STATUS
+EFIAPI
+InitializeUnicodeCollationEng (
+  IN EFI_HANDLE       ImageHandle,
+  IN EFI_SYSTEM_TABLE *SystemTable
+  );
+
+#endif
+
Index: Library/UefiShellDebug1CommandsLib/DmpStore.c
===================================================================
--- Library/UefiShellDebug1CommandsLib/DmpStore.c	(revision 13225)
+++ Library/UefiShellDebug1CommandsLib/DmpStore.c	(working copy)
@@ -64,6 +64,9 @@
     return (SHELL_DEVICE_ERROR);
   }
 
+  // dmazar: AMI Aptio 2.0 returns 0 as MaxVarSize - fix it
+  if (MaxVarSize <= 0) MaxVarSize = 16384;
+  
   Found         = FALSE;
   ShellStatus   = SHELL_SUCCESS;
   Size          = PcdGet16(PcdShellFileOperationSize);
Index: Library/UefiShellLevel2CommandsLib/Load.c
===================================================================
--- Library/UefiShellLevel2CommandsLib/Load.c	(revision 13225)
+++ Library/UefiShellLevel2CommandsLib/Load.c	(working copy)
@@ -36,7 +36,8 @@
   UINTN       HandleCount;
   EFI_HANDLE  *HandleBuffer;
   UINTN       Index;
-
+  VOID       *Interface;
+  
   Status = gBS->LocateHandleBuffer (
                   AllHandles,
                   NULL,
@@ -49,7 +50,10 @@
   }
 
   for (Index = 0; Index < HandleCount; Index++) {
-    Status = gBS->ConnectController (HandleBuffer[Index], NULL, NULL, TRUE);
+    Status = gBS->HandleProtocol(HandleBuffer[Index], &gEfiShellProtocolGuid, &Interface);
+	if (EFI_ERROR(Status)) {
+      Status = gBS->ConnectController (HandleBuffer[Index], NULL, NULL, TRUE);
+	}
   }
 
   if (HandleBuffer != NULL) {
Index: ShellPkg.dsc
===================================================================
--- ShellPkg.dsc	(revision 13225)
+++ ShellPkg.dsc	(working copy)
@@ -36,7 +36,8 @@
   BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
   PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
   UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
-  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
+  #UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
+  UefiHiiServicesLib|ShellPkg/Library/UefiHiiServicesLibWithDrv/UefiHiiServicesLib.inf
   HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
   NetLib|MdeModulePkg/Library/DxeNetLib/DxeNetLib.inf
 
@@ -58,6 +59,13 @@
   #
   NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
 
+[PcdsFeatureFlag]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSupportHiiImageProtocol|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathFromText|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDevicePathSupportDevicePathToText|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollationSupport|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUnicodeCollation2Support|TRUE
+
 [PcdsFixedAtBuild]
   gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0xFF
   gEfiShellPkgTokenSpaceGuid.PcdShellLibAutoInitialize|FALSE
@@ -85,4 +93,5 @@
       NULL|ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf
 !endif
   }
+  #ShellPkg/Application/Bcfg/Bcfg.inf
 
